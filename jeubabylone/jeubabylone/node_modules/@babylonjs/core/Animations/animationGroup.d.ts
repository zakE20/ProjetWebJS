import { Animatable } from "./animatable";
import { Animation } from "./animation";
import { Scene, IDisposable } from "../scene";
import { Observable } from "../Misc/observable";
import { Nullable } from "../types";
import "./animatable";
/**
 * This class defines the direct association between an animation and a target
 */
export declare class TargetedAnimation {
    /**
     * Animation to perform
     */
    animation: Animation;
    /**
     * Target to animate
     */
    target: any;
}
/**
 * Use this class to create coordinated animations on multiple targets
 */
export declare class AnimationGroup implements IDisposable {
    /** The name of the animation group */
    name: string;
    private _scene;
    private _targetedAnimations;
    private _animatables;
    private _from;
    private _to;
    private _isStarted;
    private _isPaused;
    private _speedRatio;
    private _loopAnimation;
    /**
     * Gets or sets the unique id of the node
     */
    uniqueId: number;
    /**
     * This observable will notify when one animation have ended
     */
    onAnimationEndObservable: Observable<TargetedAnimation>;
    /**
     * Observer raised when one animation loops
     */
    onAnimationLoopObservable: Observable<TargetedAnimation>;
    /**
     * This observable will notify when all animations have ended.
     */
    onAnimationGroupEndObservable: Observable<AnimationGroup>;
    /**
     * This observable will notify when all animations have paused.
     */
    onAnimationGroupPauseObservable: Observable<AnimationGroup>;
    /**
     * This observable will notify when all animations are playing.
     */
    onAnimationGroupPlayObservable: Observable<AnimationGroup>;
    /**
     * Gets the first frame
     */
    readonly from: number;
    /**
     * Gets the last frame
     */
    readonly to: number;
    /**
     * Define if the animations are started
     */
    readonly isStarted: boolean;
    /**
     * Gets a value indicating that the current group is playing
     */
    readonly isPlaying: boolean;
    /**
     * Gets or sets the speed ratio to use for all animations
     */
    /**
    * Gets or sets the speed ratio to use for all animations
    */
    speedRatio: number;
    /**
     * Gets or sets if all animations should loop or not
     */
    loopAnimation: boolean;
    /**
     * Gets the targeted animations for this animation group
     */
    readonly targetedAnimations: Array<TargetedAnimation>;
    /**
     * returning the list of animatables controlled by this animation group.
     */
    readonly animatables: Array<Animatable>;
    /**
     * Instantiates a new Animation Group.
     * This helps managing several animations at once.
     * @see http://doc.babylonjs.com/how_to/group
     * @param name Defines the name of the group
     * @param scene Defines the scene the group belongs to
     */
    constructor(
    /** The name of the animation group */
    name: string, scene?: Nullable<Scene>);
    /**
     * Add an animation (with its target) in the group
     * @param animation defines the animation we want to add
     * @param target defines the target of the animation
     * @returns the TargetedAnimation object
     */
    addTargetedAnimation(animation: Animation, target: any): TargetedAnimation;
    /**
     * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame
     * It can add constant keys at begin or end
     * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)
     * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)
     * @returns the animation group
     */
    normalize(beginFrame?: Nullable<number>, endFrame?: Nullable<number>): AnimationGroup;
    /**
     * Start all animations on given targets
     * @param loop defines if animations must loop
     * @param speedRatio defines the ratio to apply to animation speed (1 by default)
     * @param from defines the from key (optional)
     * @param to defines the to key (optional)
     * @returns the current animation group
     */
    start(loop?: boolean, speedRatio?: number, from?: number, to?: number): AnimationGroup;
    /**
     * Pause all animations
     * @returns the animation group
     */
    pause(): AnimationGroup;
    /**
     * Play all animations to initial state
     * This function will start() the animations if they were not started or will restart() them if they were paused
     * @param loop defines if animations must loop
     * @returns the animation group
     */
    play(loop?: boolean): AnimationGroup;
    /**
     * Reset all animations to initial state
     * @returns the animation group
     */
    reset(): AnimationGroup;
    /**
     * Restart animations from key 0
     * @returns the animation group
     */
    restart(): AnimationGroup;
    /**
     * Stop all animations
     * @returns the animation group
     */
    stop(): AnimationGroup;
    /**
     * Set animation weight for all animatables
     * @param weight defines the weight to use
     * @return the animationGroup
     * @see http://doc.babylonjs.com/babylon101/animations#animation-weights
     */
    setWeightForAllAnimatables(weight: number): AnimationGroup;
    /**
     * Synchronize and normalize all animatables with a source animatable
     * @param root defines the root animatable to synchronize with
     * @return the animationGroup
     * @see http://doc.babylonjs.com/babylon101/animations#animation-weights
     */
    syncAllAnimationsWith(root: Animatable): AnimationGroup;
    /**
     * Goes to a specific frame in this animation group
     * @param frame the frame number to go to
     * @return the animationGroup
     */
    goToFrame(frame: number): AnimationGroup;
    /**
     * Dispose all associated resources
     */
    dispose(): void;
    private _checkAnimationGroupEnded;
    /**
     * Clone the current animation group and returns a copy
     * @param newName defines the name of the new group
     * @param targetConverter defines an optional function used to convert current animation targets to new ones
     * @returns the new aniamtion group
     */
    clone(newName: string, targetConverter?: (oldTarget: any) => any): AnimationGroup;
    /**
     * Returns a new AnimationGroup object parsed from the source provided.
     * @param parsedAnimationGroup defines the source
     * @param scene defines the scene that will receive the animationGroup
     * @returns a new AnimationGroup
     */
    static Parse(parsedAnimationGroup: any, scene: Scene): AnimationGroup;
    /**
     * Returns the string "AnimationGroup"
     * @returns "AnimationGroup"
     */
    getClassName(): string;
    /**
     * Creates a detailled string about the object
     * @param fullDetails defines if the output string will support multiple levels of logging within scene loading
     * @returns a string representing the object
     */
    toString(fullDetails?: boolean): string;
}
