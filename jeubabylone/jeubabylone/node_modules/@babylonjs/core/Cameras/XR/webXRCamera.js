import * as tslib_1 from "tslib";
import { Vector3, Matrix, Quaternion, Viewport } from "../../Maths/math";
import { Camera } from "../../Cameras/camera";
import { FreeCamera } from "../../Cameras/freeCamera";
import { TargetCamera } from "../../Cameras/targetCamera";
/**
 * WebXR Camera which holds the views for the xrSession
 * @see https://doc.babylonjs.com/how_to/webxr
 */
var WebXRCamera = /** @class */ (function (_super) {
    tslib_1.__extends(WebXRCamera, _super);
    /**
     * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager
     * @param name the name of the camera
     * @param scene the scene to add the camera to
     */
    function WebXRCamera(name, scene) {
        var _this = _super.call(this, name, Vector3.Zero(), scene) || this;
        // Initial camera configuration
        _this.minZ = 0;
        _this.rotationQuaternion = new Quaternion();
        _this.cameraRigMode = Camera.RIG_MODE_CUSTOM;
        _this.updateUpVectorFromRotation = true;
        _this._updateNumberOfRigCameras(1);
        return _this;
    }
    WebXRCamera.prototype._updateNumberOfRigCameras = function (viewCount) {
        if (viewCount === void 0) { viewCount = 1; }
        while (this.rigCameras.length < viewCount) {
            var newCamera = new TargetCamera("view: " + this.rigCameras.length, Vector3.Zero(), this.getScene());
            newCamera.minZ = 0;
            newCamera.parent = this;
            newCamera.rotationQuaternion = new Quaternion();
            newCamera.updateUpVectorFromRotation = true;
            this.rigCameras.push(newCamera);
        }
        while (this.rigCameras.length > viewCount) {
            var removedCamera = this.rigCameras.pop();
            if (removedCamera) {
                removedCamera.dispose();
            }
        }
    };
    /** @hidden */
    WebXRCamera.prototype._updateForDualEyeDebugging = function (pupilDistance) {
        if (pupilDistance === void 0) { pupilDistance = 0.01; }
        // Create initial camera rigs
        this._updateNumberOfRigCameras(2);
        this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);
        this.rigCameras[0].position.x = -pupilDistance / 2;
        this.rigCameras[0].outputRenderTarget = null;
        this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);
        this.rigCameras[1].position.x = pupilDistance / 2;
        this.rigCameras[1].outputRenderTarget = null;
    };
    /**
     * Updates the cameras position from the current pose information of the  XR session
     * @param xrSessionManager the session containing pose information
     * @returns true if the camera has been updated, false if the session did not contain pose or frame data
     */
    WebXRCamera.prototype.updateFromXRSessionManager = function (xrSessionManager) {
        var _this = this;
        // Ensure all frame data is available
        if (!xrSessionManager._currentXRFrame || !xrSessionManager._currentXRFrame.getDevicePose) {
            return false;
        }
        var pose = xrSessionManager._currentXRFrame.getDevicePose(xrSessionManager._frameOfReference);
        if (!pose || !pose.poseModelMatrix) {
            return false;
        }
        // Update the parent cameras matrix
        Matrix.FromFloat32ArrayToRefScaled(pose.poseModelMatrix, 0, 1, WebXRCamera._TmpMatrix);
        if (!this._scene.useRightHandedSystem) {
            WebXRCamera._TmpMatrix.toggleModelMatrixHandInPlace();
        }
        WebXRCamera._TmpMatrix.getTranslationToRef(this.position);
        WebXRCamera._TmpMatrix.getRotationMatrixToRef(WebXRCamera._TmpMatrix);
        Quaternion.FromRotationMatrixToRef(WebXRCamera._TmpMatrix, this.rotationQuaternion);
        this.computeWorldMatrix();
        // Update camera rigs
        this._updateNumberOfRigCameras(xrSessionManager._currentXRFrame.views.length);
        xrSessionManager._currentXRFrame.views.forEach(function (view, i) {
            // Update view/projection matrix
            Matrix.FromFloat32ArrayToRefScaled(pose.getViewMatrix(view), 0, 1, _this.rigCameras[i]._computedViewMatrix);
            Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, _this.rigCameras[i]._projectionMatrix);
            if (!_this._scene.useRightHandedSystem) {
                _this.rigCameras[i]._computedViewMatrix.toggleModelMatrixHandInPlace();
                _this.rigCameras[i]._projectionMatrix.toggleProjectionMatrixHandInPlace();
            }
            // Update viewport
            var viewport = xrSessionManager._xrSession.baseLayer.getViewport(view);
            var width = xrSessionManager._xrSession.baseLayer.framebufferWidth;
            var height = xrSessionManager._xrSession.baseLayer.framebufferHeight;
            _this.rigCameras[i].viewport.width = viewport.width / width;
            _this.rigCameras[i].viewport.height = viewport.height / height;
            _this.rigCameras[i].viewport.x = viewport.x / width;
            _this.rigCameras[i].viewport.y = viewport.y / height;
            // Set cameras to render to the session's render target
            _this.rigCameras[i].outputRenderTarget = xrSessionManager._sessionRenderTargetTexture;
        });
        return true;
    };
    WebXRCamera._TmpMatrix = new Matrix();
    return WebXRCamera;
}(FreeCamera));
export { WebXRCamera };
//# sourceMappingURL=webXRCamera.js.map