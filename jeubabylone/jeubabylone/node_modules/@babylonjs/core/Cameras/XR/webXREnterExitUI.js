import * as tslib_1 from "tslib";
import { Observable } from "../../Misc/observable";
import { WebXRState } from "./webXRExperienceHelper";
/**
 * Button which can be used to enter a different mode of XR
 */
var WebXREnterExitUIButton = /** @class */ (function () {
    /**
     * Creates a WebXREnterExitUIButton
     * @param element button element
     * @param initializationOptions XR initialization options for the button
     */
    function WebXREnterExitUIButton(
    /** button element */
    element, 
    /** XR initialization options for the button */
    initializationOptions) {
        this.element = element;
        this.initializationOptions = initializationOptions;
    }
    /**
     * Overwritable function which can be used to update the button's visuals when the state changes
     * @param activeButton the current active button in the UI
     */
    WebXREnterExitUIButton.prototype.update = function (activeButton) {
    };
    return WebXREnterExitUIButton;
}());
export { WebXREnterExitUIButton };
/**
 * Options to create the webXR UI
 */
var WebXREnterExitUIOptions = /** @class */ (function () {
    function WebXREnterExitUIOptions() {
    }
    return WebXREnterExitUIOptions;
}());
export { WebXREnterExitUIOptions };
/**
 * UI to allow the user to enter/exit XR mode
 */
var WebXREnterExitUI = /** @class */ (function () {
    function WebXREnterExitUI(scene, options) {
        var _this = this;
        this.scene = scene;
        this._buttons = [];
        this._activeButton = null;
        /**
         * Fired every time the active button is changed.
         *
         * When xr is entered via a button that launches xr that button will be the callback parameter
         *
         * When exiting xr the callback parameter will be null)
         */
        this.activeButtonChangedObservable = new Observable();
        this._overlay = document.createElement("div");
        this._overlay.style.cssText = "z-index:11;position: absolute; right: 20px;bottom: 50px;";
        if (options.customButtons) {
            this._buttons = options.customButtons;
        }
        else {
            var hmdBtn = document.createElement("button");
            hmdBtn.style.cssText = "color: #868686; border-color: #868686; border-style: solid; margin-left: 10px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-repeat:no-repeat; background-position: center; outline: none;";
            hmdBtn.innerText = "HMD";
            this._buttons.push(new WebXREnterExitUIButton(hmdBtn, { immersive: true, outputContext: options.outputCanvasContext }));
            this._buttons[this._buttons.length - 1].update = function (activeButton) {
                this.element.style.display = (activeButton === null || activeButton === this) ? "" : "none";
                this.element.innerText = activeButton === this ? "EXIT" : "HMD";
            };
            var windowBtn = document.createElement("button");
            windowBtn.style.cssText = hmdBtn.style.cssText;
            windowBtn.innerText = "Window";
            this._buttons.push(new WebXREnterExitUIButton(windowBtn, { immersive: false, environmentIntegration: true, outputContext: options.outputCanvasContext }));
            this._buttons[this._buttons.length - 1].update = function (activeButton) {
                this.element.style.display = (activeButton === null || activeButton === this) ? "" : "none";
                this.element.innerText = activeButton === this ? "EXIT" : "Window";
            };
            this._updateButtons(null);
        }
        var renderCanvas = scene.getEngine().getRenderingCanvas();
        if (renderCanvas && renderCanvas.parentNode) {
            renderCanvas.parentNode.appendChild(this._overlay);
            scene.onDisposeObservable.addOnce(function () {
                _this.dispose();
            });
        }
    }
    /**
     * Creates UI to allow the user to enter/exit XR mode
     * @param scene the scene to add the ui to
     * @param helper the xr experience helper to enter/exit xr with
     * @param options options to configure the UI
     * @returns the created ui
     */
    WebXREnterExitUI.CreateAsync = function (scene, helper, options) {
        var _this = this;
        var ui = new WebXREnterExitUI(scene, options);
        var supportedPromises = ui._buttons.map(function (btn) {
            return helper.supportsSessionAsync(btn.initializationOptions);
        });
        helper.onStateChangedObservable.add(function (state) {
            if (state == WebXRState.NOT_IN_XR) {
                ui._updateButtons(null);
            }
        });
        return Promise.all(supportedPromises).then(function (results) {
            results.forEach(function (supported, i) {
                if (supported) {
                    ui._overlay.appendChild(ui._buttons[i].element);
                    ui._buttons[i].element.onclick = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!(helper.state == WebXRState.IN_XR)) return [3 /*break*/, 2];
                                    ui._updateButtons(null);
                                    return [4 /*yield*/, helper.exitXRAsync()];
                                case 1:
                                    _a.sent();
                                    return [2 /*return*/];
                                case 2:
                                    if (!(helper.state == WebXRState.NOT_IN_XR)) return [3 /*break*/, 4];
                                    ui._updateButtons(ui._buttons[i]);
                                    return [4 /*yield*/, helper.enterXRAsync(ui._buttons[i].initializationOptions, "eye-level")];
                                case 3:
                                    _a.sent();
                                    _a.label = 4;
                                case 4: return [2 /*return*/];
                            }
                        });
                    }); };
                }
            });
            return ui;
        });
    };
    WebXREnterExitUI.prototype._updateButtons = function (activeButton) {
        var _this = this;
        this._activeButton = activeButton;
        this._buttons.forEach(function (b) {
            b.update(_this._activeButton);
        });
        this.activeButtonChangedObservable.notifyObservers(this._activeButton);
    };
    /**
     * Disposes of the object
     */
    WebXREnterExitUI.prototype.dispose = function () {
        var renderCanvas = this.scene.getEngine().getRenderingCanvas();
        if (renderCanvas && renderCanvas.parentNode && renderCanvas.parentNode.contains(this._overlay)) {
            renderCanvas.parentNode.removeChild(this._overlay);
        }
        this.activeButtonChangedObservable.clear();
    };
    return WebXREnterExitUI;
}());
export { WebXREnterExitUI };
//# sourceMappingURL=webXREnterExitUI.js.map