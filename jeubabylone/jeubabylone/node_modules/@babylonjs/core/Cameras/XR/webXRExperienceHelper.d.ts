import { Nullable } from "../../types";
import { Observable } from "../../Misc/observable";
import { IDisposable, Scene } from "../../scene";
import { Quaternion, Vector3 } from "../../Maths/math";
import { AbstractMesh } from "../../Meshes/abstractMesh";
import { Ray } from "../../Culling/ray";
import { WebXRSessionManager } from "./webXRSessionManager";
import { WebXRCamera } from "./webXRCamera";
/**
 * States of the webXR experience
 */
export declare enum WebXRState {
    /**
     * Transitioning to being in XR mode
     */
    ENTERING_XR = 0,
    /**
     * Transitioning to non XR mode
     */
    EXITING_XR = 1,
    /**
     * In XR mode and presenting
     */
    IN_XR = 2,
    /**
     * Not entered XR mode
     */
    NOT_IN_XR = 3
}
/**
 * Helper class used to enable XR
 * @see https://doc.babylonjs.com/how_to/webxr
 */
export declare class WebXRExperienceHelper implements IDisposable {
    private scene;
    /**
     * Container which stores the xr camera and controllers as children. This can be used to move the camera/user as the camera's position is updated by the xr device
     */
    container: AbstractMesh;
    /**
     * Camera used to render xr content
     */
    camera: WebXRCamera;
    /**
     * The current state of the XR experience (eg. transitioning, in XR or not in XR)
     */
    state: WebXRState;
    private _setState;
    private static _TmpVector;
    /**
     * Fires when the state of the experience helper has changed
     */
    onStateChangedObservable: Observable<WebXRState>;
    /** @hidden */
    _sessionManager: WebXRSessionManager;
    private _nonVRCamera;
    private _originalSceneAutoClear;
    private _supported;
    /**
     * Creates the experience helper
     * @param scene the scene to attach the experience helper to
     * @returns a promise for the experience helper
     */
    static CreateAsync(scene: Scene): Promise<WebXRExperienceHelper>;
    /**
     * Creates a WebXRExperienceHelper
     * @param scene The scene the helper should be created in
     */
    private constructor();
    /**
     * Exits XR mode and returns the scene to its original state
     * @returns promise that resolves after xr mode has exited
     */
    exitXRAsync(): Promise<void>;
    /**
     * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)
     * @param sessionCreationOptions options for the XR session
     * @param frameOfReference frame of reference of the XR session
     * @returns promise that resolves after xr mode has entered
     */
    enterXRAsync(sessionCreationOptions: XRSessionCreationOptions, frameOfReference: string): Promise<void>;
    /**
     * Fires a ray and returns the closest hit in the xr sessions enviornment, useful to place objects in AR
     * @param ray ray to cast into the environment
     * @returns Promise which resolves with a collision point in the environment if it exists
     */
    environmentPointHitTestAsync(ray: Ray): Promise<Nullable<Vector3>>;
    /**
     * Updates the global position of the camera by moving the camera's container
     * This should be used instead of modifying the camera's position as it will be overwritten by an xrSessions's update frame
     * @param position The desired global position of the camera
     */
    setPositionOfCameraUsingContainer(position: Vector3): void;
    /**
     * Rotates the xr camera by rotating the camera's container around the camera's position
     * This should be used instead of modifying the camera's rotation as it will be overwritten by an xrSessions's update frame
     * @param rotation the desired quaternion rotation to apply to the camera
     */
    rotateCameraByQuaternionUsingContainer(rotation: Quaternion): void;
    /**
     * Checks if the creation options are supported by the xr session
     * @param options creation options
     * @returns true if supported
     */
    supportsSessionAsync(options: XRSessionCreationOptions): Promise<boolean>;
    /**
     * Disposes of the experience helper
     */
    dispose(): void;
}
