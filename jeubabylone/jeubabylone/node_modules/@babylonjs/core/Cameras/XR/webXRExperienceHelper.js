import { Observable } from "../../Misc/observable";
import { Quaternion, Vector3 } from "../../Maths/math";
import { AbstractMesh } from "../../Meshes/abstractMesh";
import { WebXRSessionManager } from "./webXRSessionManager";
import { WebXRCamera } from "./webXRCamera";
/**
 * States of the webXR experience
 */
export var WebXRState;
(function (WebXRState) {
    /**
     * Transitioning to being in XR mode
     */
    WebXRState[WebXRState["ENTERING_XR"] = 0] = "ENTERING_XR";
    /**
     * Transitioning to non XR mode
     */
    WebXRState[WebXRState["EXITING_XR"] = 1] = "EXITING_XR";
    /**
     * In XR mode and presenting
     */
    WebXRState[WebXRState["IN_XR"] = 2] = "IN_XR";
    /**
     * Not entered XR mode
     */
    WebXRState[WebXRState["NOT_IN_XR"] = 3] = "NOT_IN_XR";
})(WebXRState || (WebXRState = {}));
/**
 * Helper class used to enable XR
 * @see https://doc.babylonjs.com/how_to/webxr
 */
var WebXRExperienceHelper = /** @class */ (function () {
    /**
     * Creates a WebXRExperienceHelper
     * @param scene The scene the helper should be created in
     */
    function WebXRExperienceHelper(scene) {
        this.scene = scene;
        /**
         * The current state of the XR experience (eg. transitioning, in XR or not in XR)
         */
        this.state = WebXRState.NOT_IN_XR;
        /**
         * Fires when the state of the experience helper has changed
         */
        this.onStateChangedObservable = new Observable();
        this._nonVRCamera = null;
        this._originalSceneAutoClear = true;
        this._supported = false;
        this.camera = new WebXRCamera("", scene);
        this._sessionManager = new WebXRSessionManager(scene);
        this.container = new AbstractMesh("", scene);
        this.camera.parent = this.container;
    }
    WebXRExperienceHelper.prototype._setState = function (val) {
        this.state = val;
        this.onStateChangedObservable.notifyObservers(this.state);
    };
    /**
     * Creates the experience helper
     * @param scene the scene to attach the experience helper to
     * @returns a promise for the experience helper
     */
    WebXRExperienceHelper.CreateAsync = function (scene) {
        var helper = new WebXRExperienceHelper(scene);
        return helper._sessionManager.initializeAsync().then(function () {
            helper._supported = true;
            return helper;
        }).catch(function () {
            return helper;
        });
    };
    /**
     * Exits XR mode and returns the scene to its original state
     * @returns promise that resolves after xr mode has exited
     */
    WebXRExperienceHelper.prototype.exitXRAsync = function () {
        this._setState(WebXRState.EXITING_XR);
        return this._sessionManager.exitXRAsync();
    };
    /**
     * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)
     * @param sessionCreationOptions options for the XR session
     * @param frameOfReference frame of reference of the XR session
     * @returns promise that resolves after xr mode has entered
     */
    WebXRExperienceHelper.prototype.enterXRAsync = function (sessionCreationOptions, frameOfReference) {
        var _this = this;
        if (!this._supported) {
            throw "XR session not supported by this browser";
        }
        this._setState(WebXRState.ENTERING_XR);
        return this._sessionManager.enterXRAsync(sessionCreationOptions, frameOfReference).then(function () {
            // Cache pre xr scene settings
            _this._originalSceneAutoClear = _this.scene.autoClear;
            _this._nonVRCamera = _this.scene.activeCamera;
            // Overwrite current scene settings
            _this.scene.autoClear = false;
            _this.scene.activeCamera = _this.camera;
            _this._sessionManager.onXRFrameObservable.add(function () {
                _this.camera.updateFromXRSessionManager(_this._sessionManager);
            });
            _this._sessionManager.onXRSessionEnded.addOnce(function () {
                // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends
                _this.camera.rigCameras.forEach(function (c) {
                    c.outputRenderTarget = null;
                });
                // Restore scene settings
                _this.scene.autoClear = _this._originalSceneAutoClear;
                _this.scene.activeCamera = _this._nonVRCamera;
                _this._sessionManager.onXRFrameObservable.clear();
                _this._setState(WebXRState.NOT_IN_XR);
            });
            _this._setState(WebXRState.IN_XR);
        });
    };
    /**
     * Fires a ray and returns the closest hit in the xr sessions enviornment, useful to place objects in AR
     * @param ray ray to cast into the environment
     * @returns Promise which resolves with a collision point in the environment if it exists
     */
    WebXRExperienceHelper.prototype.environmentPointHitTestAsync = function (ray) {
        return this._sessionManager.environmentPointHitTestAsync(ray);
    };
    /**
     * Updates the global position of the camera by moving the camera's container
     * This should be used instead of modifying the camera's position as it will be overwritten by an xrSessions's update frame
     * @param position The desired global position of the camera
     */
    WebXRExperienceHelper.prototype.setPositionOfCameraUsingContainer = function (position) {
        this.camera.globalPosition.subtractToRef(position, WebXRExperienceHelper._TmpVector);
        this.container.position.subtractInPlace(WebXRExperienceHelper._TmpVector);
    };
    /**
     * Rotates the xr camera by rotating the camera's container around the camera's position
     * This should be used instead of modifying the camera's rotation as it will be overwritten by an xrSessions's update frame
     * @param rotation the desired quaternion rotation to apply to the camera
     */
    WebXRExperienceHelper.prototype.rotateCameraByQuaternionUsingContainer = function (rotation) {
        if (!this.container.rotationQuaternion) {
            this.container.rotationQuaternion = Quaternion.FromEulerVector(this.container.rotation);
        }
        this.container.rotationQuaternion.multiplyInPlace(rotation);
        this.container.position.rotateByQuaternionAroundPointToRef(rotation, this.camera.globalPosition, this.container.position);
    };
    /**
     * Checks if the creation options are supported by the xr session
     * @param options creation options
     * @returns true if supported
     */
    WebXRExperienceHelper.prototype.supportsSessionAsync = function (options) {
        if (!this._supported) {
            return Promise.resolve(false);
        }
        return this._sessionManager.supportsSessionAsync(options);
    };
    /**
     * Disposes of the experience helper
     */
    WebXRExperienceHelper.prototype.dispose = function () {
        this.camera.dispose();
        this.container.dispose();
        this.onStateChangedObservable.clear();
        this._sessionManager.dispose();
    };
    WebXRExperienceHelper._TmpVector = new Vector3();
    return WebXRExperienceHelper;
}());
export { WebXRExperienceHelper };
//# sourceMappingURL=webXRExperienceHelper.js.map