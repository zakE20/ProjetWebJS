{"version":3,"file":"webXRExperienceHelper.js","sourceRoot":"","sources":["../../../../sourceES6/core/Cameras/XR/webXRExperienceHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { IDisposable, Scene } from \"../../scene\";\r\nimport { Quaternion, Vector3 } from \"../../Maths/math\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { WebXRCamera } from \"./webXRCamera\";\r\n/**\r\n * States of the webXR experience\r\n */\r\nexport enum WebXRState {\r\n    /**\r\n     * Transitioning to being in XR mode\r\n     */\r\n    ENTERING_XR,\r\n    /**\r\n     * Transitioning to non XR mode\r\n     */\r\n    EXITING_XR,\r\n    /**\r\n     * In XR mode and presenting\r\n     */\r\n    IN_XR,\r\n    /**\r\n     * Not entered XR mode\r\n     */\r\n    NOT_IN_XR\r\n}\r\n/**\r\n * Helper class used to enable XR\r\n * @see https://doc.babylonjs.com/how_to/webxr\r\n */\r\nexport class WebXRExperienceHelper implements IDisposable {\r\n    /**\r\n     * Container which stores the xr camera and controllers as children. This can be used to move the camera/user as the camera's position is updated by the xr device\r\n     */\r\n    public container: AbstractMesh;\r\n    /**\r\n     * Camera used to render xr content\r\n     */\r\n    public camera: WebXRCamera;\r\n\r\n    /**\r\n     * The current state of the XR experience (eg. transitioning, in XR or not in XR)\r\n     */\r\n    public state: WebXRState = WebXRState.NOT_IN_XR;\r\n\r\n    private _setState(val: WebXRState) {\r\n        this.state = val;\r\n        this.onStateChangedObservable.notifyObservers(this.state);\r\n    }\r\n\r\n    private static _TmpVector = new Vector3();\r\n\r\n    /**\r\n     * Fires when the state of the experience helper has changed\r\n     */\r\n    public onStateChangedObservable = new Observable<WebXRState>();\r\n\r\n    /** @hidden */\r\n    public _sessionManager: WebXRSessionManager;\r\n\r\n    private _nonVRCamera: Nullable<Camera> = null;\r\n    private _originalSceneAutoClear = true;\r\n\r\n    private _supported = false;\r\n\r\n    /**\r\n     * Creates the experience helper\r\n     * @param scene the scene to attach the experience helper to\r\n     * @returns a promise for the experience helper\r\n     */\r\n    public static CreateAsync(scene: Scene): Promise<WebXRExperienceHelper> {\r\n        var helper = new WebXRExperienceHelper(scene);\r\n        return helper._sessionManager.initializeAsync().then(() => {\r\n            helper._supported = true;\r\n            return helper;\r\n        }).catch(() => {\r\n            return helper;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a WebXRExperienceHelper\r\n     * @param scene The scene the helper should be created in\r\n     */\r\n    private constructor(private scene: Scene) {\r\n        this.camera = new WebXRCamera(\"\", scene);\r\n        this._sessionManager = new WebXRSessionManager(scene);\r\n        this.container = new AbstractMesh(\"\", scene);\r\n        this.camera.parent = this.container;\r\n    }\r\n\r\n    /**\r\n     * Exits XR mode and returns the scene to its original state\r\n     * @returns promise that resolves after xr mode has exited\r\n     */\r\n    public exitXRAsync() {\r\n        this._setState(WebXRState.EXITING_XR);\r\n        return this._sessionManager.exitXRAsync();\r\n    }\r\n\r\n    /**\r\n     * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)\r\n     * @param sessionCreationOptions options for the XR session\r\n     * @param frameOfReference frame of reference of the XR session\r\n     * @returns promise that resolves after xr mode has entered\r\n     */\r\n    public enterXRAsync(sessionCreationOptions: XRSessionCreationOptions, frameOfReference: string) {\r\n        if (!this._supported) {\r\n            throw \"XR session not supported by this browser\";\r\n        }\r\n        this._setState(WebXRState.ENTERING_XR);\r\n\r\n        return this._sessionManager.enterXRAsync(sessionCreationOptions, frameOfReference).then(() => {\r\n            // Cache pre xr scene settings\r\n            this._originalSceneAutoClear = this.scene.autoClear;\r\n            this._nonVRCamera = this.scene.activeCamera;\r\n\r\n            // Overwrite current scene settings\r\n            this.scene.autoClear = false;\r\n            this.scene.activeCamera = this.camera;\r\n\r\n            this._sessionManager.onXRFrameObservable.add(() => {\r\n                this.camera.updateFromXRSessionManager(this._sessionManager);\r\n            });\r\n\r\n            this._sessionManager.onXRSessionEnded.addOnce(() => {\r\n                // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends\r\n                this.camera.rigCameras.forEach((c) => {\r\n                    c.outputRenderTarget = null;\r\n                });\r\n\r\n                // Restore scene settings\r\n                this.scene.autoClear = this._originalSceneAutoClear;\r\n                this.scene.activeCamera = this._nonVRCamera;\r\n                this._sessionManager.onXRFrameObservable.clear();\r\n\r\n                this._setState(WebXRState.NOT_IN_XR);\r\n            });\r\n            this._setState(WebXRState.IN_XR);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fires a ray and returns the closest hit in the xr sessions enviornment, useful to place objects in AR\r\n     * @param ray ray to cast into the environment\r\n     * @returns Promise which resolves with a collision point in the environment if it exists\r\n     */\r\n    public environmentPointHitTestAsync(ray: Ray): Promise<Nullable<Vector3>> {\r\n        return this._sessionManager.environmentPointHitTestAsync(ray);\r\n    }\r\n\r\n    /**\r\n     * Updates the global position of the camera by moving the camera's container\r\n     * This should be used instead of modifying the camera's position as it will be overwritten by an xrSessions's update frame\r\n     * @param position The desired global position of the camera\r\n     */\r\n    public setPositionOfCameraUsingContainer(position: Vector3) {\r\n        this.camera.globalPosition.subtractToRef(position, WebXRExperienceHelper._TmpVector);\r\n        this.container.position.subtractInPlace(WebXRExperienceHelper._TmpVector);\r\n    }\r\n\r\n    /**\r\n     * Rotates the xr camera by rotating the camera's container around the camera's position\r\n     * This should be used instead of modifying the camera's rotation as it will be overwritten by an xrSessions's update frame\r\n     * @param rotation the desired quaternion rotation to apply to the camera\r\n     */\r\n    public rotateCameraByQuaternionUsingContainer(rotation: Quaternion) {\r\n        if (!this.container.rotationQuaternion) {\r\n            this.container.rotationQuaternion = Quaternion.FromEulerVector(this.container.rotation);\r\n        }\r\n        this.container.rotationQuaternion.multiplyInPlace(rotation);\r\n        this.container.position.rotateByQuaternionAroundPointToRef(rotation, this.camera.globalPosition, this.container.position);\r\n    }\r\n\r\n    /**\r\n     * Checks if the creation options are supported by the xr session\r\n     * @param options creation options\r\n     * @returns true if supported\r\n     */\r\n    public supportsSessionAsync(options: XRSessionCreationOptions) {\r\n        if (!this._supported) {\r\n            return Promise.resolve(false);\r\n        }\r\n        return this._sessionManager.supportsSessionAsync(options);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the experience helper\r\n     */\r\n    public dispose() {\r\n        this.camera.dispose();\r\n        this.container.dispose();\r\n        this.onStateChangedObservable.clear();\r\n        this._sessionManager.dispose();\r\n    }\r\n}\r\n"]}