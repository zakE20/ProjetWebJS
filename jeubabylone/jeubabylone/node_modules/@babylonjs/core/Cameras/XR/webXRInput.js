import { Matrix, Quaternion } from "../../Maths/math";
import { AbstractMesh } from "../../Meshes/abstractMesh";
/**
 * Represents an XR input
 */
var WebXRController = /** @class */ (function () {
    /**
     * Creates the controller
     * @see https://doc.babylonjs.com/how_to/webxr
     * @param scene the scene which the controller should be associated to
     */
    function WebXRController(scene) {
        this.pointer = new AbstractMesh("controllerPointer", scene);
    }
    /**
     * Disposes of the object
     */
    WebXRController.prototype.dispose = function () {
        if (this.grip) {
            this.grip.dispose();
        }
        this.pointer.dispose();
    };
    return WebXRController;
}());
export { WebXRController };
/**
 * XR input used to track XR inputs such as controllers/rays
 */
var WebXRInput = /** @class */ (function () {
    /**
     * Initializes the WebXRInput
     * @param helper experience helper which the input should be created for
     */
    function WebXRInput(helper) {
        var _this = this;
        this.helper = helper;
        /**
         * XR controllers being tracked
         */
        this.controllers = [];
        this._tmpMatrix = new Matrix();
        this._frameObserver = helper._sessionManager.onXRFrameObservable.add(function () {
            if (!helper._sessionManager._currentXRFrame || !helper._sessionManager._currentXRFrame.getDevicePose) {
                return;
            }
            var xrFrame = helper._sessionManager._currentXRFrame;
            var inputSources = helper._sessionManager._xrSession.getInputSources();
            inputSources.forEach(function (input, i) {
                var inputPose = xrFrame.getInputPose(input, helper._sessionManager._frameOfReference);
                if (inputPose) {
                    if (_this.controllers.length <= i) {
                        _this.controllers.push(new WebXRController(helper.container.getScene()));
                    }
                    var controller = _this.controllers[i];
                    // Manage the grip if it exists
                    if (inputPose.gripMatrix) {
                        if (!controller.grip) {
                            controller.grip = new AbstractMesh("controllerGrip", helper.container.getScene());
                        }
                        Matrix.FromFloat32ArrayToRefScaled(inputPose.gripMatrix, 0, 1, _this._tmpMatrix);
                        if (!controller.grip.getScene().useRightHandedSystem) {
                            _this._tmpMatrix.toggleModelMatrixHandInPlace();
                        }
                        if (!controller.grip.rotationQuaternion) {
                            controller.grip.rotationQuaternion = new Quaternion();
                        }
                        _this._tmpMatrix.decompose(controller.grip.scaling, controller.grip.rotationQuaternion, controller.grip.position);
                    }
                    // Manager pointer of controller
                    Matrix.FromFloat32ArrayToRefScaled(inputPose.targetRay.transformMatrix, 0, 1, _this._tmpMatrix);
                    if (!controller.pointer.getScene().useRightHandedSystem) {
                        _this._tmpMatrix.toggleModelMatrixHandInPlace();
                    }
                    if (!controller.pointer.rotationQuaternion) {
                        controller.pointer.rotationQuaternion = new Quaternion();
                    }
                    _this._tmpMatrix.decompose(controller.pointer.scaling, controller.pointer.rotationQuaternion, controller.pointer.position);
                }
            });
        });
    }
    /**
     * Disposes of the object
     */
    WebXRInput.prototype.dispose = function () {
        this.controllers.forEach(function (c) {
            c.dispose();
        });
        this.helper._sessionManager.onXRFrameObservable.remove(this._frameObserver);
    };
    return WebXRInput;
}());
export { WebXRInput };
//# sourceMappingURL=webXRInput.js.map