import { Logger } from "../../Misc/logger";
import { Observable } from "../../Misc/observable";
import { Matrix } from "../../Maths/math";
import { InternalTexture } from "../../Materials/Textures/internalTexture";
import { RenderTargetTexture } from "../../Materials/Textures/renderTargetTexture";
/**
 * Manages an XRSession
 * @see https://doc.babylonjs.com/how_to/webxr
 */
var WebXRSessionManager = /** @class */ (function () {
    /**
     * Constructs a WebXRSessionManager, this must be initialized within a user action before usage
     * @param scene The scene which the session should be created for
     */
    function WebXRSessionManager(scene) {
        this.scene = scene;
        /**
         * Fires every time a new xrFrame arrives which can be used to update the camera
         */
        this.onXRFrameObservable = new Observable();
        /**
         * Fires when the xr session is ended either by the device or manually done
         */
        this.onXRSessionEnded = new Observable();
        /** @hidden */
        this._sessionRenderTargetTexture = null;
        this._tmpMatrix = new Matrix();
    }
    /**
     * Initializes the manager
     * After initialization enterXR can be called to start an XR session
     * @returns Promise which resolves after it is initialized
     */
    WebXRSessionManager.prototype.initializeAsync = function () {
        var _this = this;
        Logger.Warn("The WebXR APIs are still under development and are subject to change in the future.");
        // Check if the browser supports webXR
        this._xrNavigator = navigator;
        if (!this._xrNavigator.xr) {
            return Promise.reject("webXR not supported by this browser");
        }
        // Request the webXR device
        return this._xrNavigator.xr.requestDevice().then(function (device) {
            _this._xrDevice = device;
            return _this.scene.getEngine()._gl.setCompatibleXRDevice(_this._xrDevice);
        });
    };
    /**
     * Enters XR with the desired XR session options, this must be done with a user action (eg. button click event)
     * @param sessionCreationOptions xr options to create the session with
     * @param frameOfReferenceType option to configure how the xr pose is expressed
     * @returns Promise which resolves after it enters XR
     */
    WebXRSessionManager.prototype.enterXRAsync = function (sessionCreationOptions, frameOfReferenceType) {
        var _this = this;
        // initialize session
        return this._xrDevice.requestSession(sessionCreationOptions).then(function (session) {
            _this._xrSession = session;
            // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)
            _this._xrSession.addEventListener("end", function () {
                // Remove render target texture and notify frame obervers
                _this._sessionRenderTargetTexture = null;
                // Restore frame buffer to avoid clear on xr framebuffer after session end
                _this.scene.getEngine().restoreDefaultFramebuffer();
                // Need to restart render loop as after the session is ended the last request for new frame will never call callback
                _this.scene.getEngine().customAnimationFrameRequester = null;
                _this.onXRSessionEnded.notifyObservers(null);
                _this.scene.getEngine()._renderLoop();
            }, { once: true });
            _this._xrSession.baseLayer = new XRWebGLLayer(_this._xrSession, _this.scene.getEngine()._gl);
            return _this._xrSession.requestFrameOfReference(frameOfReferenceType);
        }).then(function (frameOfRef) {
            _this._frameOfReference = frameOfRef;
            // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information
            _this.scene.getEngine().customAnimationFrameRequester = {
                requestAnimationFrame: _this._xrSession.requestAnimationFrame.bind(_this._xrSession),
                renderFunction: function (timestamp, xrFrame) {
                    // Store the XR frame in the manager to be consumed by the XR camera to update pose
                    _this._currentXRFrame = xrFrame;
                    _this.onXRFrameObservable.notifyObservers(null);
                    _this.scene.getEngine()._renderLoop();
                }
            };
            // Create render target texture from xr's webgl render target
            _this._sessionRenderTargetTexture = WebXRSessionManager._CreateRenderTargetTextureFromSession(_this._xrSession, _this.scene);
            // Stop window's animation frame and trigger sessions animation frame
            window.cancelAnimationFrame(_this.scene.getEngine()._frameHandler);
            _this.scene.getEngine()._renderLoop();
        });
    };
    /**
     * Stops the xrSession and restores the renderloop
     * @returns Promise which resolves after it exits XR
     */
    WebXRSessionManager.prototype.exitXRAsync = function () {
        return this._xrSession.end();
    };
    /**
     * Fires a ray and returns the closest hit in the xr sessions enviornment, useful to place objects in AR
     * @param ray ray to cast into the environment
     * @returns Promise which resolves with a collision point in the environment if it exists
     */
    WebXRSessionManager.prototype.environmentPointHitTestAsync = function (ray) {
        var _this = this;
        return new Promise(function (res) {
            // Compute left handed inputs to request hit test
            var origin = new Float32Array([ray.origin.x, ray.origin.y, ray.origin.z]);
            var direction = new Float32Array([ray.direction.x, ray.direction.y, ray.direction.z]);
            if (!_this.scene.useRightHandedSystem) {
                origin[2] *= -1;
                direction[2] *= -1;
            }
            // Fire hittest
            _this._xrSession.requestHitTest(origin, direction, _this._frameOfReference)
                .then(function (hits) {
                if (hits.length > 0) {
                    Matrix.FromFloat32ArrayToRefScaled(hits[0].hitMatrix, 0, 1.0, _this._tmpMatrix);
                    var hitPoint = _this._tmpMatrix.getTranslation();
                    if (!_this.scene.useRightHandedSystem) {
                        hitPoint.z *= -1;
                    }
                    res(hitPoint);
                }
                else {
                    res(null);
                }
            }).catch(function () {
                res(null);
            });
        });
    };
    /**
     * Checks if a session would be supported for the creation options specified
     * @param options creation options to check if they are supported
     * @returns true if supported
     */
    WebXRSessionManager.prototype.supportsSessionAsync = function (options) {
        return this._xrDevice.supportsSession(options).then(function () {
            return true;
        }).catch(function () {
            return false;
        });
    };
    /**
     * @hidden
     * Converts the render layer of xrSession to a render target
     * @param session session to create render target for
     * @param scene scene the new render target should be created for
     */
    WebXRSessionManager._CreateRenderTargetTextureFromSession = function (session, scene) {
        // Create internal texture
        var internalTexture = new InternalTexture(scene.getEngine(), InternalTexture.DATASOURCE_UNKNOWN, true);
        internalTexture.width = session.baseLayer.framebufferWidth;
        internalTexture.height = session.baseLayer.framebufferHeight;
        internalTexture._framebuffer = session.baseLayer.framebuffer;
        // Create render target texture from the internal texture
        var renderTargetTexture = new RenderTargetTexture("XR renderTargetTexture", { width: internalTexture.width, height: internalTexture.height }, scene, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);
        renderTargetTexture._texture = internalTexture;
        return renderTargetTexture;
    };
    /**
     * Disposes of the session manager
     */
    WebXRSessionManager.prototype.dispose = function () {
        this.onXRFrameObservable.clear();
        this.onXRSessionEnded.clear();
    };
    return WebXRSessionManager;
}());
export { WebXRSessionManager };
//# sourceMappingURL=webXRSessionManager.js.map