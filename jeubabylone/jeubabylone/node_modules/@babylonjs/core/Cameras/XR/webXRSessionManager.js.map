{"version":3,"file":"webXRSessionManager.js","sourceRoot":"","sources":["../../../../sourceES6/core/Cameras/XR/webXRSessionManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Nullable } from \"../../types\";\r\nimport { IDisposable, Scene } from \"../../scene\";\r\nimport { Vector3, Matrix } from \"../../Maths/math\";\r\nimport { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { Ray } from \"../../Culling/ray\";\r\n/**\r\n * Manages an XRSession\r\n * @see https://doc.babylonjs.com/how_to/webxr\r\n */\r\nexport class WebXRSessionManager implements IDisposable {\r\n    /**\r\n     * Fires every time a new xrFrame arrives which can be used to update the camera\r\n     */\r\n    public onXRFrameObservable: Observable<any> = new Observable<any>();\r\n    /**\r\n     * Fires when the xr session is ended either by the device or manually done\r\n     */\r\n    public onXRSessionEnded: Observable<any> = new Observable<any>();\r\n\r\n    /** @hidden */\r\n    public _xrSession: XRSession;\r\n    /** @hidden */\r\n    public _frameOfReference: XRFrameOfReference;\r\n    /** @hidden */\r\n    public _sessionRenderTargetTexture: Nullable<RenderTargetTexture> = null;\r\n    /** @hidden */\r\n    public _currentXRFrame: Nullable<XRFrame>;\r\n    private _xrNavigator: any;\r\n    private _xrDevice: XRDevice;\r\n    private _tmpMatrix = new Matrix();\r\n\r\n    /**\r\n     * Constructs a WebXRSessionManager, this must be initialized within a user action before usage\r\n     * @param scene The scene which the session should be created for\r\n     */\r\n    constructor(private scene: Scene) {\r\n\r\n    }\r\n\r\n    /**\r\n     * Initializes the manager\r\n     * After initialization enterXR can be called to start an XR session\r\n     * @returns Promise which resolves after it is initialized\r\n     */\r\n    public initializeAsync(): Promise<void> {\r\n        Logger.Warn(\"The WebXR APIs are still under development and are subject to change in the future.\");\r\n        // Check if the browser supports webXR\r\n        this._xrNavigator = navigator;\r\n        if (!this._xrNavigator.xr) {\r\n            return Promise.reject(\"webXR not supported by this browser\");\r\n        }\r\n        // Request the webXR device\r\n        return this._xrNavigator.xr.requestDevice().then((device: XRDevice) => {\r\n            this._xrDevice = device;\r\n            return (<any>this.scene.getEngine()._gl).setCompatibleXRDevice(this._xrDevice);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Enters XR with the desired XR session options, this must be done with a user action (eg. button click event)\r\n     * @param sessionCreationOptions xr options to create the session with\r\n     * @param frameOfReferenceType option to configure how the xr pose is expressed\r\n     * @returns Promise which resolves after it enters XR\r\n     */\r\n    public enterXRAsync(sessionCreationOptions: XRSessionCreationOptions, frameOfReferenceType: string): Promise<void> {\r\n        // initialize session\r\n        return this._xrDevice.requestSession(sessionCreationOptions).then((session: XRSession) => {\r\n            this._xrSession = session;\r\n\r\n            // handle when the session is ended (By calling session.end or device ends its own session eg. pressing home button on phone)\r\n            this._xrSession.addEventListener(\"end\", () => {\r\n                // Remove render target texture and notify frame obervers\r\n                this._sessionRenderTargetTexture = null;\r\n\r\n                // Restore frame buffer to avoid clear on xr framebuffer after session end\r\n                this.scene.getEngine().restoreDefaultFramebuffer();\r\n\r\n                // Need to restart render loop as after the session is ended the last request for new frame will never call callback\r\n                this.scene.getEngine().customAnimationFrameRequester = null;\r\n                this.onXRSessionEnded.notifyObservers(null);\r\n                this.scene.getEngine()._renderLoop();\r\n            }, { once: true });\r\n\r\n            this._xrSession.baseLayer = new XRWebGLLayer(this._xrSession, this.scene.getEngine()._gl);\r\n            return this._xrSession.requestFrameOfReference(frameOfReferenceType);\r\n        }).then((frameOfRef: any) => {\r\n            this._frameOfReference = frameOfRef;\r\n            // Tell the engine's render loop to be driven by the xr session's refresh rate and provide xr pose information\r\n            this.scene.getEngine().customAnimationFrameRequester = {\r\n                requestAnimationFrame: this._xrSession.requestAnimationFrame.bind(this._xrSession),\r\n                renderFunction: (timestamp: number, xrFrame: Nullable<XRFrame>) => {\r\n                    // Store the XR frame in the manager to be consumed by the XR camera to update pose\r\n                    this._currentXRFrame = xrFrame;\r\n                    this.onXRFrameObservable.notifyObservers(null);\r\n                    this.scene.getEngine()._renderLoop();\r\n                }\r\n            };\r\n            // Create render target texture from xr's webgl render target\r\n            this._sessionRenderTargetTexture = WebXRSessionManager._CreateRenderTargetTextureFromSession(this._xrSession, this.scene);\r\n\r\n            // Stop window's animation frame and trigger sessions animation frame\r\n            window.cancelAnimationFrame(this.scene.getEngine()._frameHandler);\r\n            this.scene.getEngine()._renderLoop();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Stops the xrSession and restores the renderloop\r\n     * @returns Promise which resolves after it exits XR\r\n     */\r\n    public exitXRAsync() {\r\n        return this._xrSession.end();\r\n    }\r\n\r\n    /**\r\n     * Fires a ray and returns the closest hit in the xr sessions enviornment, useful to place objects in AR\r\n     * @param ray ray to cast into the environment\r\n     * @returns Promise which resolves with a collision point in the environment if it exists\r\n     */\r\n    public environmentPointHitTestAsync(ray: Ray): Promise<Nullable<Vector3>> {\r\n        return new Promise((res) => {\r\n            // Compute left handed inputs to request hit test\r\n            var origin = new Float32Array([ray.origin.x, ray.origin.y, ray.origin.z]);\r\n            var direction = new Float32Array([ray.direction.x, ray.direction.y, ray.direction.z]);\r\n            if (!this.scene.useRightHandedSystem) {\r\n                origin[2] *= -1;\r\n                direction[2] *= -1;\r\n            }\r\n\r\n            // Fire hittest\r\n            this._xrSession.requestHitTest(origin, direction, this._frameOfReference)\r\n                .then((hits: any) => {\r\n                    if (hits.length > 0) {\r\n                        Matrix.FromFloat32ArrayToRefScaled(hits[0].hitMatrix, 0, 1.0, this._tmpMatrix);\r\n                        var hitPoint = this._tmpMatrix.getTranslation();\r\n                        if (!this.scene.useRightHandedSystem) {\r\n                            hitPoint.z *= -1;\r\n                        }\r\n                        res(hitPoint);\r\n                    } else {\r\n                        res(null);\r\n                    }\r\n                }).catch(() => {\r\n                    res(null);\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks if a session would be supported for the creation options specified\r\n     * @param options creation options to check if they are supported\r\n     * @returns true if supported\r\n     */\r\n    public supportsSessionAsync(options: XRSessionCreationOptions) {\r\n        return this._xrDevice.supportsSession(options).then(() => {\r\n            return true;\r\n        }).catch(() => {\r\n            return false;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Converts the render layer of xrSession to a render target\r\n     * @param session session to create render target for\r\n     * @param scene scene the new render target should be created for\r\n     */\r\n    public static _CreateRenderTargetTextureFromSession(session: XRSession, scene: Scene) {\r\n        // Create internal texture\r\n        var internalTexture = new InternalTexture(scene.getEngine(), InternalTexture.DATASOURCE_UNKNOWN, true);\r\n        internalTexture.width = session.baseLayer.framebufferWidth;\r\n        internalTexture.height = session.baseLayer.framebufferHeight;\r\n        internalTexture._framebuffer = session.baseLayer.framebuffer;\r\n\r\n        // Create render target texture from the internal texture\r\n        var renderTargetTexture = new RenderTargetTexture(\"XR renderTargetTexture\", { width: internalTexture.width, height: internalTexture.height }, scene, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\r\n        renderTargetTexture._texture = internalTexture;\r\n\r\n        return renderTargetTexture;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the session manager\r\n     */\r\n    public dispose() {\r\n        this.onXRFrameObservable.clear();\r\n        this.onXRSessionEnded.clear();\r\n    }\r\n}\r\n"]}