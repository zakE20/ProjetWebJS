import { Nullable, FloatArray, IndicesArray } from "../types";
import { Scene } from "../scene";
import { Matrix, Color3, Color4, Viewport } from "../Maths/math";
import { Engine } from "../Engines/engine";
import { RenderTargetCreationOptions } from "../Materials/Textures/renderTargetCreationOptions";
import { VertexBuffer } from "../Meshes/buffer";
import { InternalTexture } from "../Materials/Textures/internalTexture";
import { Effect } from "../Materials/effect";
import { IPipelineContext } from './IPipelineContext';
import { DataBuffer } from '../Meshes/dataBuffer';
/**
 * Options to create the null engine
 */
export declare class NullEngineOptions {
    /**
     * Render width (Default: 512)
     */
    renderWidth: number;
    /**
     * Render height (Default: 256)
     */
    renderHeight: number;
    /**
     * Texture size (Default: 512)
     */
    textureSize: number;
    /**
     * If delta time between frames should be constant
     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
     */
    deterministicLockstep: boolean;
    /**
     * Maximum about of steps between frames (Default: 4)
     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
     */
    lockstepMaxSteps: number;
}
/**
 * The null engine class provides support for headless version of babylon.js.
 * This can be used in server side scenario or for testing purposes
 */
export declare class NullEngine extends Engine {
    private _options;
    /**
     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
     */
    isDeterministicLockStep(): boolean;
    /** @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep */
    getLockstepMaxSteps(): number;
    /**
     * Sets hardware scaling, used to save performance if needed
     * @see https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    getHardwareScalingLevel(): number;
    constructor(options?: NullEngineOptions);
    createVertexBuffer(vertices: FloatArray): DataBuffer;
    createIndexBuffer(indices: IndicesArray): DataBuffer;
    clear(color: Color4, backBuffer: boolean, depth: boolean, stencil?: boolean): void;
    getRenderWidth(useScreen?: boolean): number;
    getRenderHeight(useScreen?: boolean): number;
    setViewport(viewport: Viewport, requiredWidth?: number, requiredHeight?: number): void;
    createShaderProgram(pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, defines: string, context?: WebGLRenderingContext): WebGLProgram;
    getUniforms(pipelineContext: IPipelineContext, uniformsNames: string[]): Nullable<WebGLUniformLocation>[];
    getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[];
    bindSamplers(effect: Effect): void;
    enableEffect(effect: Effect): void;
    setState(culling: boolean, zOffset?: number, force?: boolean, reverseSide?: boolean): void;
    setIntArray(uniform: WebGLUniformLocation, array: Int32Array): void;
    setIntArray2(uniform: WebGLUniformLocation, array: Int32Array): void;
    setIntArray3(uniform: WebGLUniformLocation, array: Int32Array): void;
    setIntArray4(uniform: WebGLUniformLocation, array: Int32Array): void;
    setFloatArray(uniform: WebGLUniformLocation, array: Float32Array): void;
    setFloatArray2(uniform: WebGLUniformLocation, array: Float32Array): void;
    setFloatArray3(uniform: WebGLUniformLocation, array: Float32Array): void;
    setFloatArray4(uniform: WebGLUniformLocation, array: Float32Array): void;
    setArray(uniform: WebGLUniformLocation, array: number[]): void;
    setArray2(uniform: WebGLUniformLocation, array: number[]): void;
    setArray3(uniform: WebGLUniformLocation, array: number[]): void;
    setArray4(uniform: WebGLUniformLocation, array: number[]): void;
    setMatrices(uniform: WebGLUniformLocation, matrices: Float32Array): void;
    setMatrix(uniform: WebGLUniformLocation, matrix: Matrix): void;
    setMatrix3x3(uniform: WebGLUniformLocation, matrix: Float32Array): void;
    setMatrix2x2(uniform: WebGLUniformLocation, matrix: Float32Array): void;
    setFloat(uniform: WebGLUniformLocation, value: number): void;
    setFloat2(uniform: WebGLUniformLocation, x: number, y: number): void;
    setFloat3(uniform: WebGLUniformLocation, x: number, y: number, z: number): void;
    setBool(uniform: WebGLUniformLocation, bool: number): void;
    setFloat4(uniform: WebGLUniformLocation, x: number, y: number, z: number, w: number): void;
    setColor3(uniform: WebGLUniformLocation, color3: Color3): void;
    setColor4(uniform: WebGLUniformLocation, color3: Color3, alpha: number): void;
    setAlphaMode(mode: number, noDepthWriteChange?: boolean): void;
    bindBuffers(vertexBuffers: {
        [key: string]: VertexBuffer;
    }, indexBuffer: DataBuffer, effect: Effect): void;
    wipeCaches(bruteForce?: boolean): void;
    draw(useTriangles: boolean, indexStart: number, indexCount: number, instancesCount?: number): void;
    drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void;
    drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void;
    /** @hidden */
    _createTexture(): WebGLTexture;
    /** @hidden */
    _releaseTexture(texture: InternalTexture): void;
    createTexture(urlArg: string, noMipmap: boolean, invertY: boolean, scene: Scene, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<(message: string, exception: any) => void>, buffer?: Nullable<ArrayBuffer | HTMLImageElement>, fallBack?: InternalTexture, format?: number): InternalTexture;
    createRenderTargetTexture(size: any, options: boolean | RenderTargetCreationOptions): InternalTexture;
    updateTextureSamplingMode(samplingMode: number, texture: InternalTexture): void;
    bindFramebuffer(texture: InternalTexture, faceIndex?: number, requiredWidth?: number, requiredHeight?: number, forceFullscreenViewport?: boolean): void;
    unBindFramebuffer(texture: InternalTexture, disableGenerateMipMaps?: boolean, onBeforeUnbind?: () => void): void;
    createDynamicVertexBuffer(vertices: FloatArray): DataBuffer;
    updateDynamicTexture(texture: Nullable<InternalTexture>, canvas: HTMLCanvasElement, invertY: boolean, premulAlpha?: boolean, format?: number): void;
    areAllEffectsReady(): boolean;
    /**
     * @hidden
     * Get the current error code of the webGL context
     * @returns the error code
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError
     */
    getError(): number;
    /** @hidden */
    _getUnpackAlignement(): number;
    /** @hidden */
    _unpackFlipY(value: boolean): void;
    updateDynamicIndexBuffer(indexBuffer: WebGLBuffer, indices: IndicesArray, offset?: number): void;
    /**
     * Updates a dynamic vertex buffer.
     * @param vertexBuffer the vertex buffer to update
     * @param data the data used to update the vertex buffer
     * @param byteOffset the byte offset of the data (optional)
     * @param byteLength the byte length of the data (optional)
     */
    updateDynamicVertexBuffer(vertexBuffer: WebGLBuffer, vertices: FloatArray, byteOffset?: number, byteLength?: number): void;
    _bindTextureDirectly(target: number, texture: InternalTexture): boolean;
    /** @hidden */
    _bindTexture(channel: number, texture: InternalTexture): void;
    /** @hidden */
    _releaseBuffer(buffer: DataBuffer): boolean;
    releaseEffects(): void;
    displayLoadingUI(): void;
    hideLoadingUI(): void;
    /** @hidden */
    _uploadCompressedDataToTextureDirectly(texture: InternalTexture, internalFormat: number, width: number, height: number, data: ArrayBufferView, faceIndex?: number, lod?: number): void;
    /** @hidden */
    _uploadDataToTextureDirectly(texture: InternalTexture, imageData: ArrayBufferView, faceIndex?: number, lod?: number): void;
    /** @hidden */
    _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex?: number, lod?: number): void;
    /** @hidden */
    _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement, faceIndex?: number, lod?: number): void;
}
