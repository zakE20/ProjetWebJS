import * as tslib_1 from "tslib";
import { Logger } from "../Misc/logger";
import { Engine, EngineCapabilities } from "../Engines/engine";
import { RenderTargetCreationOptions } from "../Materials/Textures/renderTargetCreationOptions";
import { InternalTexture } from "../Materials/Textures/internalTexture";
import { Constants } from "./constants";
import { DataBuffer } from '../Meshes/dataBuffer';
/**
 * Options to create the null engine
 */
var NullEngineOptions = /** @class */ (function () {
    function NullEngineOptions() {
        /**
         * Render width (Default: 512)
         */
        this.renderWidth = 512;
        /**
         * Render height (Default: 256)
         */
        this.renderHeight = 256;
        /**
         * Texture size (Default: 512)
         */
        this.textureSize = 512;
        /**
         * If delta time between frames should be constant
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         */
        this.deterministicLockstep = false;
        /**
         * Maximum about of steps between frames (Default: 4)
         * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
         */
        this.lockstepMaxSteps = 4;
    }
    return NullEngineOptions;
}());
export { NullEngineOptions };
/**
 * The null engine class provides support for headless version of babylon.js.
 * This can be used in server side scenario or for testing purposes
 */
var NullEngine = /** @class */ (function (_super) {
    tslib_1.__extends(NullEngine, _super);
    function NullEngine(options) {
        if (options === void 0) { options = new NullEngineOptions(); }
        var _this = _super.call(this, null) || this;
        if (options.deterministicLockstep === undefined) {
            options.deterministicLockstep = false;
        }
        if (options.lockstepMaxSteps === undefined) {
            options.lockstepMaxSteps = 4;
        }
        _this._options = options;
        // Init caps
        // We consider we are on a webgl1 capable device
        _this._caps = new EngineCapabilities();
        _this._caps.maxTexturesImageUnits = 16;
        _this._caps.maxVertexTextureImageUnits = 16;
        _this._caps.maxTextureSize = 512;
        _this._caps.maxCubemapTextureSize = 512;
        _this._caps.maxRenderTextureSize = 512;
        _this._caps.maxVertexAttribs = 16;
        _this._caps.maxVaryingVectors = 16;
        _this._caps.maxFragmentUniformVectors = 16;
        _this._caps.maxVertexUniformVectors = 16;
        // Extensions
        _this._caps.standardDerivatives = false;
        _this._caps.astc = null;
        _this._caps.s3tc = null;
        _this._caps.pvrtc = null;
        _this._caps.etc1 = null;
        _this._caps.etc2 = null;
        _this._caps.textureAnisotropicFilterExtension = null;
        _this._caps.maxAnisotropy = 0;
        _this._caps.uintIndices = false;
        _this._caps.fragmentDepthSupported = false;
        _this._caps.highPrecisionShaderSupported = true;
        _this._caps.colorBufferFloat = false;
        _this._caps.textureFloat = false;
        _this._caps.textureFloatLinearFiltering = false;
        _this._caps.textureFloatRender = false;
        _this._caps.textureHalfFloat = false;
        _this._caps.textureHalfFloatLinearFiltering = false;
        _this._caps.textureHalfFloatRender = false;
        _this._caps.textureLOD = false;
        _this._caps.drawBuffersExtension = false;
        _this._caps.depthTextureExtension = false;
        _this._caps.vertexArrayObject = false;
        _this._caps.instancedArrays = false;
        Logger.Log("Babylon.js v" + Engine.Version + " - Null engine");
        // Wrappers
        var theCurrentGlobal = (typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : window);
        if (typeof URL === "undefined") {
            theCurrentGlobal.URL = {
                createObjectURL: function () { },
                revokeObjectURL: function () { }
            };
        }
        if (typeof Blob === "undefined") {
            theCurrentGlobal.Blob = function () { };
        }
        return _this;
    }
    /**
     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
     */
    NullEngine.prototype.isDeterministicLockStep = function () {
        return this._options.deterministicLockstep;
    };
    /** @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep */
    NullEngine.prototype.getLockstepMaxSteps = function () {
        return this._options.lockstepMaxSteps;
    };
    /**
     * Sets hardware scaling, used to save performance if needed
     * @see https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
     */
    NullEngine.prototype.getHardwareScalingLevel = function () {
        return 1.0;
    };
    NullEngine.prototype.createVertexBuffer = function (vertices) {
        var buffer = new DataBuffer();
        buffer.references = 1;
        return buffer;
    };
    NullEngine.prototype.createIndexBuffer = function (indices) {
        var buffer = new DataBuffer();
        buffer.references = 1;
        return buffer;
    };
    NullEngine.prototype.clear = function (color, backBuffer, depth, stencil) {
        if (stencil === void 0) { stencil = false; }
    };
    NullEngine.prototype.getRenderWidth = function (useScreen) {
        if (useScreen === void 0) { useScreen = false; }
        if (!useScreen && this._currentRenderTarget) {
            return this._currentRenderTarget.width;
        }
        return this._options.renderWidth;
    };
    NullEngine.prototype.getRenderHeight = function (useScreen) {
        if (useScreen === void 0) { useScreen = false; }
        if (!useScreen && this._currentRenderTarget) {
            return this._currentRenderTarget.height;
        }
        return this._options.renderHeight;
    };
    NullEngine.prototype.setViewport = function (viewport, requiredWidth, requiredHeight) {
        this._cachedViewport = viewport;
    };
    NullEngine.prototype.createShaderProgram = function (pipelineContext, vertexCode, fragmentCode, defines, context) {
        return {
            __SPECTOR_rebuildProgram: null,
        };
    };
    NullEngine.prototype.getUniforms = function (pipelineContext, uniformsNames) {
        return [];
    };
    NullEngine.prototype.getAttributes = function (pipelineContext, attributesNames) {
        return [];
    };
    NullEngine.prototype.bindSamplers = function (effect) {
        this._currentEffect = null;
    };
    NullEngine.prototype.enableEffect = function (effect) {
        this._currentEffect = effect;
        if (effect.onBind) {
            effect.onBind(effect);
        }
        if (effect._onBindObservable) {
            effect._onBindObservable.notifyObservers(effect);
        }
    };
    NullEngine.prototype.setState = function (culling, zOffset, force, reverseSide) {
        if (zOffset === void 0) { zOffset = 0; }
        if (reverseSide === void 0) { reverseSide = false; }
    };
    NullEngine.prototype.setIntArray = function (uniform, array) {
    };
    NullEngine.prototype.setIntArray2 = function (uniform, array) {
    };
    NullEngine.prototype.setIntArray3 = function (uniform, array) {
    };
    NullEngine.prototype.setIntArray4 = function (uniform, array) {
    };
    NullEngine.prototype.setFloatArray = function (uniform, array) {
    };
    NullEngine.prototype.setFloatArray2 = function (uniform, array) {
    };
    NullEngine.prototype.setFloatArray3 = function (uniform, array) {
    };
    NullEngine.prototype.setFloatArray4 = function (uniform, array) {
    };
    NullEngine.prototype.setArray = function (uniform, array) {
    };
    NullEngine.prototype.setArray2 = function (uniform, array) {
    };
    NullEngine.prototype.setArray3 = function (uniform, array) {
    };
    NullEngine.prototype.setArray4 = function (uniform, array) {
    };
    NullEngine.prototype.setMatrices = function (uniform, matrices) {
    };
    NullEngine.prototype.setMatrix = function (uniform, matrix) {
    };
    NullEngine.prototype.setMatrix3x3 = function (uniform, matrix) {
    };
    NullEngine.prototype.setMatrix2x2 = function (uniform, matrix) {
    };
    NullEngine.prototype.setFloat = function (uniform, value) {
    };
    NullEngine.prototype.setFloat2 = function (uniform, x, y) {
    };
    NullEngine.prototype.setFloat3 = function (uniform, x, y, z) {
    };
    NullEngine.prototype.setBool = function (uniform, bool) {
    };
    NullEngine.prototype.setFloat4 = function (uniform, x, y, z, w) {
    };
    NullEngine.prototype.setColor3 = function (uniform, color3) {
    };
    NullEngine.prototype.setColor4 = function (uniform, color3, alpha) {
    };
    NullEngine.prototype.setAlphaMode = function (mode, noDepthWriteChange) {
        if (noDepthWriteChange === void 0) { noDepthWriteChange = false; }
        if (this._alphaMode === mode) {
            return;
        }
        this._alphaState.alphaBlend = (mode !== Constants.ALPHA_DISABLE);
        if (!noDepthWriteChange) {
            this.setDepthWrite(mode === Constants.ALPHA_DISABLE);
        }
        this._alphaMode = mode;
    };
    NullEngine.prototype.bindBuffers = function (vertexBuffers, indexBuffer, effect) {
    };
    NullEngine.prototype.wipeCaches = function (bruteForce) {
        if (this.preventCacheWipeBetweenFrames) {
            return;
        }
        this.resetTextureCache();
        this._currentEffect = null;
        if (bruteForce) {
            this._currentProgram = null;
            this._stencilState.reset();
            this._depthCullingState.reset();
            this._alphaState.reset();
        }
        this._cachedVertexBuffers = null;
        this._cachedIndexBuffer = null;
        this._cachedEffectForVertexBuffers = null;
    };
    NullEngine.prototype.draw = function (useTriangles, indexStart, indexCount, instancesCount) {
    };
    NullEngine.prototype.drawElementsType = function (fillMode, indexStart, indexCount, instancesCount) {
    };
    NullEngine.prototype.drawArraysType = function (fillMode, verticesStart, verticesCount, instancesCount) {
    };
    /** @hidden */
    NullEngine.prototype._createTexture = function () {
        return {};
    };
    /** @hidden */
    NullEngine.prototype._releaseTexture = function (texture) {
    };
    NullEngine.prototype.createTexture = function (urlArg, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallBack, format) {
        if (samplingMode === void 0) { samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE; }
        if (onLoad === void 0) { onLoad = null; }
        if (onError === void 0) { onError = null; }
        if (buffer === void 0) { buffer = null; }
        var texture = new InternalTexture(this, InternalTexture.DATASOURCE_URL);
        var url = String(urlArg);
        texture.url = url;
        texture.generateMipMaps = !noMipmap;
        texture.samplingMode = samplingMode;
        texture.invertY = invertY;
        texture.baseWidth = this._options.textureSize;
        texture.baseHeight = this._options.textureSize;
        texture.width = this._options.textureSize;
        texture.height = this._options.textureSize;
        if (format) {
            texture.format = format;
        }
        texture.isReady = true;
        if (onLoad) {
            onLoad();
        }
        this._internalTexturesCache.push(texture);
        return texture;
    };
    NullEngine.prototype.createRenderTargetTexture = function (size, options) {
        var fullOptions = new RenderTargetCreationOptions();
        if (options !== undefined && typeof options === "object") {
            fullOptions.generateMipMaps = options.generateMipMaps;
            fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;
            fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;
            fullOptions.type = options.type === undefined ? Constants.TEXTURETYPE_UNSIGNED_INT : options.type;
            fullOptions.samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;
        }
        else {
            fullOptions.generateMipMaps = options;
            fullOptions.generateDepthBuffer = true;
            fullOptions.generateStencilBuffer = false;
            fullOptions.type = Constants.TEXTURETYPE_UNSIGNED_INT;
            fullOptions.samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;
        }
        var texture = new InternalTexture(this, InternalTexture.DATASOURCE_RENDERTARGET);
        var width = size.width || size;
        var height = size.height || size;
        texture._depthStencilBuffer = {};
        texture._framebuffer = {};
        texture.baseWidth = width;
        texture.baseHeight = height;
        texture.width = width;
        texture.height = height;
        texture.isReady = true;
        texture.samples = 1;
        texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
        texture.samplingMode = fullOptions.samplingMode;
        texture.type = fullOptions.type;
        texture._generateDepthBuffer = fullOptions.generateDepthBuffer;
        texture._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
        this._internalTexturesCache.push(texture);
        return texture;
    };
    NullEngine.prototype.updateTextureSamplingMode = function (samplingMode, texture) {
        texture.samplingMode = samplingMode;
    };
    NullEngine.prototype.bindFramebuffer = function (texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {
        if (this._currentRenderTarget) {
            this.unBindFramebuffer(this._currentRenderTarget);
        }
        this._currentRenderTarget = texture;
        this._currentFramebuffer = texture._MSAAFramebuffer ? texture._MSAAFramebuffer : texture._framebuffer;
        if (this._cachedViewport && !forceFullscreenViewport) {
            this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
        }
    };
    NullEngine.prototype.unBindFramebuffer = function (texture, disableGenerateMipMaps, onBeforeUnbind) {
        if (disableGenerateMipMaps === void 0) { disableGenerateMipMaps = false; }
        this._currentRenderTarget = null;
        if (onBeforeUnbind) {
            if (texture._MSAAFramebuffer) {
                this._currentFramebuffer = texture._framebuffer;
            }
            onBeforeUnbind();
        }
        this._currentFramebuffer = null;
    };
    NullEngine.prototype.createDynamicVertexBuffer = function (vertices) {
        var buffer = new DataBuffer();
        buffer.references = 1;
        buffer.capacity = 1;
        return buffer;
    };
    NullEngine.prototype.updateDynamicTexture = function (texture, canvas, invertY, premulAlpha, format) {
        if (premulAlpha === void 0) { premulAlpha = false; }
    };
    NullEngine.prototype.areAllEffectsReady = function () {
        return true;
    };
    /**
     * @hidden
     * Get the current error code of the webGL context
     * @returns the error code
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError
     */
    NullEngine.prototype.getError = function () {
        return 0;
    };
    /** @hidden */
    NullEngine.prototype._getUnpackAlignement = function () {
        return 1;
    };
    /** @hidden */
    NullEngine.prototype._unpackFlipY = function (value) {
    };
    NullEngine.prototype.updateDynamicIndexBuffer = function (indexBuffer, indices, offset) {
        if (offset === void 0) { offset = 0; }
    };
    /**
     * Updates a dynamic vertex buffer.
     * @param vertexBuffer the vertex buffer to update
     * @param data the data used to update the vertex buffer
     * @param byteOffset the byte offset of the data (optional)
     * @param byteLength the byte length of the data (optional)
     */
    NullEngine.prototype.updateDynamicVertexBuffer = function (vertexBuffer, vertices, byteOffset, byteLength) {
    };
    NullEngine.prototype._bindTextureDirectly = function (target, texture) {
        if (this._boundTexturesCache[this._activeChannel] !== texture) {
            this._boundTexturesCache[this._activeChannel] = texture;
            return true;
        }
        return false;
    };
    /** @hidden */
    NullEngine.prototype._bindTexture = function (channel, texture) {
        if (channel < 0) {
            return;
        }
        this._bindTextureDirectly(0, texture);
    };
    /** @hidden */
    NullEngine.prototype._releaseBuffer = function (buffer) {
        buffer.references--;
        if (buffer.references === 0) {
            return true;
        }
        return false;
    };
    NullEngine.prototype.releaseEffects = function () {
    };
    NullEngine.prototype.displayLoadingUI = function () {
    };
    NullEngine.prototype.hideLoadingUI = function () {
    };
    /** @hidden */
    NullEngine.prototype._uploadCompressedDataToTextureDirectly = function (texture, internalFormat, width, height, data, faceIndex, lod) {
        if (faceIndex === void 0) { faceIndex = 0; }
        if (lod === void 0) { lod = 0; }
    };
    /** @hidden */
    NullEngine.prototype._uploadDataToTextureDirectly = function (texture, imageData, faceIndex, lod) {
        if (faceIndex === void 0) { faceIndex = 0; }
        if (lod === void 0) { lod = 0; }
    };
    /** @hidden */
    NullEngine.prototype._uploadArrayBufferViewToTexture = function (texture, imageData, faceIndex, lod) {
        if (faceIndex === void 0) { faceIndex = 0; }
        if (lod === void 0) { lod = 0; }
    };
    /** @hidden */
    NullEngine.prototype._uploadImageToTexture = function (texture, image, faceIndex, lod) {
        if (faceIndex === void 0) { faceIndex = 0; }
        if (lod === void 0) { lod = 0; }
    };
    return NullEngine;
}(Engine));
export { NullEngine };
//# sourceMappingURL=nullEngine.js.map