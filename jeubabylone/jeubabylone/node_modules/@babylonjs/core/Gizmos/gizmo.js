import { Quaternion, Vector3 } from "../Maths/math";
import { Mesh } from "../Meshes/mesh";
import { UtilityLayerRenderer } from "../Rendering/utilityLayerRenderer";
/**
 * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.
 */
var Gizmo = /** @class */ (function () {
    /**
     * Creates a gizmo
     * @param gizmoLayer The utility layer the gizmo will be added to
     */
    function Gizmo(
    /** The utility layer the gizmo will be added to */
    gizmoLayer) {
        var _this = this;
        if (gizmoLayer === void 0) { gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer; }
        this.gizmoLayer = gizmoLayer;
        this._attachedMesh = null;
        /**
         * Ratio for the scale of the gizmo (Default: 1)
         */
        this.scaleRatio = 1;
        /**
         * If a custom mesh has been set (Default: false)
         */
        this._customMeshSet = false;
        /**
         * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)
         */
        this.updateGizmoRotationToMatchAttachedMesh = true;
        /**
         * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)
         */
        this.updateGizmoPositionToMatchAttachedMesh = true;
        /**
         * When set, the gizmo will always appear the same size no matter where the camera is (default: false)
         */
        this._updateScale = true;
        this._interactionsEnabled = true;
        this._tempVector = new Vector3();
        this._rootMesh = new Mesh("gizmoRootNode", gizmoLayer.utilityLayerScene);
        this._rootMesh.rotationQuaternion = Quaternion.Identity();
        this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(function () {
            _this._update();
        });
    }
    Object.defineProperty(Gizmo.prototype, "attachedMesh", {
        /**
         * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)
         * * When set, interactions will be enabled
         */
        get: function () {
            return this._attachedMesh;
        },
        set: function (value) {
            this._attachedMesh = value;
            this._rootMesh.setEnabled(value ? true : false);
            this._attachedMeshChanged(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes and replaces the current meshes in the gizmo with the specified mesh
     * @param mesh The mesh to replace the default mesh of the gizmo
     */
    Gizmo.prototype.setCustomMesh = function (mesh) {
        if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {
            throw "When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)";
        }
        this._rootMesh.getChildMeshes().forEach(function (c) {
            c.dispose();
        });
        mesh.parent = this._rootMesh;
        this._customMeshSet = true;
    };
    Gizmo.prototype._attachedMeshChanged = function (value) {
    };
    /**
     * Updates the gizmo to match the attached mesh's position/rotation
     */
    Gizmo.prototype._update = function () {
        if (this.attachedMesh) {
            var effectiveMesh = this.attachedMesh._effectiveMesh || this.attachedMesh;
            // Position
            if (this.updateGizmoPositionToMatchAttachedMesh) {
                this._rootMesh.position.copyFrom(effectiveMesh.absolutePosition);
            }
            // Rotation
            if (this.updateGizmoRotationToMatchAttachedMesh) {
                effectiveMesh.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion);
            }
            else {
                this._rootMesh.rotationQuaternion.set(0, 0, 0, 1);
            }
            // Scale
            if (this._updateScale) {
                var activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera;
                var cameraPosition = activeCamera.globalPosition;
                if (activeCamera.devicePosition) {
                    cameraPosition = activeCamera.devicePosition;
                }
                this._rootMesh.position.subtractToRef(cameraPosition, this._tempVector);
                var dist = this._tempVector.length() * this.scaleRatio;
                this._rootMesh.scaling.set(dist, dist, dist);
                // Account for handedness, similar to Matrix.decompose
                if (effectiveMesh._getWorldMatrixDeterminant() < 0) {
                    this._rootMesh.scaling.y *= -1;
                }
            }
        }
    };
    /**
     * Disposes of the gizmo
     */
    Gizmo.prototype.dispose = function () {
        this._rootMesh.dispose();
        if (this._beforeRenderObserver) {
            this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);
        }
    };
    return Gizmo;
}());
export { Gizmo };
//# sourceMappingURL=gizmo.js.map