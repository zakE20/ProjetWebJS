{"version":3,"file":"planeRotationGizmo.js","sourceRoot":"","sources":["../../../sourceES6/core/Gizmos/planeRotationGizmo.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observer, Observable } from \"../Misc/observable\";\nimport { Nullable } from \"../types\";\nimport { PointerInfo } from \"../Events/pointerEvents\";\nimport { Quaternion, Matrix, Vector3, Color3 } from \"../Maths/math\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { LinesMesh } from \"../Meshes/linesMesh\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\nimport { _TimeToken } from \"../Instrumentation/timeToken\";\nimport { _DepthCullingState, _StencilState, _AlphaState } from \"../States/index\";\nimport { Gizmo } from \"./gizmo\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\n\nimport \"../Meshes/Builders/linesBuilder\";\n\n/**\n * Single plane rotation gizmo\n */\nexport class PlaneRotationGizmo extends Gizmo {\n    /**\n     * Drag behavior responsible for the gizmos dragging interactions\n     */\n    public dragBehavior: PointerDragBehavior;\n    private _pointerObserver: Nullable<Observer<PointerInfo>> = null;\n\n    /**\n     * Rotation distance in radians that the gizmo will snap to (Default: 0)\n     */\n    public snapDistance = 0;\n    /**\n     * Event that fires each time the gizmo snaps to a new location.\n     * * snapDistance is the the change in distance\n     */\n    public onSnapObservable = new Observable<{ snapDistance: number }>();\n\n    /**\n     * Creates a PlaneRotationGizmo\n     * @param gizmoLayer The utility layer the gizmo will be added to\n     * @param planeNormal The normal of the plane which the gizmo will be able to rotate on\n     * @param color The color of the gizmo\n     * @param tessellation Amount of tessellation to be used when creating rotation circles\n     */\n    constructor(planeNormal: Vector3, color: Color3 = Color3.Gray(), gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer, tessellation = 32) {\n        super(gizmoLayer);\n\n        // Create Material\n        var coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        coloredMaterial.diffuseColor = color;\n        coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n\n        var hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        hoverMaterial.diffuseColor = color.add(new Color3(0.3, 0.3, 0.3));\n\n        // Build mesh on root node\n        var parentMesh = new AbstractMesh(\"\", gizmoLayer.utilityLayerScene);\n\n        let drag = Mesh.CreateTorus(\"\", 0.6, 0.03, tessellation, gizmoLayer.utilityLayerScene);\n        drag.visibility = 0;\n        let rotationMesh = Mesh.CreateTorus(\"\", 0.6, 0.005, tessellation, gizmoLayer.utilityLayerScene);\n        rotationMesh.material = coloredMaterial;\n\n        // Position arrow pointing in its drag axis\n        rotationMesh.rotation.x = Math.PI / 2;\n        drag.rotation.x = Math.PI / 2;\n        parentMesh.addChild(rotationMesh);\n        parentMesh.addChild(drag);\n        parentMesh.lookAt(this._rootMesh.position.add(planeNormal));\n\n        this._rootMesh.addChild(parentMesh);\n        parentMesh.scaling.scaleInPlace(1 / 3);\n        // Add drag behavior to handle events when the gizmo is dragged\n        this.dragBehavior = new PointerDragBehavior({ dragPlaneNormal: planeNormal });\n        this.dragBehavior.moveAttached = false;\n        this.dragBehavior.maxDragAngle = Math.PI * 9 / 20;\n        this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle = true;\n        this._rootMesh.addBehavior(this.dragBehavior);\n\n        var lastDragPosition = new Vector3();\n\n        this.dragBehavior.onDragStartObservable.add((e) => {\n            if (this.attachedMesh) {\n                lastDragPosition.copyFrom(e.dragPlanePoint);\n            }\n        });\n\n        var rotationMatrix = new Matrix();\n        var planeNormalTowardsCamera = new Vector3();\n        var localPlaneNormalTowardsCamera = new Vector3();\n\n        var tmpSnapEvent = { snapDistance: 0 };\n        var currentSnapDragDistance = 0;\n        var tmpMatrix = new Matrix();\n        var tmpVector = new Vector3();\n        var amountToRotate = new Quaternion();\n        this.dragBehavior.onDragObservable.add((event) => {\n            if (this.attachedMesh) {\n                if (!this.attachedMesh.rotationQuaternion) {\n                    this.attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.attachedMesh.rotation.y, this.attachedMesh.rotation.x, this.attachedMesh.rotation.z);\n                }\n\n                // Remove parent priort to rotating\n                var attachedMeshParent = this.attachedMesh.parent;\n                if (attachedMeshParent) {\n                    this.attachedMesh.setParent(null);\n                }\n\n                // Calc angle over full 360 degree (https://stackoverflow.com/questions/43493711/the-angle-between-two-3d-vectors-with-a-result-range-0-360)\n                var newVector = event.dragPlanePoint.subtract(this.attachedMesh.absolutePosition).normalize();\n                var originalVector = lastDragPosition.subtract(this.attachedMesh.absolutePosition).normalize();\n                var cross = Vector3.Cross(newVector, originalVector);\n                var dot = Vector3.Dot(newVector, originalVector);\n                var angle = Math.atan2(cross.length(), dot);\n                planeNormalTowardsCamera.copyFrom(planeNormal);\n                localPlaneNormalTowardsCamera.copyFrom(planeNormal);\n                if (this.updateGizmoRotationToMatchAttachedMesh) {\n                    this.attachedMesh.rotationQuaternion.toRotationMatrix(rotationMatrix);\n                    localPlaneNormalTowardsCamera = Vector3.TransformCoordinates(planeNormalTowardsCamera, rotationMatrix);\n                }\n                // Flip up vector depending on which side the camera is on\n                if (gizmoLayer.utilityLayerScene.activeCamera) {\n                    var camVec = gizmoLayer.utilityLayerScene.activeCamera.position.subtract(this.attachedMesh.position);\n                    if (Vector3.Dot(camVec, localPlaneNormalTowardsCamera) > 0) {\n                        planeNormalTowardsCamera.scaleInPlace(-1);\n                        localPlaneNormalTowardsCamera.scaleInPlace(-1);\n                    }\n                }\n                var halfCircleSide = Vector3.Dot(localPlaneNormalTowardsCamera, cross) > 0.0;\n                if (halfCircleSide) { angle = -angle; }\n\n                // Snapping logic\n                var snapped = false;\n                if (this.snapDistance != 0) {\n                    currentSnapDragDistance += angle;\n                    if (Math.abs(currentSnapDragDistance) > this.snapDistance) {\n                        var dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);\n                        if (currentSnapDragDistance < 0) {\n                            dragSteps *= -1;\n                        }\n                        currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;\n                        angle = this.snapDistance * dragSteps;\n                        snapped = true;\n                    } else {\n                        angle = 0;\n                    }\n                }\n\n                // If the mesh has a parent, convert needed world rotation to local rotation\n                tmpMatrix.reset();\n                if (this.attachedMesh.parent) {\n                    this.attachedMesh.parent.computeWorldMatrix().invertToRef(tmpMatrix);\n                    tmpMatrix.getRotationMatrixToRef(tmpMatrix);\n                    Vector3.TransformCoordinatesToRef(planeNormalTowardsCamera, tmpMatrix, planeNormalTowardsCamera);\n                }\n\n                // Convert angle and axis to quaternion (http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm)\n                var quaternionCoefficient = Math.sin(angle / 2);\n                amountToRotate.set(planeNormalTowardsCamera.x * quaternionCoefficient, planeNormalTowardsCamera.y * quaternionCoefficient, planeNormalTowardsCamera.z * quaternionCoefficient, Math.cos(angle / 2));\n\n                // If the meshes local scale is inverted (eg. loaded gltf file parent with z scale of -1) the rotation needs to be inverted on the y axis\n                if (tmpMatrix.determinant() > 0) {\n                    amountToRotate.toEulerAnglesToRef(tmpVector);\n                    Quaternion.RotationYawPitchRollToRef(tmpVector.y, -tmpVector.x, -tmpVector.z, amountToRotate);\n                }\n\n                if (this.updateGizmoRotationToMatchAttachedMesh) {\n                    // Rotate selected mesh quaternion over fixed axis\n                    this.attachedMesh.rotationQuaternion.multiplyToRef(amountToRotate, this.attachedMesh.rotationQuaternion);\n                } else {\n                    // Rotate selected mesh quaternion over rotated axis\n                    amountToRotate.multiplyToRef(this.attachedMesh.rotationQuaternion, this.attachedMesh.rotationQuaternion);\n                }\n\n                lastDragPosition.copyFrom(event.dragPlanePoint);\n                if (snapped) {\n                    tmpSnapEvent.snapDistance = angle;\n                    this.onSnapObservable.notifyObservers(tmpSnapEvent);\n                }\n\n                // Restore parent\n                if (attachedMeshParent) {\n                    this.attachedMesh.setParent(attachedMeshParent);\n                }\n            }\n        });\n\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\n            if (this._customMeshSet) {\n                return;\n            }\n            var isHovered = pointerInfo.pickInfo && (this._rootMesh.getChildMeshes().indexOf(<Mesh>pointerInfo.pickInfo.pickedMesh) != -1);\n            var material = isHovered ? hoverMaterial : coloredMaterial;\n            this._rootMesh.getChildMeshes().forEach((m) => {\n                m.material = material;\n                if ((<LinesMesh>m).color) {\n                    (<LinesMesh>m).color = material.diffuseColor;\n                }\n            });\n        });\n\n        var light = gizmoLayer._getSharedGizmoLight();\n        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));\n    }\n\n    protected _attachedMeshChanged(value: Nullable<AbstractMesh>) {\n        if (this.dragBehavior) {\n            this.dragBehavior.enabled = value ? true : false;\n        }\n    }\n\n    /**\n     * Disposes of the gizmo\n     */\n    public dispose() {\n        this.onSnapObservable.clear();\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n        this.dragBehavior.detach();\n        super.dispose();\n    }\n}"]}