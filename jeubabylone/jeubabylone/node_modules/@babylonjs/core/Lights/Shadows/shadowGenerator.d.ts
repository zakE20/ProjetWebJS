import { Nullable } from "../../types";
import { Scene } from "../../scene";
import { Matrix } from "../../Maths/math";
import { SubMesh } from "../../Meshes/subMesh";
import { AbstractMesh } from "../../Meshes/abstractMesh";
import { Mesh } from "../../Meshes/mesh";
import { IShadowLight } from "../../Lights/shadowLight";
import { MaterialDefines } from "../../Materials/materialDefines";
import { Effect } from "../../Materials/effect";
import { RenderTargetTexture } from "../../Materials/Textures/renderTargetTexture";
import "../../Shaders/shadowMap.fragment";
import "../../Shaders/shadowMap.vertex";
import "../../Shaders/depthBoxBlur.fragment";
import { Observable } from '../../Misc/observable';
/**
 * Defines the options associated with the creation of a custom shader for a shadow generator.
 */
export interface ICustomShaderOptions {
    /**
     * Gets or sets the custom shader name to use
     */
    shaderName: string;
    /**
     * The list of attribute names used in the shader
     */
    attributes?: string[];
    /**
     * The list of unifrom names used in the shader
     */
    uniforms?: string[];
    /**
     * The list of sampler names used in the shader
     */
    samplers?: string[];
    /**
     * The list of defines used in the shader
     */
    defines?: string[];
}
/**
 * Interface to implement to create a shadow generator compatible with BJS.
 */
export interface IShadowGenerator {
    /**
     * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
     * @returns The render target texture if present otherwise, null
     */
    getShadowMap(): Nullable<RenderTargetTexture>;
    /**
     * Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
     * @returns The render target texture if the shadow map is present otherwise, null
     */
    getShadowMapForRendering(): Nullable<RenderTargetTexture>;
    /**
     * Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
     * @param subMesh The submesh we want to render in the shadow map
     * @param useInstances Defines wether will draw in the map using instances
     * @returns true if ready otherwise, false
     */
    isReady(subMesh: SubMesh, useInstances: boolean): boolean;
    /**
     * Prepare all the defines in a material relying on a shadow map at the specified light index.
     * @param defines Defines of the material we want to update
     * @param lightIndex Index of the light in the enabled light list of the material
     */
    prepareDefines(defines: MaterialDefines, lightIndex: number): void;
    /**
     * Binds the shadow related information inside of an effect (information like near, far, darkness...
     * defined in the generator but impacting the effect).
     * It implies the unifroms available on the materials are the standard BJS ones.
     * @param lightIndex Index of the light in the enabled light list of the material owning the effect
     * @param effect The effect we are binfing the information for
     */
    bindShadowLight(lightIndex: string, effect: Effect): void;
    /**
     * Gets the transformation matrix used to project the meshes into the map from the light point of view.
     * (eq to shadow prjection matrix * light transform matrix)
     * @returns The transform matrix used to create the shadow map
     */
    getTransformMatrix(): Matrix;
    /**
     * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
     * Cube and 2D textures for instance.
     */
    recreateShadowMap(): void;
    /**
     * Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
     * @param onCompiled Callback triggered at the and of the effects compilation
     * @param options Sets of optional options forcing the compilation with different modes
     */
    forceCompilation(onCompiled?: (generator: ShadowGenerator) => void, options?: Partial<{
        useInstances: boolean;
    }>): void;
    /**
     * Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
     * @param options Sets of optional options forcing the compilation with different modes
     * @returns A promise that resolves when the compilation completes
     */
    forceCompilationAsync(options?: Partial<{
        useInstances: boolean;
    }>): Promise<void>;
    /**
     * Serializes the shadow generator setup to a json object.
     * @returns The serialized JSON object
     */
    serialize(): any;
    /**
     * Disposes the Shadow map and related Textures and effects.
     */
    dispose(): void;
}
/**
 * Default implementation IShadowGenerator.
 * This is the main object responsible of generating shadows in the framework.
 * Documentation: https://doc.babylonjs.com/babylon101/shadows
 */
export declare class ShadowGenerator implements IShadowGenerator {
    /**
     * Shadow generator mode None: no filtering applied.
     */
    static readonly FILTER_NONE = 0;
    /**
     * Shadow generator mode ESM: Exponential Shadow Mapping.
     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
     */
    static readonly FILTER_EXPONENTIALSHADOWMAP = 1;
    /**
     * Shadow generator mode Poisson Sampling: Percentage Closer Filtering.
     * (Multiple Tap around evenly distributed around the pixel are used to evaluate the shadow strength)
     */
    static readonly FILTER_POISSONSAMPLING = 2;
    /**
     * Shadow generator mode ESM: Blurred Exponential Shadow Mapping.
     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
     */
    static readonly FILTER_BLUREXPONENTIALSHADOWMAP = 3;
    /**
     * Shadow generator mode ESM: Exponential Shadow Mapping using the inverse of the exponential preventing
     * edge artifacts on steep falloff.
     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
     */
    static readonly FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;
    /**
     * Shadow generator mode ESM: Blurred Exponential Shadow Mapping using the inverse of the exponential preventing
     * edge artifacts on steep falloff.
     * (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
     */
    static readonly FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;
    /**
     * Shadow generator mode PCF: Percentage Closer Filtering
     * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
     * (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html)
     */
    static readonly FILTER_PCF = 6;
    /**
     * Shadow generator mode PCSS: Percentage Closering Soft Shadow.
     * benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
     * Contact Hardening
     */
    static readonly FILTER_PCSS = 7;
    /**
     * Reserved for PCF and PCSS
     * Highest Quality.
     *
     * Execute PCF on a 5*5 kernel improving a lot the shadow aliasing artifacts.
     *
     * Execute PCSS with 32 taps blocker search and 64 taps PCF.
     */
    static readonly QUALITY_HIGH = 0;
    /**
     * Reserved for PCF and PCSS
     * Good tradeoff for quality/perf cross devices
     *
     * Execute PCF on a 3*3 kernel.
     *
     * Execute PCSS with 16 taps blocker search and 32 taps PCF.
     */
    static readonly QUALITY_MEDIUM = 1;
    /**
     * Reserved for PCF and PCSS
     * The lowest quality but the fastest.
     *
     * Execute PCF on a 1*1 kernel.
     *
     * Execute PCSS with 16 taps blocker search and 16 taps PCF.
     */
    static readonly QUALITY_LOW = 2;
    /** Gets or sets the custom shader name to use */
    customShaderOptions: ICustomShaderOptions;
    /**
     * Observable triggered before the shadow is rendered. Can be used to update internal effect state
     */
    onBeforeShadowMapRenderObservable: Observable<Effect>;
    /**
     * Observable triggered before a mesh is rendered in the shadow map.
     * Can be used to update internal effect state (that you can get from the onBeforeShadowMapRenderObservable)
     */
    onBeforeShadowMapRenderMeshObservable: Observable<Mesh>;
    private _bias;
    /**
     * Gets the bias: offset applied on the depth preventing acnea (in light direction).
     */
    /**
    * Sets the bias: offset applied on the depth preventing acnea (in light direction).
    */
    bias: number;
    private _normalBias;
    /**
     * Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
     */
    /**
    * Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
    */
    normalBias: number;
    private _blurBoxOffset;
    /**
     * Gets the blur box offset: offset applied during the blur pass.
     * Only useful if useKernelBlur = false
     */
    /**
    * Sets the blur box offset: offset applied during the blur pass.
    * Only useful if useKernelBlur = false
    */
    blurBoxOffset: number;
    private _blurScale;
    /**
     * Gets the blur scale: scale of the blurred texture compared to the main shadow map.
     * 2 means half of the size.
     */
    /**
    * Sets the blur scale: scale of the blurred texture compared to the main shadow map.
    * 2 means half of the size.
    */
    blurScale: number;
    private _blurKernel;
    /**
     * Gets the blur kernel: kernel size of the blur pass.
     * Only useful if useKernelBlur = true
     */
    /**
    * Sets the blur kernel: kernel size of the blur pass.
    * Only useful if useKernelBlur = true
    */
    blurKernel: number;
    private _useKernelBlur;
    /**
     * Gets whether the blur pass is a kernel blur (if true) or box blur.
     * Only useful in filtered mode (useBlurExponentialShadowMap...)
     */
    /**
    * Sets whether the blur pass is a kernel blur (if true) or box blur.
    * Only useful in filtered mode (useBlurExponentialShadowMap...)
    */
    useKernelBlur: boolean;
    private _depthScale;
    /**
     * Gets the depth scale used in ESM mode.
     */
    /**
    * Sets the depth scale used in ESM mode.
    * This can override the scale stored on the light.
    */
    depthScale: number;
    private _filter;
    /**
     * Gets the current mode of the shadow generator (normal, PCF, ESM...).
     * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
     */
    /**
    * Sets the current mode of the shadow generator (normal, PCF, ESM...).
    * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
    */
    filter: number;
    /**
     * Gets if the current filter is set to Poisson Sampling.
     */
    /**
    * Sets the current filter to Poisson Sampling.
    */
    usePoissonSampling: boolean;
    /**
     * Gets if the current filter is set to ESM.
     */
    /**
    * Sets the current filter is to ESM.
    */
    useExponentialShadowMap: boolean;
    /**
     * Gets if the current filter is set to filtered ESM.
     */
    /**
    * Gets if the current filter is set to filtered  ESM.
    */
    useBlurExponentialShadowMap: boolean;
    /**
     * Gets if the current filter is set to "close ESM" (using the inverse of the
     * exponential to prevent steep falloff artifacts).
     */
    /**
    * Sets the current filter to "close ESM" (using the inverse of the
    * exponential to prevent steep falloff artifacts).
    */
    useCloseExponentialShadowMap: boolean;
    /**
     * Gets if the current filter is set to filtered "close ESM" (using the inverse of the
     * exponential to prevent steep falloff artifacts).
     */
    /**
    * Sets the current filter to filtered "close ESM" (using the inverse of the
    * exponential to prevent steep falloff artifacts).
    */
    useBlurCloseExponentialShadowMap: boolean;
    /**
     * Gets if the current filter is set to "PCF" (percentage closer filtering).
     */
    /**
    * Sets the current filter to "PCF" (percentage closer filtering).
    */
    usePercentageCloserFiltering: boolean;
    private _filteringQuality;
    /**
     * Gets the PCF or PCSS Quality.
     * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
     */
    /**
    * Sets the PCF or PCSS Quality.
    * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
    */
    filteringQuality: number;
    /**
     * Gets if the current filter is set to "PCSS" (contact hardening).
     */
    /**
    * Sets the current filter to "PCSS" (contact hardening).
    */
    useContactHardeningShadow: boolean;
    private _contactHardeningLightSizeUVRatio;
    /**
     * Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
     * Using a ratio helps keeping shape stability independently of the map size.
     *
     * It does not account for the light projection as it was having too much
     * instability during the light setup or during light position changes.
     *
     * Only valid if useContactHardeningShadow is true.
     */
    /**
    * Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
    * Using a ratio helps keeping shape stability independently of the map size.
    *
    * It does not account for the light projection as it was having too much
    * instability during the light setup or during light position changes.
    *
    * Only valid if useContactHardeningShadow is true.
    */
    contactHardeningLightSizeUVRatio: number;
    private _darkness;
    /**
     * Returns the darkness value (float). This can only decrease the actual darkness of a shadow.
     * 0 means strongest and 1 would means no shadow.
     * @returns the darkness.
     */
    getDarkness(): number;
    /**
     * Sets the darkness value (float). This can only decrease the actual darkness of a shadow.
     * @param darkness The darkness value 0 means strongest and 1 would means no shadow.
     * @returns the shadow generator allowing fluent coding.
     */
    setDarkness(darkness: number): ShadowGenerator;
    private _transparencyShadow;
    /**
     * Sets the ability to have transparent shadow (boolean).
     * @param transparent True if transparent else False
     * @returns the shadow generator allowing fluent coding
     */
    setTransparencyShadow(transparent: boolean): ShadowGenerator;
    private _shadowMap;
    private _shadowMap2;
    /**
     * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
     * @returns The render target texture if present otherwise, null
     */
    getShadowMap(): Nullable<RenderTargetTexture>;
    /**
     * Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
     * @returns The render target texture if the shadow map is present otherwise, null
     */
    getShadowMapForRendering(): Nullable<RenderTargetTexture>;
    /**
     * Helper function to add a mesh and its descendants to the list of shadow casters.
     * @param mesh Mesh to add
     * @param includeDescendants boolean indicating if the descendants should be added. Default to true
     * @returns the Shadow Generator itself
     */
    addShadowCaster(mesh: AbstractMesh, includeDescendants?: boolean): ShadowGenerator;
    /**
     * Helper function to remove a mesh and its descendants from the list of shadow casters
     * @param mesh Mesh to remove
     * @param includeDescendants boolean indicating if the descendants should be removed. Default to true
     * @returns the Shadow Generator itself
     */
    removeShadowCaster(mesh: AbstractMesh, includeDescendants?: boolean): ShadowGenerator;
    /**
     * Controls the extent to which the shadows fade out at the edge of the frustum
     * Used only by directionals and spots
     */
    frustumEdgeFalloff: number;
    private _light;
    /**
     * Returns the associated light object.
     * @returns the light generating the shadow
     */
    getLight(): IShadowLight;
    /**
     * If true the shadow map is generated by rendering the back face of the mesh instead of the front face.
     * This can help with self-shadowing as the geometry making up the back of objects is slightly offset.
     * It might on the other hand introduce peter panning.
     */
    forceBackFacesOnly: boolean;
    private _scene;
    private _lightDirection;
    private _effect;
    private _viewMatrix;
    private _projectionMatrix;
    private _transformMatrix;
    private _cachedPosition;
    private _cachedDirection;
    private _cachedDefines;
    private _currentRenderID;
    private _boxBlurPostprocess;
    private _kernelBlurXPostprocess;
    private _kernelBlurYPostprocess;
    private _blurPostProcesses;
    private _mapSize;
    private _currentFaceIndex;
    private _currentFaceIndexCache;
    private _textureType;
    private _defaultTextureMatrix;
    /** @hidden */
    static _SceneComponentInitialization: (scene: Scene) => void;
    /**
     * Creates a ShadowGenerator object.
     * A ShadowGenerator is the required tool to use the shadows.
     * Each light casting shadows needs to use its own ShadowGenerator.
     * Documentation : https://doc.babylonjs.com/babylon101/shadows
     * @param mapSize The size of the texture what stores the shadows. Example : 1024.
     * @param light The light object generating the shadows.
     * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
     */
    constructor(mapSize: number, light: IShadowLight, usefulFloatFirst?: boolean);
    private _initializeGenerator;
    private _initializeShadowMap;
    private _initializeBlurRTTAndPostProcesses;
    private _renderForShadowMap;
    private _renderSubMeshForShadowMap;
    private _applyFilterValues;
    /**
     * Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
     * @param onCompiled Callback triggered at the and of the effects compilation
     * @param options Sets of optional options forcing the compilation with different modes
     */
    forceCompilation(onCompiled?: (generator: ShadowGenerator) => void, options?: Partial<{
        useInstances: boolean;
    }>): void;
    /**
     * Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
     * @param options Sets of optional options forcing the compilation with different modes
     * @returns A promise that resolves when the compilation completes
     */
    forceCompilationAsync(options?: Partial<{
        useInstances: boolean;
    }>): Promise<void>;
    /**
     * Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
     * @param subMesh The submesh we want to render in the shadow map
     * @param useInstances Defines wether will draw in the map using instances
     * @returns true if ready otherwise, false
     */
    isReady(subMesh: SubMesh, useInstances: boolean): boolean;
    /**
     * Prepare all the defines in a material relying on a shadow map at the specified light index.
     * @param defines Defines of the material we want to update
     * @param lightIndex Index of the light in the enabled light list of the material
     */
    prepareDefines(defines: any, lightIndex: number): void;
    /**
     * Binds the shadow related information inside of an effect (information like near, far, darkness...
     * defined in the generator but impacting the effect).
     * @param lightIndex Index of the light in the enabled light list of the material owning the effect
     * @param effect The effect we are binfing the information for
     */
    bindShadowLight(lightIndex: string, effect: Effect): void;
    /**
     * Gets the transformation matrix used to project the meshes into the map from the light point of view.
     * (eq to shadow prjection matrix * light transform matrix)
     * @returns The transform matrix used to create the shadow map
     */
    getTransformMatrix(): Matrix;
    /**
     * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
     * Cube and 2D textures for instance.
     */
    recreateShadowMap(): void;
    private _disposeBlurPostProcesses;
    private _disposeRTTandPostProcesses;
    /**
     * Disposes the ShadowGenerator.
     * Returns nothing.
     */
    dispose(): void;
    /**
     * Serializes the shadow generator setup to a json object.
     * @returns The serialized JSON object
     */
    serialize(): any;
    /**
     * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
     * @param parsedShadowGenerator The JSON object to parse
     * @param scene The scene to create the shadow map for
     * @returns The parsed shadow generator
     */
    static Parse(parsedShadowGenerator: any, scene: Scene): ShadowGenerator;
}
