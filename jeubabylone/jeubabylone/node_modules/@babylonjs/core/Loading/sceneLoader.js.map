{"version":3,"file":"sceneLoader.js","sourceRoot":"","sources":["../../../sourceES6/core/Loading/sceneLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import { IFileRequest, Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { FilesInputStore } from \"../Misc/filesInputStore\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { AnimationGroup } from \"../Animations/animationGroup\";\r\nimport { _TimeToken } from \"../Instrumentation/timeToken\";\r\nimport { IOfflineProvider } from \"../Offline/IOfflineProvider\";\r\nimport { _DepthCullingState, _StencilState, _AlphaState } from \"../States/index\";\r\nimport { AssetContainer } from \"../assetContainer\";\r\nimport { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport { Skeleton } from \"../Bones/skeleton\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags\";\r\n/**\r\n * Class used to represent data loading progression\r\n */\r\nexport class SceneLoaderProgressEvent {\r\n    /**\r\n     * Create a new progress event\r\n     * @param lengthComputable defines if data length to load can be evaluated\r\n     * @param loaded defines the loaded data length\r\n     * @param total defines the data length to load\r\n     */\r\n    constructor(\r\n        /** defines if data length to load can be evaluated */\r\n        public readonly lengthComputable: boolean,\r\n        /** defines the loaded data length */\r\n        public readonly loaded: number,\r\n        /** defines the data length to load */\r\n        public readonly total: number) {\r\n    }\r\n\r\n    /**\r\n     * Creates a new SceneLoaderProgressEvent from a ProgressEvent\r\n     * @param event defines the source event\r\n     * @returns a new SceneLoaderProgressEvent\r\n     */\r\n    public static FromProgressEvent(event: ProgressEvent): SceneLoaderProgressEvent {\r\n        return new SceneLoaderProgressEvent(event.lengthComputable, event.loaded, event.total);\r\n    }\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugins to define supported file extensions\r\n */\r\nexport interface ISceneLoaderPluginExtensions {\r\n    /**\r\n     * Defines the list of supported extensions\r\n     */\r\n    [extension: string]: {\r\n        isBinary: boolean;\r\n    };\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugin factory\r\n */\r\nexport interface ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines the name of the factory\r\n     */\r\n    name: string;\r\n    /**\r\n     * Function called to create a new plugin\r\n     * @return the new plugin\r\n     */\r\n    createPlugin(): ISceneLoaderPlugin | ISceneLoaderPluginAsync;\r\n    /**\r\n     * Boolean indicating if the plugin can direct load specific data\r\n     */\r\n    canDirectLoad?: (data: string) => boolean;\r\n}\r\n\r\n/**\r\n * Interface used to define a SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPlugin {\r\n    /**\r\n     * The friendly name of this plugin.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The file extensions supported by this plugin.\r\n     */\r\n    extensions: string | ISceneLoaderPluginExtensions;\r\n\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param meshes The meshes array to import into\r\n     * @param particleSystems The particle systems array to import into\r\n     * @param skeletons The skeletons array to import into\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    importMesh(meshesNames: any, scene: Scene, data: any, rootUrl: string, meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], onError?: (message: string, exception?: any) => void): boolean;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns true if successful or false otherwise\r\n     */\r\n    load(scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void): boolean;\r\n\r\n    /**\r\n     * The callback that returns true if the data can be directly loaded.\r\n     */\r\n    canDirectLoad?: (data: string) => boolean;\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     */\r\n    rewriteRootURL?: (rootUrl: string, responseURL?: string) => string;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainer(scene: Scene, data: string, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer;\r\n}\r\n\r\n/**\r\n * Interface used to define an async SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPluginAsync {\r\n    /**\r\n     * The friendly name of this plugin.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The file extensions supported by this plugin.\r\n     */\r\n    extensions: string | ISceneLoaderPluginExtensions;\r\n\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded meshes, particle systems, skeletons, and animation groups\r\n     */\r\n    importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<{ meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[] }>;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns Nothing\r\n     */\r\n    loadAsync(scene: Scene, data: string, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<void>;\r\n\r\n    /**\r\n     * The callback that returns true if the data can be directly loaded.\r\n     */\r\n    canDirectLoad?: (data: string) => boolean;\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     */\r\n    rewriteRootURL?: (rootUrl: string, responseURL?: string) => string;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer>;\r\n}\r\n\r\n/**\r\n * Defines a plugin registered by the SceneLoader\r\n */\r\ninterface IRegisteredPlugin {\r\n    /**\r\n     * Defines the plugin to use\r\n     */\r\n    plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory;\r\n    /**\r\n     * Defines if the plugin supports binary data\r\n     */\r\n    isBinary: boolean;\r\n}\r\n\r\n/**\r\n * Defines file information\r\n */\r\ninterface IFileInfo {\r\n    /**\r\n     * Gets the file url\r\n     */\r\n    url: string;\r\n    /**\r\n     * Gets the root url\r\n     */\r\n    rootUrl: string;\r\n    /**\r\n     * Gets filename\r\n     */\r\n    name: string;\r\n    /**\r\n     * Gets the file\r\n     */\r\n    file: Nullable<File>;\r\n}\r\n\r\n/**\r\n * Class used to load scene from various file formats using registered plugins\r\n * @see http://doc.babylonjs.com/how_to/load_from_any_file_type\r\n */\r\nexport class SceneLoader {\r\n    /**\r\n     * No logging while loading\r\n     */\r\n    public static readonly NO_LOGGING = Constants.SCENELOADER_NO_LOGGING;\r\n\r\n    /**\r\n     * Minimal logging while loading\r\n     */\r\n    public static readonly MINIMAL_LOGGING = Constants.SCENELOADER_MINIMAL_LOGGING;\r\n\r\n    /**\r\n     * Summary logging while loading\r\n     */\r\n    public static readonly SUMMARY_LOGGING = Constants.SCENELOADER_SUMMARY_LOGGING;\r\n\r\n    /**\r\n     * Detailled logging while loading\r\n     */\r\n    public static readonly DETAILED_LOGGING = Constants.SCENELOADER_DETAILED_LOGGING;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\r\n     */\r\n    public static get ForceFullSceneLoadingForIncremental() {\r\n        return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\r\n    }\r\n\r\n    public static set ForceFullSceneLoadingForIncremental(value: boolean) {\r\n        SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\r\n     */\r\n    public static get ShowLoadingScreen(): boolean {\r\n        return SceneLoaderFlags.ShowLoadingScreen;\r\n    }\r\n\r\n    public static set ShowLoadingScreen(value: boolean) {\r\n        SceneLoaderFlags.ShowLoadingScreen = value;\r\n    }\r\n\r\n    /**\r\n     * Defines the current logging level (while loading the scene)\r\n     * @ignorenaming\r\n     */\r\n    public static get loggingLevel(): number {\r\n        return SceneLoaderFlags.loggingLevel;\r\n    }\r\n\r\n    public static set loggingLevel(value: number) {\r\n        SceneLoaderFlags.loggingLevel = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\r\n     */\r\n    public static get CleanBoneMatrixWeights(): boolean {\r\n        return SceneLoaderFlags.CleanBoneMatrixWeights;\r\n    }\r\n\r\n    public static set CleanBoneMatrixWeights(value: boolean) {\r\n        SceneLoaderFlags.CleanBoneMatrixWeights = value;\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Event raised when a plugin is used to load a scene\r\n     */\r\n    public static OnPluginActivatedObservable = new Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>();\r\n\r\n    private static _registeredPlugins: { [extension: string]: IRegisteredPlugin } = {};\r\n\r\n    private static _getDefaultPlugin(): IRegisteredPlugin {\r\n        return SceneLoader._registeredPlugins[\".babylon\"];\r\n    }\r\n\r\n    private static _getPluginForExtension(extension: string): IRegisteredPlugin {\r\n        var registeredPlugin = SceneLoader._registeredPlugins[extension];\r\n        if (registeredPlugin) {\r\n            return registeredPlugin;\r\n        }\r\n        Logger.Warn(\"Unable to find a plugin to load \" + extension + \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: http://doc.babylonjs.com/how_to/load_from_any_file_type\");\r\n        return SceneLoader._getDefaultPlugin();\r\n    }\r\n\r\n    private static _getPluginForDirectLoad(data: string): IRegisteredPlugin {\r\n        for (var extension in SceneLoader._registeredPlugins) {\r\n            var plugin = SceneLoader._registeredPlugins[extension].plugin;\r\n\r\n            if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\r\n                return SceneLoader._registeredPlugins[extension];\r\n            }\r\n        }\r\n\r\n        return SceneLoader._getDefaultPlugin();\r\n    }\r\n\r\n    private static _getPluginForFilename(sceneFilename: string): IRegisteredPlugin {\r\n        var queryStringPosition = sceneFilename.indexOf(\"?\");\r\n\r\n        if (queryStringPosition !== -1) {\r\n            sceneFilename = sceneFilename.substring(0, queryStringPosition);\r\n        }\r\n\r\n        var dotPosition = sceneFilename.lastIndexOf(\".\");\r\n\r\n        var extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\r\n        return SceneLoader._getPluginForExtension(extension);\r\n    }\r\n\r\n    // use babylon file loader directly if sceneFilename is prefixed with \"data:\"\r\n    private static _getDirectLoad(sceneFilename: string): Nullable<string> {\r\n        if (sceneFilename.substr(0, 5) === \"data:\") {\r\n            return sceneFilename.substr(5);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _loadData(fileInfo: IFileInfo, scene: Scene, onSuccess: (plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync, data: any, responseURL?: string) => void, onProgress: ((event: SceneLoaderProgressEvent) => void) | undefined, onError: (message: string, exception?: any) => void, onDispose: () => void, pluginExtension: Nullable<string>): ISceneLoaderPlugin | ISceneLoaderPluginAsync {\r\n        let directLoad = SceneLoader._getDirectLoad(fileInfo.name);\r\n        let registeredPlugin = pluginExtension ? SceneLoader._getPluginForExtension(pluginExtension) : (directLoad ? SceneLoader._getPluginForDirectLoad(fileInfo.name) : SceneLoader._getPluginForFilename(fileInfo.name));\r\n\r\n        let plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync;\r\n        if ((registeredPlugin.plugin as ISceneLoaderPluginFactory).createPlugin) {\r\n            plugin = (registeredPlugin.plugin as ISceneLoaderPluginFactory).createPlugin();\r\n        }\r\n        else {\r\n            plugin = <any>registeredPlugin.plugin;\r\n        }\r\n\r\n        if (!plugin) {\r\n            throw \"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.\";\r\n        }\r\n\r\n        let useArrayBuffer = registeredPlugin.isBinary;\r\n        let offlineProvider: IOfflineProvider;\r\n\r\n        SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);\r\n\r\n        let dataCallback = (data: any, responseURL?: string) => {\r\n            if (scene.isDisposed) {\r\n                onError(\"Scene has been disposed\");\r\n                return;\r\n            }\r\n\r\n            scene.offlineProvider = offlineProvider;\r\n\r\n            onSuccess(plugin, data, responseURL);\r\n        };\r\n\r\n        let request: Nullable<IFileRequest> = null;\r\n        let pluginDisposed = false;\r\n        let onDisposeObservable = (plugin as any).onDisposeObservable as Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;\r\n        if (onDisposeObservable) {\r\n            onDisposeObservable.add(() => {\r\n                pluginDisposed = true;\r\n\r\n                if (request) {\r\n                    request.abort();\r\n                    request = null;\r\n                }\r\n\r\n                onDispose();\r\n            });\r\n        }\r\n\r\n        let manifestChecked = () => {\r\n            if (pluginDisposed) {\r\n                return;\r\n            }\r\n\r\n            request = Tools.LoadFile(fileInfo.url, dataCallback, onProgress ? (event) => {\r\n                onProgress(SceneLoaderProgressEvent.FromProgressEvent(event));\r\n            } : undefined, offlineProvider, useArrayBuffer, (request, exception) => {\r\n                onError(\"Failed to load scene.\" + (exception ? \" \" + exception.message : \"\"), exception);\r\n            });\r\n        };\r\n\r\n        if (directLoad) {\r\n            dataCallback(directLoad);\r\n            return plugin;\r\n        }\r\n\r\n        const file = fileInfo.file || FilesInputStore.FilesToLoad[fileInfo.name.toLowerCase()];\r\n\r\n        if (fileInfo.rootUrl.indexOf(\"file:\") === -1 || (fileInfo.rootUrl.indexOf(\"file:\") !== -1 && !file)) {\r\n            let engine = scene.getEngine();\r\n            let canUseOfflineSupport = engine.enableOfflineSupport;\r\n            if (canUseOfflineSupport) {\r\n                // Also check for exceptions\r\n                let exceptionFound = false;\r\n                for (var regex of scene.disableOfflineSupportExceptionRules) {\r\n                    if (regex.test(fileInfo.url)) {\r\n                        exceptionFound = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                canUseOfflineSupport = !exceptionFound;\r\n            }\r\n\r\n            if (canUseOfflineSupport && Engine.OfflineProviderFactory) {\r\n                // Checking if a manifest file has been set for this scene and if offline mode has been requested\r\n                offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\r\n            }\r\n            else {\r\n                manifestChecked();\r\n            }\r\n        }\r\n        // Loading file from disk via input file or drag'n'drop\r\n        else {\r\n            if (file) {\r\n                request = Tools.ReadFile(file, dataCallback, onProgress, useArrayBuffer);\r\n            } else {\r\n                onError(\"Unable to find file named \" + fileInfo.name);\r\n            }\r\n        }\r\n        return plugin;\r\n    }\r\n\r\n    private static _getFileInfo(rootUrl: string, sceneFilename: string | File): Nullable<IFileInfo> {\r\n        let url: string;\r\n        let name: string;\r\n        let file: Nullable<File> = null;\r\n\r\n        if (!sceneFilename) {\r\n            url = rootUrl;\r\n            name = Tools.GetFilename(rootUrl);\r\n            rootUrl = Tools.GetFolderPath(rootUrl);\r\n        }\r\n        else if ((sceneFilename as File).name) {\r\n            const sceneFile = sceneFilename as File;\r\n            url = rootUrl + sceneFile.name;\r\n            name = sceneFile.name;\r\n            file = sceneFile;\r\n        }\r\n        else {\r\n            const filename = sceneFilename as string;\r\n            if (filename.substr(0, 1) === \"/\") {\r\n                Tools.Error(\"Wrong sceneFilename parameter\");\r\n                return null;\r\n            }\r\n\r\n            url = rootUrl + filename;\r\n            name = filename;\r\n        }\r\n\r\n        return {\r\n            url: url,\r\n            rootUrl: rootUrl,\r\n            name: name,\r\n            file: file\r\n        };\r\n    }\r\n\r\n    // Public functions\r\n\r\n    /**\r\n     * Gets a plugin that can load the given extension\r\n     * @param extension defines the extension to load\r\n     * @returns a plugin or null if none works\r\n     */\r\n    public static GetPluginForExtension(extension: string): ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory {\r\n        return SceneLoader._getPluginForExtension(extension).plugin;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the given extension can be loaded\r\n     * @param extension defines the extension to load\r\n     * @returns true if the extension is supported\r\n     */\r\n    public static IsPluginForExtensionAvailable(extension: string): boolean {\r\n        return !!SceneLoader._registeredPlugins[extension];\r\n    }\r\n\r\n    /**\r\n     * Adds a new plugin to the list of registered plugins\r\n     * @param plugin defines the plugin to add\r\n     */\r\n    public static RegisterPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync): void {\r\n        if (typeof plugin.extensions === \"string\") {\r\n            var extension = <string>plugin.extensions;\r\n            SceneLoader._registeredPlugins[extension.toLowerCase()] = {\r\n                plugin: plugin,\r\n                isBinary: false\r\n            };\r\n        }\r\n        else {\r\n            var extensions = <ISceneLoaderPluginExtensions>plugin.extensions;\r\n            Object.keys(extensions).forEach((extension) => {\r\n                SceneLoader._registeredPlugins[extension.toLowerCase()] = {\r\n                    plugin: plugin,\r\n                    isBinary: extensions[extension].isBinary\r\n                };\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with a list of imported meshes, particleSystems, and skeletons when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static ImportMesh(meshNames: any, rootUrl: string, sceneFilename: string | File = \"\", scene: Nullable<Scene> = EngineStore.LastCreatedScene, onSuccess: Nullable<(meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[]) => void> = null, onProgress: Nullable<(event: SceneLoaderProgressEvent) => void> = null, onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null, pluginExtension: Nullable<string> = null): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to import mesh to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._getFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        var loadingToken = {};\r\n        scene._addPendingData(loadingToken);\r\n\r\n        var disposeHandler = () => {\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        var errorHandler = (message: string, exception?: any) => {\r\n            let errorMessage = \"Unable to import meshes from \" + fileInfo.url + \": \" + message;\r\n\r\n            if (onError) {\r\n                onError(scene, errorMessage, exception);\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        var progressHandler = onProgress ? (event: SceneLoaderProgressEvent) => {\r\n            try {\r\n                onProgress(event);\r\n            }\r\n            catch (e) {\r\n                errorHandler(\"Error in onProgress callback\", e);\r\n            }\r\n        } : undefined;\r\n\r\n        var successHandler = (meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[]) => {\r\n            scene.importedMeshesFiles.push(fileInfo.url);\r\n\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(meshes, particleSystems, skeletons, animationGroups);\r\n                }\r\n                catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback\", e);\r\n                }\r\n            }\r\n\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._loadData(fileInfo, scene, (plugin, data, responseURL) => {\r\n            if (plugin.rewriteRootURL) {\r\n                fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\r\n            }\r\n\r\n            if ((<any>plugin).importMesh) {\r\n                var syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                var meshes = new Array<AbstractMesh>();\r\n                var particleSystems = new Array<IParticleSystem>();\r\n                var skeletons = new Array<Skeleton>();\r\n\r\n                if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\r\n                    return;\r\n                }\r\n\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler(meshes, particleSystems, skeletons, []);\r\n            }\r\n            else {\r\n                var asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then((result) => {\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups);\r\n                }).catch((error) => {\r\n                    errorHandler(error.message, error);\r\n                });\r\n            }\r\n        }, progressHandler, errorHandler, disposeHandler, pluginExtension);\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\r\n     */\r\n    public static ImportMeshAsync(meshNames: any, rootUrl: string, sceneFilename: string | File = \"\", scene: Nullable<Scene> = EngineStore.LastCreatedScene, onProgress: Nullable<(event: SceneLoaderProgressEvent) => void> = null, pluginExtension: Nullable<string> = null): Promise<{ meshes: AbstractMesh[], particleSystems: IParticleSystem[], skeletons: Skeleton[], animationGroups: AnimationGroup[] }> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.ImportMesh(meshNames, rootUrl, sceneFilename, scene, (meshes, particleSystems, skeletons, animationGroups) => {\r\n                resolve({\r\n                    meshes: meshes,\r\n                    particleSystems: particleSystems,\r\n                    skeletons: skeletons,\r\n                    animationGroups: animationGroups\r\n                });\r\n            }, onProgress, (scene, message, exception) => {\r\n                reject(exception || new Error(message));\r\n            },\r\n                pluginExtension);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static Load(rootUrl: string, sceneFilename: string | File = \"\", engine: Nullable<Engine> = EngineStore.LastCreatedEngine, onSuccess: Nullable<(scene: Scene) => void> = null, onProgress: Nullable<(event: SceneLoaderProgressEvent) => void> = null, onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null, pluginExtension: Nullable<string> = null): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!engine) {\r\n            Tools.Error(\"No engine available\");\r\n            return null;\r\n        }\r\n\r\n        return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded scene\r\n     */\r\n    public static LoadAsync(rootUrl: string, sceneFilename: string | File = \"\", engine: Nullable<Engine> = EngineStore.LastCreatedEngine, onProgress: Nullable<(event: SceneLoaderProgressEvent) => void> = null, pluginExtension: Nullable<string> = null): Promise<Scene> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.Load(rootUrl, sceneFilename, engine, (scene) => {\r\n                resolve(scene);\r\n            }, onProgress, (scene, message, exception) => {\r\n                reject(exception || new Error(message));\r\n            }, pluginExtension);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static Append(rootUrl: string, sceneFilename: string | File = \"\", scene: Nullable<Scene> = EngineStore.LastCreatedScene, onSuccess: Nullable<(scene: Scene) => void> = null, onProgress: Nullable<(event: SceneLoaderProgressEvent) => void> = null, onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null, pluginExtension: Nullable<string> = null): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to append to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._getFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        if (SceneLoader.ShowLoadingScreen) {\r\n            scene.getEngine().displayLoadingUI();\r\n        }\r\n\r\n        var loadingToken = {};\r\n        scene._addPendingData(loadingToken);\r\n\r\n        var disposeHandler = () => {\r\n            scene._removePendingData(loadingToken);\r\n            scene.getEngine().hideLoadingUI();\r\n        };\r\n\r\n        var errorHandler = (message: Nullable<string>, exception?: any) => {\r\n            let errorMessage = \"Unable to load from \" + fileInfo.url + (message ? \": \" + message : \"\");\r\n            if (onError) {\r\n                onError(scene, errorMessage, exception);\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        var progressHandler = onProgress ? (event: SceneLoaderProgressEvent) => {\r\n            try {\r\n                onProgress(event);\r\n            }\r\n            catch (e) {\r\n                errorHandler(\"Error in onProgress callback\", e);\r\n            }\r\n        } : undefined;\r\n\r\n        var successHandler = () => {\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(scene);\r\n                }\r\n                catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback\", e);\r\n                }\r\n            }\r\n\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._loadData(fileInfo, scene, (plugin, data) => {\r\n            if ((<any>plugin).load) {\r\n                var syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\r\n                    return;\r\n                }\r\n\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler();\r\n            } else {\r\n                var asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(() => {\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler();\r\n                }).catch((error) => {\r\n                    errorHandler(error.message, error);\r\n                });\r\n            }\r\n\r\n            if (SceneLoader.ShowLoadingScreen) {\r\n                scene.executeWhenReady(() => {\r\n                    scene.getEngine().hideLoadingUI();\r\n                });\r\n            }\r\n        }, progressHandler, errorHandler, disposeHandler, pluginExtension);\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The given scene\r\n     */\r\n    public static AppendAsync(rootUrl: string, sceneFilename: string | File = \"\", scene: Nullable<Scene> = EngineStore.LastCreatedScene, onProgress: Nullable<(event: SceneLoaderProgressEvent) => void> = null, pluginExtension: Nullable<string> = null): Promise<Scene> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.Append(rootUrl, sceneFilename, scene, (scene) => {\r\n                resolve(scene);\r\n            }, onProgress, (scene, message, exception) => {\r\n                reject(exception || new Error(message));\r\n            }, pluginExtension);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static LoadAssetContainer(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onSuccess: Nullable<(assets: AssetContainer) => void> = null,\r\n        onProgress: Nullable<(event: SceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to load asset container to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._getFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        var loadingToken = {};\r\n        scene._addPendingData(loadingToken);\r\n\r\n        var disposeHandler = () => {\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        var errorHandler = (message: Nullable<string>, exception?: any) => {\r\n            let errorMessage = \"Unable to load assets from \" + fileInfo.url + (message ? \": \" + message : \"\");\r\n            if (onError) {\r\n                onError(scene, errorMessage, exception);\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        var progressHandler = onProgress ? (event: SceneLoaderProgressEvent) => {\r\n            try {\r\n                onProgress(event);\r\n            }\r\n            catch (e) {\r\n                errorHandler(\"Error in onProgress callback\", e);\r\n            }\r\n        } : undefined;\r\n\r\n        var successHandler = (assets: AssetContainer) => {\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(assets);\r\n                }\r\n                catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback\", e);\r\n                }\r\n            }\r\n\r\n            scene._removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._loadData(fileInfo, scene, (plugin, data) => {\r\n            if ((<any>plugin).loadAssetContainer) {\r\n                var syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                var assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\r\n                if (!assetContainer) {\r\n                    return;\r\n                }\r\n\r\n                scene.loadingPluginName = plugin.name;\r\n                successHandler(assetContainer);\r\n            } else if ((<any>plugin).loadAssetContainerAsync) {\r\n                var asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then((assetContainer) => {\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler(assetContainer);\r\n                }).catch((error) => {\r\n                    errorHandler(error.message, error);\r\n                });\r\n            } else {\r\n                errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\r\n            }\r\n\r\n            if (SceneLoader.ShowLoadingScreen) {\r\n                scene.executeWhenReady(() => {\r\n                    scene.getEngine().hideLoadingUI();\r\n                });\r\n            }\r\n        }, progressHandler, errorHandler, disposeHandler, pluginExtension);\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\r\n     * @param scene is the instance of Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded asset container\r\n     */\r\n    public static LoadAssetContainerAsync(rootUrl: string, sceneFilename: string = \"\", scene: Nullable<Scene> = EngineStore.LastCreatedScene, onProgress: Nullable<(event: SceneLoaderProgressEvent) => void> = null, pluginExtension: Nullable<string> = null): Promise<AssetContainer> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.LoadAssetContainer(rootUrl, sceneFilename, scene, (assetContainer) => {\r\n                resolve(assetContainer);\r\n            }, onProgress, (scene, message, exception) => {\r\n                reject(exception || new Error(message));\r\n            }, pluginExtension);\r\n        });\r\n    }\r\n}\r\n"]}