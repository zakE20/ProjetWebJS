{"version":3,"file":"baseTexture.js","sourceRoot":"","sources":["../../../../sourceES6/core/Materials/Textures/baseTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, SerializationHelper } from \"../../Misc/decorators\";\r\nimport { Observer, Observable } from \"../../Misc/observable\";\r\nimport { Tools, IAnimatable } from \"../../Misc/tools\";\r\nimport { CubeMapToSphericalPolynomialTools } from \"../../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Matrix, Size, ISize } from \"../../Maths/math\";\r\nimport { SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { _TimeToken } from \"../../Instrumentation/timeToken\";\r\nimport { _DepthCullingState, _StencilState, _AlphaState } from \"../../States/index\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\ndeclare type Animation = import(\"../../Animations/animation\").Animation;\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\r\nexport class BaseTexture implements IAnimatable {\r\n    /**\r\n     * Default anisotropic filtering level for the application.\r\n     * It is set to 4 as a good tradeoff between perf and quality.\r\n     */\r\n    public static DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the texture\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Define the name of the texture.\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information.\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    @serialize(\"hasAlpha\")\r\n    private _hasAlpha = false;\r\n    /**\r\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n     */\r\n    public set hasAlpha(value: boolean) {\r\n        if (this._hasAlpha === value) {\r\n            return;\r\n        }\r\n        this._hasAlpha = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag | Constants.MATERIAL_MiscDirtyFlag);\r\n        }\r\n    }\r\n    public get hasAlpha(): boolean {\r\n        return this._hasAlpha;\r\n    }\r\n\r\n    /**\r\n     * Defines if the alpha value should be determined via the rgb values.\r\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n     */\r\n    @serialize()\r\n    public getAlphaFromRGB = false;\r\n\r\n    /**\r\n     * Intensity or strength of the texture.\r\n     * It is commonly used by materials to fine tune the intensity of the texture\r\n     */\r\n    @serialize()\r\n    public level = 1;\r\n\r\n    /**\r\n     * Define the UV chanel to use starting from 0 and defaulting to 0.\r\n     * This is part of the texture as textures usually maps to one uv set.\r\n     */\r\n    @serialize()\r\n    public coordinatesIndex = 0;\r\n\r\n    @serialize(\"coordinatesMode\")\r\n    private _coordinatesMode = Constants.TEXTURE_EXPLICIT_MODE;\r\n\r\n    /**\r\n    * How a texture is mapped.\r\n    *\r\n    * | Value | Type                                | Description |\r\n    * | ----- | ----------------------------------- | ----------- |\r\n    * | 0     | EXPLICIT_MODE                       |             |\r\n    * | 1     | SPHERICAL_MODE                      |             |\r\n    * | 2     | PLANAR_MODE                         |             |\r\n    * | 3     | CUBIC_MODE                          |             |\r\n    * | 4     | PROJECTION_MODE                     |             |\r\n    * | 5     | SKYBOX_MODE                         |             |\r\n    * | 6     | INVCUBIC_MODE                       |             |\r\n    * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n    * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n    * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n    */\r\n    public set coordinatesMode(value: number) {\r\n        if (this._coordinatesMode === value) {\r\n            return;\r\n        }\r\n        this._coordinatesMode = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n        }\r\n    }\r\n    public get coordinatesMode(): number {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n    * | Value | Type               | Description |\r\n    * | ----- | ------------------ | ----------- |\r\n    * | 0     | CLAMP_ADDRESSMODE  |             |\r\n    * | 1     | WRAP_ADDRESSMODE   |             |\r\n    * | 2     | MIRROR_ADDRESSMODE |             |\r\n    */\r\n    @serialize()\r\n    public wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n    * | Value | Type               | Description |\r\n    * | ----- | ------------------ | ----------- |\r\n    * | 0     | CLAMP_ADDRESSMODE  |             |\r\n    * | 1     | WRAP_ADDRESSMODE   |             |\r\n    * | 2     | MIRROR_ADDRESSMODE |             |\r\n    */\r\n    @serialize()\r\n    public wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n    * | Value | Type               | Description |\r\n    * | ----- | ------------------ | ----------- |\r\n    * | 0     | CLAMP_ADDRESSMODE  |             |\r\n    * | 1     | WRAP_ADDRESSMODE   |             |\r\n    * | 2     | MIRROR_ADDRESSMODE |             |\r\n    */\r\n    @serialize()\r\n    public wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    @serialize()\r\n    public anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\r\n\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    public set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.isCube = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    public set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n     * HDR texture are usually stored in linear space.\r\n     * This only impacts the PBR and Background materials\r\n     */\r\n    @serialize()\r\n    public gammaSpace = true;\r\n\r\n    /**\r\n     * Gets whether or not the texture contains RGBD data.\r\n     */\r\n    public get isRGBD(): boolean {\r\n        return this._texture != null && this._texture._isRGBD;\r\n    }\r\n\r\n    /**\r\n     * Is Z inverted in the texture (useful in a cube texture).\r\n     */\r\n    @serialize()\r\n    public invertZ = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    @serialize()\r\n    public lodLevelInAlpha = false;\r\n\r\n    /**\r\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationOffset(): number {\r\n        if (this._texture) { return this._texture._lodGenerationOffset; }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationOffset(value: number) {\r\n        if (this._texture) { this._texture._lodGenerationOffset = value; }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationScale(): number {\r\n        if (this._texture) { return this._texture._lodGenerationScale; }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationScale(value: number) {\r\n        if (this._texture) { this._texture._lodGenerationScale = value; }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a render target.\r\n     */\r\n    @serialize()\r\n    public isRenderTarget = false;\r\n\r\n    /**\r\n     * Define the unique id of the texture in the scene.\r\n     */\r\n    public get uid(): string {\r\n        if (!this._uid) {\r\n            this._uid = Tools.RandomId();\r\n        }\r\n        return this._uid;\r\n    }\r\n\r\n    /**\r\n     * Return a string representation of the texture.\r\n     * @returns the texture as a string\r\n     */\r\n    public toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"BaseTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseTexture\";\r\n    }\r\n\r\n    /**\r\n     * Define the list of animation attached to the texture.\r\n     */\r\n    public animations = new Array<Animation>();\r\n\r\n    /**\r\n    * An event triggered when the texture is disposed.\r\n    */\r\n    public onDisposeObservable = new Observable<BaseTexture>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<BaseTexture>> = null;\r\n    /**\r\n     * Callback triggered when the texture has been disposed.\r\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Define the current state of the loading sequence when in delayed load mode.\r\n     */\r\n    public delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n\r\n    private _scene: Nullable<Scene> = null;\r\n\r\n    /** @hidden */\r\n    public _texture: Nullable<InternalTexture> = null;\r\n    private _uid: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define if the texture is preventinga material to render or not.\r\n     * If not and the texture is not ready, the engine will use a default black texture instead.\r\n     */\r\n    public get isBlocking(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new BaseTexture.\r\n     * Base class of all the textures in babylon.\r\n     * It groups all the common properties the materials, post process, lights... might need\r\n     * in order to make a correct use of the texture.\r\n     * @param scene Define the scene the texture blongs to\r\n     */\r\n    constructor(scene: Nullable<Scene>) {\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        if (this._scene) {\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.addTexture(this);\r\n        }\r\n        this._uid = null;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the texture belongs to.\r\n     * @returns the scene or null if undefined\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Get the texture transform matrix used to offset tile the texture for istance.\r\n     * @returns the transformation matrix\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get the underlying lower level texture from Babylon.\r\n     * @returns the insternal texture\r\n     */\r\n    public getInternalTexture(): Nullable<InternalTexture> {\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n     * @returns true if ready or not blocking\r\n     */\r\n    public isReadyOrNotBlocking(): boolean {\r\n        return !this.isBlocking || this.isReady();\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (this.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            this.delayLoad();\r\n            return false;\r\n        }\r\n\r\n        if (this._texture) {\r\n            return this._texture.isReady;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _cachedSize: ISize = Size.Zero();\r\n    /**\r\n     * Get the size of the texture.\r\n     * @returns the texture size.\r\n     */\r\n    public getSize(): ISize {\r\n        if (this._texture) {\r\n            if (this._texture.width) {\r\n                this._cachedSize.width = this._texture.width;\r\n                this._cachedSize.height = this._texture.height;\r\n                return this._cachedSize;\r\n            }\r\n\r\n            if (this._texture._size) {\r\n                this._cachedSize.width = this._texture._size;\r\n                this._cachedSize.height = this._texture._size;\r\n                return this._cachedSize;\r\n            }\r\n        }\r\n\r\n        return this._cachedSize;\r\n    }\r\n\r\n    /**\r\n     * Get the base size of the texture.\r\n     * It can be different from the size if the texture has been resized for POT for instance\r\n     * @returns the base size\r\n     */\r\n    public getBaseSize(): ISize {\r\n        if (!this.isReady() || !this._texture) {\r\n            return Size.Zero();\r\n        }\r\n\r\n        if (this._texture._size) {\r\n            return new Size(this._texture._size, this._texture._size);\r\n        }\r\n\r\n        return new Size(this._texture.baseWidth, this._texture.baseHeight);\r\n    }\r\n\r\n    /**\r\n           * Update the sampling mode of the texture.\r\n           * Default is Trilinear mode.\r\n           *\r\n           * | Value | Type               | Description |\r\n           * | ----- | ------------------ | ----------- |\r\n           * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\r\n           * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\r\n           * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\r\n           * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\r\n           * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\r\n           * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\r\n           * | 7    | NEAREST_LINEAR |             |\r\n           * | 8    | NEAREST_NEAREST |             |\r\n           * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\r\n           * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\r\n           * | 11   | LINEAR_LINEAR |             |\r\n           * | 12   | LINEAR_NEAREST |             |\r\n           *\r\n           *    > _mag_: magnification filter (close to the viewer)\r\n           *    > _min_: minification filter (far from the viewer)\r\n           *    > _mip_: filter used between mip map levels\r\n           *@param samplingMode Define the new sampling mode of the texture\r\n           */\r\n    public updateSamplingMode(samplingMode: number): void {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        scene.getEngine().updateTextureSamplingMode(samplingMode, this._texture);\r\n    }\r\n\r\n    /**\r\n     * Scales the texture if is `canRescale()`\r\n     * @param ratio the resize factor we want to use to rescale\r\n     */\r\n    public scale(ratio: number): void {\r\n    }\r\n\r\n    /**\r\n     * Get if the texture can rescale.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _getFromCache(url: Nullable<string>, noMipmap: boolean, sampling?: number, invertY?: boolean): Nullable<InternalTexture> {\r\n        if (!this._scene) {\r\n            return null;\r\n        }\r\n\r\n        var texturesCache = this._scene.getEngine().getLoadedTexturesCache();\r\n        for (var index = 0; index < texturesCache.length; index++) {\r\n            var texturesCacheEntry = texturesCache[index];\r\n\r\n            if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\r\n                if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\r\n                    if (!sampling || sampling === texturesCacheEntry.samplingMode) {\r\n                        texturesCacheEntry.incrementReferences();\r\n                        return texturesCacheEntry;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n\r\n    }\r\n\r\n    /**\r\n     * Triggers the load sequence in delayed load mode.\r\n     */\r\n    public delayLoad(): void {\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying type (INT, FLOAT...)\r\n     */\r\n    public get textureType(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        return (this._texture.type !== undefined) ? this._texture.type : Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying format (RGB, RGBA...)\r\n     */\r\n    public get textureFormat(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTUREFORMAT_RGBA;\r\n        }\r\n\r\n        return (this._texture.format !== undefined) ? this._texture.format : Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n     * This will returns an RGBA array buffer containing either in values (0-255) or\r\n     * float values (0-1) depending of the underlying buffer type.\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @param buffer defines a user defined buffer to fill with data (can be null)\r\n     * @returns The Array buffer containing the pixels data.\r\n     */\r\n    public readPixels(faceIndex = 0, level = 0, buffer: Nullable<ArrayBufferView> = null): Nullable<ArrayBufferView> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        var size = this.getSize();\r\n        var width = size.width;\r\n        var height = size.height;\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return null;\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        if (level != 0) {\r\n            width = width / Math.pow(2, level);\r\n            height = height / Math.pow(2, level);\r\n\r\n            width = Math.round(width);\r\n            height = Math.round(height);\r\n        }\r\n\r\n        if (this._texture.isCube) {\r\n            return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer);\r\n        }\r\n\r\n        return engine._readTexturePixels(this._texture, width, height, -1, level, buffer);\r\n    }\r\n\r\n    /**\r\n     * Release and destroy the underlying lower level texture aka internalTexture.\r\n     */\r\n    public releaseInternalTexture(): void {\r\n        if (this._texture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the polynomial representation of the texture data.\r\n     * This is mainly use as a fast way to recover IBL Diffuse irradiance data.\r\n     * @see https://learnopengl.com/PBR/IBL/Diffuse-irradiance\r\n     */\r\n    public get sphericalPolynomial(): Nullable<SphericalPolynomial> {\r\n        if (!this._texture || !CubeMapToSphericalPolynomialTools || !this.isReady()) {\r\n            return null;\r\n        }\r\n\r\n        if (!this._texture._sphericalPolynomial) {\r\n            this._texture._sphericalPolynomial =\r\n                CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);\r\n        }\r\n\r\n        return this._texture._sphericalPolynomial;\r\n    }\r\n\r\n    public set sphericalPolynomial(value: Nullable<SphericalPolynomial>) {\r\n        if (this._texture) {\r\n            this._texture._sphericalPolynomial = value;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _lodTextureHigh(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureHigh;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _lodTextureMid(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureMid;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @hidden */\r\n    public get _lodTextureLow(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureLow;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n\r\n        // Animations\r\n        if (this._scene.stopAnimation) {\r\n            this._scene.stopAnimation(this);\r\n        }\r\n\r\n        // Remove from scene\r\n        this._scene._removePendingData(this);\r\n        var index = this._scene.textures.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            this._scene.textures.splice(index, 1);\r\n        }\r\n        this._scene.onTextureRemovedObservable.notifyObservers(this);\r\n\r\n        if (this._texture === undefined) {\r\n            return;\r\n        }\r\n\r\n        // Release\r\n        this.releaseInternalTexture();\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture into a JSON representation that can be parsed later on.\r\n     * @returns the JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Helper function to be called back once a list of texture contains only ready textures.\r\n     * @param textures Define the list of textures to wait for\r\n     * @param callback Define the callback triggered once the entire list will be ready\r\n     */\r\n    public static WhenAllReady(textures: BaseTexture[], callback: () => void): void {\r\n        let numRemaining = textures.length;\r\n        if (numRemaining === 0) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < textures.length; i++) {\r\n            var texture = textures[i];\r\n\r\n            if (texture.isReady()) {\r\n                if (--numRemaining === 0) {\r\n                    callback();\r\n                }\r\n            }\r\n            else {\r\n                var onLoadObservable = (texture as any).onLoadObservable as Observable<BaseTexture>;\r\n\r\n                let onLoadCallback = () => {\r\n                    onLoadObservable.removeCallback(onLoadCallback);\r\n                    if (--numRemaining === 0) {\r\n                        callback();\r\n                    }\r\n                };\r\n\r\n                onLoadObservable.add(onLoadCallback);\r\n            }\r\n        }\r\n    }\r\n}\r\n"]}