import { Scene } from "../../scene";
import { Engine } from "../../Engines/engine";
import { Texture } from "../../Materials/Textures/texture";
import { RenderTargetTexture } from "../../Materials/Textures/renderTargetTexture";
import "../../Engines/Extensions/engine.multiRender";
/**
 * Creation options of the multi render target texture.
 */
export interface IMultiRenderTargetOptions {
    /**
     * Define if the texture needs to create mip maps after render.
     */
    generateMipMaps?: boolean;
    /**
     * Define the types of all the draw buffers we want to create
     */
    types?: number[];
    /**
     * Define the sampling modes of all the draw buffers we want to create
     */
    samplingModes?: number[];
    /**
     * Define if a depth buffer is required
     */
    generateDepthBuffer?: boolean;
    /**
     * Define if a stencil buffer is required
     */
    generateStencilBuffer?: boolean;
    /**
     * Define if a depth texture is required instead of a depth buffer
     */
    generateDepthTexture?: boolean;
    /**
     * Define the number of desired draw buffers
     */
    textureCount?: number;
    /**
     * Define if aspect ratio should be adapted to the texture or stay the scene one
     */
    doNotChangeAspectRatio?: boolean;
    /**
     * Define the default type of the buffers we are creating
     */
    defaultType?: number;
}
/**
 * A multi render target, like a render target provides the ability to render to a texture.
 * Unlike the render target, it can render to several draw buffers in one draw.
 * This is specially interesting in deferred rendering or for any effects requiring more than
 * just one color from a single pass.
 */
export declare class MultiRenderTarget extends RenderTargetTexture {
    private _internalTextures;
    private _textures;
    private _multiRenderTargetOptions;
    /**
     * Get if draw buffers are currently supported by the used hardware and browser.
     */
    readonly isSupported: boolean;
    /**
     * Get the list of textures generated by the multi render target.
     */
    readonly textures: Texture[];
    /**
     * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set
     */
    readonly depthTexture: Texture;
    /**
     * Set the wrapping mode on U of all the textures we are rendering to.
     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
     */
    wrapU: number;
    /**
     * Set the wrapping mode on V of all the textures we are rendering to.
     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
     */
    wrapV: number;
    /**
     * Instantiate a new multi render target texture.
     * A multi render target, like a render target provides the ability to render to a texture.
     * Unlike the render target, it can render to several draw buffers in one draw.
     * This is specially interesting in deferred rendering or for any effects requiring more than
     * just one color from a single pass.
     * @param name Define the name of the texture
     * @param size Define the size of the buffers to render to
     * @param count Define the number of target we are rendering into
     * @param scene Define the scene the texture belongs to
     * @param options Define the options used to create the multi render target
     */
    constructor(name: string, size: any, count: number, scene: Scene, options?: IMultiRenderTargetOptions);
    /** @hidden */
    _rebuild(): void;
    private _createInternalTextures;
    private _createTextures;
    /**
     * Define the number of samples used if MSAA is enabled.
     */
    samples: number;
    /**
     * Resize all the textures in the multi render target.
     * Be carrefull as it will recreate all the data in the new texture.
     * @param size Define the new size
     */
    resize(size: any): void;
    protected unbindFrameBuffer(engine: Engine, faceIndex: number): void;
    /**
     * Dispose the render targets and their associated resources
     */
    dispose(): void;
    /**
     * Release all the underlying texture used as draw buffers.
     */
    releaseInternalTextures(): void;
}
