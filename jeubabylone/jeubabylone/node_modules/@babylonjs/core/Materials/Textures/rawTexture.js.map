{"version":3,"file":"rawTexture.js","sourceRoot":"","sources":["../../../../sourceES6/core/Materials/Textures/rawTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"../../scene\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\n\r\n/**\r\n * Raw texture can help creating a texture directly from an array of data.\r\n * This can be super useful if you either get the data from an uncompressed source or\r\n * if you wish to create your texture pixel by pixel.\r\n */\r\nexport class RawTexture extends Texture {\r\n    private _engine: Engine;\r\n\r\n    /**\r\n     * Instantiates a new RawTexture.\r\n     * Raw texture can help creating a texture directly from an array of data.\r\n     * This can be super useful if you either get the data from an uncompressed source or\r\n     * if you wish to create your texture pixel by pixel.\r\n     * @param data define the array of data to use to create the texture\r\n     * @param width define the width of the texture\r\n     * @param height define the height of the texture\r\n     * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n     * @param scene  define the scene the texture belongs to\r\n     * @param generateMipMaps define whether mip maps should be generated or not\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     */\r\n    constructor(data: ArrayBufferView, width: number, height: number,\r\n        /**\r\n         * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n         */\r\n        public format: number,\r\n        scene: Scene, generateMipMaps: boolean = true, invertY: boolean = false, samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, type: number = Constants.TEXTURETYPE_UNSIGNED_INT) {\r\n        super(null, scene, !generateMipMaps, invertY);\r\n        this._engine = scene.getEngine();\r\n        this._texture = scene.getEngine().createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type);\r\n\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n    }\r\n\r\n    /**\r\n     * Updates the texture underlying data.\r\n     * @param data Define the new data of the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        this._engine.updateRawTexture(this._texture, data, this._texture!.format, this._texture!.invertY, null, this._texture!.type);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance texture\r\n     */\r\n    public static CreateLuminanceTexture(data: ArrayBufferView, width: number, height: number, scene: Scene, generateMipMaps: boolean = true, invertY: boolean = false, samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE, scene, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance alpha texture\r\n     */\r\n    public static CreateLuminanceAlphaTexture(data: ArrayBufferView, width: number, height: number, scene: Scene, generateMipMaps: boolean = true, invertY: boolean = false, samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE_ALPHA, scene, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates an alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the alpha texture\r\n     */\r\n    public static CreateAlphaTexture(data: ArrayBufferView, width: number, height: number, scene: Scene, generateMipMaps: boolean = true, invertY: boolean = false, samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_ALPHA, scene, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGB texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the RGB alpha texture\r\n     */\r\n    public static CreateRGBTexture(data: ArrayBufferView, width: number, height: number, scene: Scene, generateMipMaps: boolean = true, invertY: boolean = false, samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, type: number = Constants.TEXTURETYPE_UNSIGNED_INT): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGB, scene, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(data: ArrayBufferView, width: number, height: number, scene: Scene, generateMipMaps: boolean = true, invertY: boolean = false, samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, type: number = Constants.TEXTURETYPE_UNSIGNED_INT): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, scene, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a R texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRTexture(data: ArrayBufferView, width: number, height: number, scene: Scene, generateMipMaps: boolean = true, invertY: boolean = false, samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE, type: number = Constants.TEXTURETYPE_FLOAT): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, scene, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n}\r\n"]}