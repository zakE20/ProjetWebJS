import { Observable } from "../../Misc/observable";
import { Nullable } from "../../types";
import { Scene } from "../../scene";
import { Matrix } from "../../Maths/math";
import { BaseTexture } from "../../Materials/Textures/baseTexture";
import { IInspectable } from '../../Misc/iInspectable';
/**
 * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.
 * @see http://doc.babylonjs.com/babylon101/materials#texture
 */
export declare class Texture extends BaseTexture {
    /** @hidden */
    static _CubeTextureParser: (jsonTexture: any, scene: Scene, rootUrl: string) => import("./cubeTexture").CubeTexture;
    /** @hidden */
    static _CreateMirror: (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean) => import("./mirrorTexture").MirrorTexture;
    /** @hidden */
    static _CreateRenderTargetTexture: (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean) => import("./renderTargetTexture").RenderTargetTexture;
    /** nearest is mag = nearest and min = nearest and mip = linear */
    static readonly NEAREST_SAMPLINGMODE = 1;
    /** nearest is mag = nearest and min = nearest and mip = linear */
    static readonly NEAREST_NEAREST_MIPLINEAR = 1;
    /** Bilinear is mag = linear and min = linear and mip = nearest */
    static readonly BILINEAR_SAMPLINGMODE = 2;
    /** Bilinear is mag = linear and min = linear and mip = nearest */
    static readonly LINEAR_LINEAR_MIPNEAREST = 2;
    /** Trilinear is mag = linear and min = linear and mip = linear */
    static readonly TRILINEAR_SAMPLINGMODE = 3;
    /** Trilinear is mag = linear and min = linear and mip = linear */
    static readonly LINEAR_LINEAR_MIPLINEAR = 3;
    /** mag = nearest and min = nearest and mip = nearest */
    static readonly NEAREST_NEAREST_MIPNEAREST = 4;
    /** mag = nearest and min = linear and mip = nearest */
    static readonly NEAREST_LINEAR_MIPNEAREST = 5;
    /** mag = nearest and min = linear and mip = linear */
    static readonly NEAREST_LINEAR_MIPLINEAR = 6;
    /** mag = nearest and min = linear and mip = none */
    static readonly NEAREST_LINEAR = 7;
    /** mag = nearest and min = nearest and mip = none */
    static readonly NEAREST_NEAREST = 8;
    /** mag = linear and min = nearest and mip = nearest */
    static readonly LINEAR_NEAREST_MIPNEAREST = 9;
    /** mag = linear and min = nearest and mip = linear */
    static readonly LINEAR_NEAREST_MIPLINEAR = 10;
    /** mag = linear and min = linear and mip = none */
    static readonly LINEAR_LINEAR = 11;
    /** mag = linear and min = nearest and mip = none */
    static readonly LINEAR_NEAREST = 12;
    /** Explicit coordinates mode */
    static readonly EXPLICIT_MODE = 0;
    /** Spherical coordinates mode */
    static readonly SPHERICAL_MODE = 1;
    /** Planar coordinates mode */
    static readonly PLANAR_MODE = 2;
    /** Cubic coordinates mode */
    static readonly CUBIC_MODE = 3;
    /** Projection coordinates mode */
    static readonly PROJECTION_MODE = 4;
    /** Inverse Cubic coordinates mode */
    static readonly SKYBOX_MODE = 5;
    /** Inverse Cubic coordinates mode */
    static readonly INVCUBIC_MODE = 6;
    /** Equirectangular coordinates mode */
    static readonly EQUIRECTANGULAR_MODE = 7;
    /** Equirectangular Fixed coordinates mode */
    static readonly FIXED_EQUIRECTANGULAR_MODE = 8;
    /** Equirectangular Fixed Mirrored coordinates mode */
    static readonly FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
    /** Texture is not repeating outside of 0..1 UVs */
    static readonly CLAMP_ADDRESSMODE = 0;
    /** Texture is repeating outside of 0..1 UVs */
    static readonly WRAP_ADDRESSMODE = 1;
    /** Texture is repeating and mirrored */
    static readonly MIRROR_ADDRESSMODE = 2;
    /**
     * Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file
     */
    static UseSerializedUrlIfAny: boolean;
    /**
     * Define the url of the texture.
     */
    url: Nullable<string>;
    /**
     * Define an offset on the texture to offset the u coordinates of the UVs
     * @see http://doc.babylonjs.com/how_to/more_materials#offsetting
     */
    uOffset: number;
    /**
     * Define an offset on the texture to offset the v coordinates of the UVs
     * @see http://doc.babylonjs.com/how_to/more_materials#offsetting
     */
    vOffset: number;
    /**
     * Define an offset on the texture to scale the u coordinates of the UVs
     * @see http://doc.babylonjs.com/how_to/more_materials#tiling
     */
    uScale: number;
    /**
     * Define an offset on the texture to scale the v coordinates of the UVs
     * @see http://doc.babylonjs.com/how_to/more_materials#tiling
     */
    vScale: number;
    /**
     * Define an offset on the texture to rotate around the u coordinates of the UVs
     * @see http://doc.babylonjs.com/how_to/more_materials
     */
    uAng: number;
    /**
     * Define an offset on the texture to rotate around the v coordinates of the UVs
     * @see http://doc.babylonjs.com/how_to/more_materials
     */
    vAng: number;
    /**
     * Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)
     * @see http://doc.babylonjs.com/how_to/more_materials
     */
    wAng: number;
    /**
     * Defines the center of rotation (U)
     */
    uRotationCenter: number;
    /**
     * Defines the center of rotation (V)
     */
    vRotationCenter: number;
    /**
     * Defines the center of rotation (W)
     */
    wRotationCenter: number;
    /**
     * Are mip maps generated for this texture or not.
     */
    readonly noMipmap: boolean;
    /**
     * List of inspectable custom properties (used by the Inspector)
     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
     */
    inspectableCustomProperties: Nullable<IInspectable[]>;
    private _noMipmap;
    /** @hidden */
    _invertY: boolean;
    private _rowGenerationMatrix;
    private _cachedTextureMatrix;
    private _projectionModeMatrix;
    private _t0;
    private _t1;
    private _t2;
    private _cachedUOffset;
    private _cachedVOffset;
    private _cachedUScale;
    private _cachedVScale;
    private _cachedUAng;
    private _cachedVAng;
    private _cachedWAng;
    private _cachedProjectionMatrixId;
    private _cachedCoordinatesMode;
    /** @hidden */
    protected _initialSamplingMode: number;
    /** @hidden */
    _buffer: Nullable<string | ArrayBuffer | HTMLImageElement | Blob>;
    private _deleteBuffer;
    protected _format: Nullable<number>;
    private _delayedOnLoad;
    private _delayedOnError;
    /**
     * Observable triggered once the texture has been loaded.
     */
    onLoadObservable: Observable<Texture>;
    protected _isBlocking: boolean;
    /**
     * Is the texture preventing material to render while loading.
     * If false, a default texture will be used instead of the loading one during the preparation step.
     */
    isBlocking: boolean;
    /**
     * Get the current sampling mode associated with the texture.
     */
    readonly samplingMode: number;
    /**
     * Gets a boolean indicating if the texture needs to be inverted on the y axis during loading
     */
    readonly invertY: boolean;
    /**
     * Instantiates a new texture.
     * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.
     * @see http://doc.babylonjs.com/babylon101/materials#texture
     * @param url define the url of the picture to load as a texture
     * @param scene define the scene the texture will belong to
     * @param noMipmap define if the texture will require mip maps or not
     * @param invertY define if the texture needs to be inverted on the y axis during loading
     * @param samplingMode define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)
     * @param onLoad define a callback triggered when the texture has been loaded
     * @param onError define a callback triggered when an error occurred during the loading session
     * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation
     * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load
     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
     */
    constructor(url: Nullable<string>, scene: Nullable<Scene>, noMipmap?: boolean, invertY?: boolean, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<(message?: string, exception?: any) => void>, buffer?: Nullable<string | ArrayBuffer | HTMLImageElement | Blob>, deleteBuffer?: boolean, format?: number);
    /**
     * Update the url (and optional buffer) of this texture if url was null during construction.
     * @param url the url of the texture
     * @param buffer the buffer of the texture (defaults to null)
     * @param onLoad callback called when the texture is loaded  (defaults to null)
     */
    updateURL(url: string, buffer?: Nullable<string | ArrayBuffer | HTMLImageElement | Blob>, onLoad?: () => void): void;
    /**
     * Finish the loading sequence of a texture flagged as delayed load.
     * @hidden
     */
    delayLoad(): void;
    private _prepareRowForTextureGeneration;
    /**
     * Get the current texture matrix which includes the requested offsetting, tiling and rotation components.
     * @returns the transform matrix of the texture.
     */
    getTextureMatrix(): Matrix;
    /**
     * Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.
     * @returns The reflection texture transform
     */
    getReflectionTextureMatrix(): Matrix;
    /**
     * Clones the texture.
     * @returns the cloned texture
     */
    clone(): Texture;
    /**
     * Serialize the texture to a JSON representation we can easily use in the resepective Parse function.
     * @returns The JSON representation of the texture
     */
    serialize(): any;
    /**
     * Get the current class name of the texture useful for serialization or dynamic coding.
     * @returns "Texture"
     */
    getClassName(): string;
    /**
     * Dispose the texture and release its associated resources.
     */
    dispose(): void;
    /**
     * Parse the JSON representation of a texture in order to recreate the texture in the given scene.
     * @param parsedTexture Define the JSON representation of the texture
     * @param scene Define the scene the parsed texture should be instantiated in
     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies
     * @returns The parsed texture if successful
     */
    static Parse(parsedTexture: any, scene: Scene, rootUrl: string): Nullable<BaseTexture>;
    /**
     * Creates a texture from its base 64 representation.
     * @param data Define the base64 payload without the data: prefix
     * @param name Define the name of the texture in the scene useful fo caching purpose for instance
     * @param scene Define the scene the texture should belong to
     * @param noMipmap Forces the texture to not create mip map information if true
     * @param invertY define if the texture needs to be inverted on the y axis during loading
     * @param samplingMode define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)
     * @param onLoad define a callback triggered when the texture has been loaded
     * @param onError define a callback triggered when an error occurred during the loading session
     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
     * @returns the created texture
     */
    static CreateFromBase64String(data: string, name: string, scene: Scene, noMipmap?: boolean, invertY?: boolean, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<() => void>, format?: number): Texture;
    /**
     * Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)
     * @param data Define the base64 payload without the data: prefix
     * @param name Define the name of the texture in the scene useful fo caching purpose for instance
     * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation
     * @param scene Define the scene the texture should belong to
     * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load
     * @param noMipmap Forces the texture to not create mip map information if true
     * @param invertY define if the texture needs to be inverted on the y axis during loading
     * @param samplingMode define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)
     * @param onLoad define a callback triggered when the texture has been loaded
     * @param onError define a callback triggered when an error occurred during the loading session
     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
     * @returns the created texture
     */
    static LoadFromDataString(name: string, buffer: any, scene: Scene, deleteBuffer?: boolean, noMipmap?: boolean, invertY?: boolean, samplingMode?: number, onLoad?: Nullable<() => void>, onError?: Nullable<(message?: string, exception?: any) => void>, format?: number): Texture;
}
