import { IAnimatable } from "../Misc/tools";
import { SmartArray } from "../Misc/smartArray";
import { Observable } from "../Misc/observable";
import { Nullable } from "../types";
import { Scene } from "../scene";
import { Matrix } from "../Maths/math";
import { BaseSubMesh, SubMesh } from "../Meshes/subMesh";
import { AbstractMesh } from "../Meshes/abstractMesh";
import { Mesh } from "../Meshes/mesh";
import { UniformBuffer } from "./uniformBuffer";
import { Effect } from "./effect";
import { BaseTexture } from "../Materials/Textures/baseTexture";
import { RenderTargetTexture } from "../Materials/Textures/renderTargetTexture";
import { MaterialDefines } from "./materialDefines";
import { IInspectable } from '../Misc/iInspectable';
declare type Animation = import("../Animations/animation").Animation;
/**
 * Base class for the main features of a material in Babylon.js
 */
export declare class Material implements IAnimatable {
    /**
     * Returns the triangle fill mode
     */
    static readonly TriangleFillMode = 0;
    /**
     * Returns the wireframe mode
     */
    static readonly WireFrameFillMode = 1;
    /**
     * Returns the point fill mode
     */
    static readonly PointFillMode = 2;
    /**
     * Returns the point list draw mode
     */
    static readonly PointListDrawMode = 3;
    /**
     * Returns the line list draw mode
     */
    static readonly LineListDrawMode = 4;
    /**
     * Returns the line loop draw mode
     */
    static readonly LineLoopDrawMode = 5;
    /**
     * Returns the line strip draw mode
     */
    static readonly LineStripDrawMode = 6;
    /**
     * Returns the triangle strip draw mode
     */
    static readonly TriangleStripDrawMode = 7;
    /**
     * Returns the triangle fan draw mode
     */
    static readonly TriangleFanDrawMode = 8;
    /**
     * Stores the clock-wise side orientation
     */
    static readonly ClockWiseSideOrientation = 0;
    /**
     * Stores the counter clock-wise side orientation
     */
    static readonly CounterClockWiseSideOrientation = 1;
    /**
     * The dirty texture flag value
     */
    static readonly TextureDirtyFlag = 1;
    /**
     * The dirty light flag value
     */
    static readonly LightDirtyFlag = 2;
    /**
     * The dirty fresnel flag value
     */
    static readonly FresnelDirtyFlag = 4;
    /**
     * The dirty attribute flag value
     */
    static readonly AttributesDirtyFlag = 8;
    /**
     * The dirty misc flag value
     */
    static readonly MiscDirtyFlag = 16;
    /**
     * The all dirty flag value
     */
    static readonly AllDirtyFlag = 31;
    /**
     * The ID of the material
     */
    id: string;
    /**
     * Gets or sets the unique id of the material
     */
    uniqueId: number;
    /**
     * The name of the material
     */
    name: string;
    /**
     * Gets or sets user defined metadata
     */
    metadata: any;
    /**
     * For internal use only. Please do not use.
     */
    reservedDataStore: any;
    /**
     * Specifies if the ready state should be checked on each call
     */
    checkReadyOnEveryCall: boolean;
    /**
     * Specifies if the ready state should be checked once
     */
    checkReadyOnlyOnce: boolean;
    /**
     * The state of the material
     */
    state: string;
    /**
     * The alpha value of the material
     */
    protected _alpha: number;
    /**
     * List of inspectable custom properties (used by the Inspector)
     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility
     */
    inspectableCustomProperties: IInspectable[];
    /**
     * Sets the alpha value of the material
     */
    /**
    * Gets the alpha value of the material
    */
    alpha: number;
    /**
     * Specifies if back face culling is enabled
     */
    protected _backFaceCulling: boolean;
    /**
     * Sets the back-face culling state
     */
    /**
    * Gets the back-face culling state
    */
    backFaceCulling: boolean;
    /**
     * Stores the value for side orientation
     */
    sideOrientation: number;
    /**
     * Callback triggered when the material is compiled
     */
    onCompiled: Nullable<(effect: Effect) => void>;
    /**
     * Callback triggered when an error occurs
     */
    onError: Nullable<(effect: Effect, errors: string) => void>;
    /**
     * Callback triggered to get the render target textures
     */
    getRenderTargetTextures: Nullable<() => SmartArray<RenderTargetTexture>>;
    /**
     * Gets a boolean indicating that current material needs to register RTT
     */
    readonly hasRenderTargetTextures: boolean;
    /**
     * Specifies if the material should be serialized
     */
    doNotSerialize: boolean;
    /**
     * @hidden
     */
    _storeEffectOnSubMeshes: boolean;
    /**
     * Stores the animations for the material
     */
    animations: Nullable<Array<Animation>>;
    /**
    * An event triggered when the material is disposed
    */
    onDisposeObservable: Observable<Material>;
    /**
     * An observer which watches for dispose events
     */
    private _onDisposeObserver;
    private _onUnBindObservable;
    /**
     * Called during a dispose event
     */
    onDispose: () => void;
    private _onBindObservable;
    /**
    * An event triggered when the material is bound
    */
    readonly onBindObservable: Observable<AbstractMesh>;
    /**
     * An observer which watches for bind events
     */
    private _onBindObserver;
    /**
     * Called during a bind event
     */
    onBind: (Mesh: AbstractMesh) => void;
    /**
    * An event triggered when the material is unbound
    */
    readonly onUnBindObservable: Observable<Material>;
    /**
     * Stores the value of the alpha mode
     */
    private _alphaMode;
    /**
     * Sets the value of the alpha mode.
     *
     * | Value | Type | Description |
     * | --- | --- | --- |
     * | 0 | ALPHA_DISABLE |   |
     * | 1 | ALPHA_ADD |   |
     * | 2 | ALPHA_COMBINE |   |
     * | 3 | ALPHA_SUBTRACT |   |
     * | 4 | ALPHA_MULTIPLY |   |
     * | 5 | ALPHA_MAXIMIZED |   |
     * | 6 | ALPHA_ONEONE |   |
     * | 7 | ALPHA_PREMULTIPLIED |   |
     * | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |
     * | 9 | ALPHA_INTERPOLATE |   |
     * | 10 | ALPHA_SCREENMODE |   |
     *
     */
    /**
    * Gets the value of the alpha mode
    */
    alphaMode: number;
    /**
     * Stores the state of the need depth pre-pass value
     */
    private _needDepthPrePass;
    /**
     * Sets the need depth pre-pass value
     */
    /**
    * Gets the depth pre-pass value
    */
    needDepthPrePass: boolean;
    /**
     * Specifies if depth writing should be disabled
     */
    disableDepthWrite: boolean;
    /**
     * Specifies if depth writing should be forced
     */
    forceDepthWrite: boolean;
    /**
     * Specifies if there should be a separate pass for culling
     */
    separateCullingPass: boolean;
    /**
     * Stores the state specifing if fog should be enabled
     */
    private _fogEnabled;
    /**
     * Sets the state for enabling fog
     */
    /**
    * Gets the value of the fog enabled state
    */
    fogEnabled: boolean;
    /**
     * Stores the size of points
     */
    pointSize: number;
    /**
     * Stores the z offset value
     */
    zOffset: number;
    /**
     * Gets a value specifying if wireframe mode is enabled
     */
    /**
    * Sets the state of wireframe mode
    */
    wireframe: boolean;
    /**
     * Gets the value specifying if point clouds are enabled
     */
    /**
    * Sets the state of point cloud mode
    */
    pointsCloud: boolean;
    /**
     * Gets the material fill mode
     */
    /**
    * Sets the material fill mode
    */
    fillMode: number;
    /**
     * @hidden
     * Stores the effects for the material
     */
    _effect: Nullable<Effect>;
    /**
     * @hidden
     * Specifies if the material was previously ready
     */
    _wasPreviouslyReady: boolean;
    /**
     * Specifies if uniform buffers should be used
     */
    private _useUBO;
    /**
     * Stores a reference to the scene
     */
    private _scene;
    /**
     * Stores the fill mode state
     */
    private _fillMode;
    /**
     * Specifies if the depth write state should be cached
     */
    private _cachedDepthWriteState;
    /**
     * Stores the uniform buffer
     */
    protected _uniformBuffer: UniformBuffer;
    /** @hidden */
    _indexInSceneMaterialArray: number;
    /** @hidden */
    meshMap: Nullable<{
        [id: string]: AbstractMesh | undefined;
    }>;
    /**
     * Creates a material instance
     * @param name defines the name of the material
     * @param scene defines the scene to reference
     * @param doNotAdd specifies if the material should be added to the scene
     */
    constructor(name: string, scene: Scene, doNotAdd?: boolean);
    /**
     * Returns a string representation of the current material
     * @param fullDetails defines a boolean indicating which levels of logging is desired
     * @returns a string with material information
     */
    toString(fullDetails?: boolean): string;
    /**
     * Gets the class name of the material
     * @returns a string with the class name of the material
     */
    getClassName(): string;
    /**
     * Specifies if updates for the material been locked
     */
    readonly isFrozen: boolean;
    /**
     * Locks updates for the material
     */
    freeze(): void;
    /**
     * Unlocks updates for the material
     */
    unfreeze(): void;
    /**
     * Specifies if the material is ready to be used
     * @param mesh defines the mesh to check
     * @param useInstances specifies if instances should be used
     * @returns a boolean indicating if the material is ready to be used
     */
    isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean;
    /**
     * Specifies that the submesh is ready to be used
     * @param mesh defines the mesh to check
     * @param subMesh defines which submesh to check
     * @param useInstances specifies that instances should be used
     * @returns a boolean indicating that the submesh is ready or not
     */
    isReadyForSubMesh(mesh: AbstractMesh, subMesh: BaseSubMesh, useInstances?: boolean): boolean;
    /**
     * Returns the material effect
     * @returns the effect associated with the material
     */
    getEffect(): Nullable<Effect>;
    /**
     * Returns the current scene
     * @returns a Scene
     */
    getScene(): Scene;
    /**
     * Specifies if the material will require alpha blending
     * @returns a boolean specifying if alpha blending is needed
     */
    needAlphaBlending(): boolean;
    /**
     * Specifies if the mesh will require alpha blending
     * @param mesh defines the mesh to check
     * @returns a boolean specifying if alpha blending is needed for the mesh
     */
    needAlphaBlendingForMesh(mesh: AbstractMesh): boolean;
    /**
     * Specifies if this material should be rendered in alpha test mode
     * @returns a boolean specifying if an alpha test is needed.
     */
    needAlphaTesting(): boolean;
    /**
     * Gets the texture used for the alpha test
     * @returns the texture to use for alpha testing
     */
    getAlphaTestTexture(): Nullable<BaseTexture>;
    /**
     * Marks the material to indicate that it needs to be re-calculated
     */
    markDirty(): void;
    /** @hidden */
    _preBind(effect?: Effect, overrideOrientation?: Nullable<number>): boolean;
    /**
     * Binds the material to the mesh
     * @param world defines the world transformation matrix
     * @param mesh defines the mesh to bind the material to
     */
    bind(world: Matrix, mesh?: Mesh): void;
    /**
     * Binds the submesh to the material
     * @param world defines the world transformation matrix
     * @param mesh defines the mesh containing the submesh
     * @param subMesh defines the submesh to bind the material to
     */
    bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
    /**
     * Binds the world matrix to the material
     * @param world defines the world transformation matrix
     */
    bindOnlyWorldMatrix(world: Matrix): void;
    /**
     * Binds the scene's uniform buffer to the effect.
     * @param effect defines the effect to bind to the scene uniform buffer
     * @param sceneUbo defines the uniform buffer storing scene data
     */
    bindSceneUniformBuffer(effect: Effect, sceneUbo: UniformBuffer): void;
    /**
     * Binds the view matrix to the effect
     * @param effect defines the effect to bind the view matrix to
     */
    bindView(effect: Effect): void;
    /**
     * Binds the view projection matrix to the effect
     * @param effect defines the effect to bind the view projection matrix to
     */
    bindViewProjection(effect: Effect): void;
    /**
     * Specifies if material alpha testing should be turned on for the mesh
     * @param mesh defines the mesh to check
     */
    protected _shouldTurnAlphaTestOn(mesh: AbstractMesh): boolean;
    /**
     * Processes to execute after binding the material to a mesh
     * @param mesh defines the rendered mesh
     */
    protected _afterBind(mesh?: Mesh): void;
    /**
     * Unbinds the material from the mesh
     */
    unbind(): void;
    /**
     * Gets the active textures from the material
     * @returns an array of textures
     */
    getActiveTextures(): BaseTexture[];
    /**
     * Specifies if the material uses a texture
     * @param texture defines the texture to check against the material
     * @returns a boolean specifying if the material uses the texture
     */
    hasTexture(texture: BaseTexture): boolean;
    /**
     * Makes a duplicate of the material, and gives it a new name
     * @param name defines the new name for the duplicated material
     * @returns the cloned material
     */
    clone(name: string): Nullable<Material>;
    /**
     * Gets the meshes bound to the material
     * @returns an array of meshes bound to the material
     */
    getBindedMeshes(): AbstractMesh[];
    /**
     * Force shader compilation
     * @param mesh defines the mesh associated with this material
     * @param onCompiled defines a function to execute once the material is compiled
     * @param options defines the options to configure the compilation
     */
    forceCompilation(mesh: AbstractMesh, onCompiled?: (material: Material) => void, options?: Partial<{
        clipPlane: boolean;
    }>): void;
    /**
     * Force shader compilation
     * @param mesh defines the mesh that will use this material
     * @param options defines additional options for compiling the shaders
     * @returns a promise that resolves when the compilation completes
     */
    forceCompilationAsync(mesh: AbstractMesh, options?: Partial<{
        clipPlane: boolean;
    }>): Promise<void>;
    private static readonly _ImageProcessingDirtyCallBack;
    private static readonly _TextureDirtyCallBack;
    private static readonly _FresnelDirtyCallBack;
    private static readonly _MiscDirtyCallBack;
    private static readonly _LightsDirtyCallBack;
    private static readonly _AttributeDirtyCallBack;
    private static _FresnelAndMiscDirtyCallBack;
    private static _TextureAndMiscDirtyCallBack;
    private static readonly _DirtyCallbackArray;
    private static readonly _RunDirtyCallBacks;
    /**
     * Marks a define in the material to indicate that it needs to be re-computed
     * @param flag defines a flag used to determine which parts of the material have to be marked as dirty
     */
    markAsDirty(flag: number): void;
    /**
     * Marks all submeshes of a material to indicate that their material defines need to be re-calculated
     * @param func defines a function which checks material defines against the submeshes
     */
    protected _markAllSubMeshesAsDirty(func: (defines: MaterialDefines) => void): void;
    /**
     * Indicates that image processing needs to be re-calculated for all submeshes
     */
    protected _markAllSubMeshesAsImageProcessingDirty(): void;
    /**
     * Indicates that textures need to be re-calculated for all submeshes
     */
    protected _markAllSubMeshesAsTexturesDirty(): void;
    /**
     * Indicates that fresnel needs to be re-calculated for all submeshes
     */
    protected _markAllSubMeshesAsFresnelDirty(): void;
    /**
     * Indicates that fresnel and misc need to be re-calculated for all submeshes
     */
    protected _markAllSubMeshesAsFresnelAndMiscDirty(): void;
    /**
     * Indicates that lights need to be re-calculated for all submeshes
     */
    protected _markAllSubMeshesAsLightsDirty(): void;
    /**
     * Indicates that attributes need to be re-calculated for all submeshes
     */
    protected _markAllSubMeshesAsAttributesDirty(): void;
    /**
     * Indicates that misc needs to be re-calculated for all submeshes
     */
    protected _markAllSubMeshesAsMiscDirty(): void;
    /**
     * Indicates that textures and misc need to be re-calculated for all submeshes
     */
    protected _markAllSubMeshesAsTexturesAndMiscDirty(): void;
    /**
     * Disposes the material
     * @param forceDisposeEffect specifies if effects should be forcefully disposed
     * @param forceDisposeTextures specifies if textures should be forcefully disposed
     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
     */
    dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void;
    /** @hidden */
    private releaseVertexArrayObject;
    /**
     * Serializes this material
     * @returns the serialized material object
     */
    serialize(): any;
    /**
     * Creates a material from parsed material data
     * @param parsedMaterial defines parsed material data
     * @param scene defines the hosting scene
     * @param rootUrl defines the root URL to use to load textures
     * @returns a new material
     */
    static Parse(parsedMaterial: any, scene: Scene, rootUrl: string): Nullable<Material>;
}
export {};
