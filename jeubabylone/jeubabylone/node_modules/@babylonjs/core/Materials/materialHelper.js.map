{"version":3,"file":"materialHelper.js","sourceRoot":"","sources":["../../../sourceES6/core/Materials/materialHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport { Nullable } from \"../types\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Tmp, Color3 } from \"../Maths/math\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Light } from \"../Lights/light\";\r\n\r\nimport { UniformBuffer } from \"./uniformBuffer\";\r\nimport { Effect, EffectFallbacks, EffectCreationOptions } from \"./effect\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { WebVRFreeCamera } from '../Cameras/VR/webVRCamera';\r\n\r\n/**\r\n * \"Static Class\" containing the most commonly used helper while dealing with material for\r\n * rendering purpose.\r\n *\r\n * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.\r\n *\r\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\r\n */\r\nexport class MaterialHelper {\r\n\r\n    /**\r\n     * Bind the current view position to an effect.\r\n     * @param effect The effect to be bound\r\n     * @param scene The scene the eyes position is used from\r\n     */\r\n    public static BindEyePosition(effect: Effect, scene: Scene): void {\r\n        if (scene._forcedViewPosition) {\r\n            effect.setVector3(\"vEyePosition\", scene._forcedViewPosition);\r\n            return;\r\n        }\r\n        var globalPosition = scene.activeCamera!.globalPosition;\r\n        if (!globalPosition) {\r\n            // Use WebVRFreecamera's device position as global position is not it's actual position in babylon space\r\n            globalPosition = (scene.activeCamera! as WebVRFreeCamera).devicePosition;\r\n        }\r\n        effect.setVector3(\"vEyePosition\", scene._mirroredCameraPosition ? scene._mirroredCameraPosition : globalPosition);\r\n    }\r\n\r\n    /**\r\n     * Helps preparing the defines values about the UVs in used in the effect.\r\n     * UVs are shared as much as we can accross channels in the shaders.\r\n     * @param texture The texture we are preparing the UVs for\r\n     * @param defines The defines to update\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    public static PrepareDefinesForMergedUV(texture: BaseTexture, defines: any, key: string): void {\r\n        defines._needUVs = true;\r\n        defines[key] = true;\r\n        if (texture.getTextureMatrix().isIdentityAs3x2()) {\r\n            defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\r\n            if (texture.coordinatesIndex === 0) {\r\n                defines[\"MAINUV1\"] = true;\r\n            } else {\r\n                defines[\"MAINUV2\"] = true;\r\n            }\r\n        } else {\r\n            defines[key + \"DIRECTUV\"] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds a texture matrix value to its corrsponding uniform\r\n     * @param texture The texture to bind the matrix for\r\n     * @param uniformBuffer The uniform buffer receivin the data\r\n     * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n     */\r\n    public static BindTextureMatrix(texture: BaseTexture, uniformBuffer: UniformBuffer, key: string): void {\r\n        var matrix = texture.getTextureMatrix();\r\n\r\n        if (!matrix.isIdentityAs3x2()) {\r\n            uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n     * @param mesh defines the current mesh\r\n     * @param scene defines the current scene\r\n     * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n     * @param pointsCloud defines if point cloud rendering has to be turned on\r\n     * @param fogEnabled defines if fog has to be turned on\r\n     * @param alphaTest defines if alpha testing has to be turned on\r\n     * @param defines defines the current list of defines\r\n     */\r\n    public static PrepareDefinesForMisc(mesh: AbstractMesh, scene: Scene, useLogarithmicDepth: boolean, pointsCloud: boolean, fogEnabled: boolean, alphaTest: boolean, defines: any): void {\r\n        if (defines._areMiscDirty) {\r\n            defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\r\n            defines[\"POINTSIZE\"] = pointsCloud;\r\n            defines[\"FOG\"] = (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE && fogEnabled);\r\n            defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\r\n            defines[\"ALPHATEST\"] = alphaTest;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n     * @param scene defines the current scene\r\n     * @param engine defines the current engine\r\n     * @param defines specifies the list of active defines\r\n     * @param useInstances defines if instances have to be turned on\r\n     * @param useClipPlane defines if clip plane have to be turned on\r\n     */\r\n    public static PrepareDefinesForFrameBoundValues(scene: Scene, engine: Engine, defines: any, useInstances: boolean, useClipPlane: Nullable<boolean> = null): void {\r\n        var changed = false;\r\n        let useClipPlane1 = false;\r\n        let useClipPlane2 = false;\r\n        let useClipPlane3 = false;\r\n        let useClipPlane4 = false;\r\n\r\n        useClipPlane1 = useClipPlane == null ? (scene.clipPlane !== undefined && scene.clipPlane !== null) : useClipPlane;\r\n        useClipPlane2 = useClipPlane == null ? (scene.clipPlane2 !== undefined && scene.clipPlane2 !== null) : useClipPlane;\r\n        useClipPlane3 = useClipPlane == null ? (scene.clipPlane3 !== undefined && scene.clipPlane3 !== null) : useClipPlane;\r\n        useClipPlane4 = useClipPlane == null ? (scene.clipPlane4 !== undefined && scene.clipPlane4 !== null) : useClipPlane;\r\n\r\n        if (defines[\"CLIPPLANE\"] !== useClipPlane1) {\r\n            defines[\"CLIPPLANE\"] = useClipPlane1;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE2\"] !== useClipPlane2) {\r\n            defines[\"CLIPPLANE2\"] = useClipPlane2;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE3\"] !== useClipPlane3) {\r\n            defines[\"CLIPPLANE3\"] = useClipPlane3;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"CLIPPLANE4\"] !== useClipPlane4) {\r\n            defines[\"CLIPPLANE4\"] = useClipPlane4;\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\r\n            defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\r\n            changed = true;\r\n        }\r\n\r\n        if (defines[\"INSTANCES\"] !== useInstances) {\r\n            defines[\"INSTANCES\"] = useInstances;\r\n            changed = true;\r\n        }\r\n\r\n        if (changed) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n     * @param mesh The mesh containing the geometry data we will draw\r\n     * @param defines The defines to update\r\n     * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n     * @param useBones Precise whether bones should be used or not (override mesh info)\r\n     * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n     * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n     * @returns false if defines are considered not dirty and have not been checked\r\n     */\r\n    public static PrepareDefinesForAttributes(mesh: AbstractMesh, defines: any, useVertexColor: boolean, useBones: boolean, useMorphTargets = false, useVertexAlpha = true): boolean {\r\n        if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\r\n            return false;\r\n        }\r\n\r\n        defines._normals = defines._needNormals;\r\n        defines._uvs = defines._needUVs;\r\n\r\n        defines[\"NORMAL\"] = (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind));\r\n\r\n        if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            defines[\"TANGENT\"] = true;\r\n        }\r\n\r\n        if (defines._needUVs) {\r\n            defines[\"UV1\"] = mesh.isVerticesDataPresent(VertexBuffer.UVKind);\r\n            defines[\"UV2\"] = mesh.isVerticesDataPresent(VertexBuffer.UV2Kind);\r\n        } else {\r\n            defines[\"UV1\"] = false;\r\n            defines[\"UV2\"] = false;\r\n        }\r\n\r\n        if (useVertexColor) {\r\n            var hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);\r\n            defines[\"VERTEXCOLOR\"] = hasVertexColors;\r\n            defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\r\n        }\r\n\r\n        if (useBones) {\r\n            if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n                defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\r\n\r\n                const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\r\n\r\n                if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\r\n                    defines[\"BONETEXTURE\"] = true;\r\n                } else {\r\n                    defines[\"BonesPerMesh\"] = (mesh.skeleton.bones.length + 1);\r\n                    defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\r\n                }\r\n            } else {\r\n                defines[\"NUM_BONE_INFLUENCERS\"] = 0;\r\n                defines[\"BonesPerMesh\"] = 0;\r\n            }\r\n        }\r\n\r\n        if (useMorphTargets) {\r\n            var manager = (<Mesh>mesh).morphTargetManager;\r\n            if (manager) {\r\n                defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\r\n                defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\r\n                defines[\"MORPHTARGETS\"] = (manager.numInfluencers > 0);\r\n                defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numInfluencers;\r\n            } else {\r\n                defines[\"MORPHTARGETS_TANGENT\"] = false;\r\n                defines[\"MORPHTARGETS_NORMAL\"] = false;\r\n                defines[\"MORPHTARGETS\"] = false;\r\n                defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to multiview\r\n     * @param scene The scene we are intending to draw\r\n     * @param defines The defines to update\r\n     */\r\n    public static PrepareDefinesForMultiview(scene: Scene, defines: any) {\r\n        if (scene.activeCamera) {\r\n            var previousMultiview = defines.MULTIVIEW;\r\n            defines.MULTIVIEW = (scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1);\r\n            if (defines.MULTIVIEW != previousMultiview) {\r\n                defines.markAsUnprocessed();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the defines related to the light information passed in parameter\r\n     * @param scene The scene we are intending to draw\r\n     * @param mesh The mesh the effect is compiling for\r\n     * @param defines The defines to update\r\n     * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n     * @param maxSimultaneousLights Specfies how manuy lights can be added to the effect at max\r\n     * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n     * @returns true if normals will be required for the rest of the effect\r\n     */\r\n    public static PrepareDefinesForLights(scene: Scene, mesh: AbstractMesh, defines: any, specularSupported: boolean, maxSimultaneousLights = 4, disableLighting = false): boolean {\r\n        if (!defines._areLightsDirty) {\r\n            return defines._needNormals;\r\n        }\r\n\r\n        var lightIndex = 0;\r\n        var needNormals = false;\r\n        var needRebuild = false;\r\n        var lightmapMode = false;\r\n        var shadowEnabled = false;\r\n        var specularEnabled = false;\r\n\r\n        if (scene.lightsEnabled && !disableLighting) {\r\n            for (var light of mesh.lightSources) {\r\n                needNormals = true;\r\n\r\n                if (defines[\"LIGHT\" + lightIndex] === undefined) {\r\n                    needRebuild = true;\r\n                }\r\n\r\n                defines[\"LIGHT\" + lightIndex] = true;\r\n\r\n                defines[\"SPOTLIGHT\" + lightIndex] = false;\r\n                defines[\"HEMILIGHT\" + lightIndex] = false;\r\n                defines[\"POINTLIGHT\" + lightIndex] = false;\r\n                defines[\"DIRLIGHT\" + lightIndex] = false;\r\n\r\n                light.prepareLightSpecificDefines(defines, lightIndex);\r\n\r\n                // FallOff.\r\n                defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\r\n                defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\r\n                defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\r\n\r\n                switch (light.falloffType) {\r\n                    case Light.FALLOFF_GLTF:\r\n                        defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\r\n                        break;\r\n                    case Light.FALLOFF_PHYSICAL:\r\n                        defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\r\n                        break;\r\n                    case Light.FALLOFF_STANDARD:\r\n                        defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\r\n                        break;\r\n                }\r\n\r\n                // Specular\r\n                if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\r\n                    specularEnabled = true;\r\n                }\r\n\r\n                // Shadows\r\n                defines[\"SHADOW\" + lightIndex] = false;\r\n                defines[\"SHADOWPCF\" + lightIndex] = false;\r\n                defines[\"SHADOWPCSS\" + lightIndex] = false;\r\n                defines[\"SHADOWPOISSON\" + lightIndex] = false;\r\n                defines[\"SHADOWESM\" + lightIndex] = false;\r\n                defines[\"SHADOWCUBE\" + lightIndex] = false;\r\n                defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\r\n                defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\r\n\r\n                if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\r\n                    var shadowGenerator = light.getShadowGenerator();\r\n                    if (shadowGenerator) {\r\n                        const shadowMap = shadowGenerator.getShadowMap();\r\n                        if (shadowMap) {\r\n                            if (shadowMap.renderList && shadowMap.renderList.length > 0) {\r\n                                shadowEnabled = true;\r\n                                shadowGenerator.prepareDefines(defines, lightIndex);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (light.lightmapMode != Light.LIGHTMAP_DEFAULT) {\r\n                    lightmapMode = true;\r\n                    defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\r\n                    defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = (light.lightmapMode == Light.LIGHTMAP_SHADOWSONLY);\r\n                } else {\r\n                    defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\r\n                    defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\r\n                }\r\n\r\n                lightIndex++;\r\n                if (lightIndex === maxSimultaneousLights) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        defines[\"SPECULARTERM\"] = specularEnabled;\r\n        defines[\"SHADOWS\"] = shadowEnabled;\r\n\r\n        // Resetting all other lights if any\r\n        for (var index = lightIndex; index < maxSimultaneousLights; index++) {\r\n            if (defines[\"LIGHT\" + index] !== undefined) {\r\n                defines[\"LIGHT\" + index] = false;\r\n                defines[\"HEMILIGHT\" + index] = false;\r\n                defines[\"POINTLIGHT\" + index] = false;\r\n                defines[\"DIRLIGHT\" + index] = false;\r\n                defines[\"SPOTLIGHT\" + index] = false;\r\n                defines[\"SHADOW\" + index] = false;\r\n                defines[\"SHADOWPCF\" + index] = false;\r\n                defines[\"SHADOWPCSS\" + index] = false;\r\n                defines[\"SHADOWPOISSON\" + index] = false;\r\n                defines[\"SHADOWESM\" + index] = false;\r\n                defines[\"SHADOWCUBE\" + index] = false;\r\n                defines[\"SHADOWLOWQUALITY\" + index] = false;\r\n                defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\r\n            }\r\n        }\r\n\r\n        let caps = scene.getEngine().getCaps();\r\n\r\n        if (defines[\"SHADOWFLOAT\"] === undefined) {\r\n            needRebuild = true;\r\n        }\r\n\r\n        defines[\"SHADOWFLOAT\"] = shadowEnabled &&\r\n            ((caps.textureFloatRender && caps.textureFloatLinearFiltering) ||\r\n                (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering));\r\n        defines[\"LIGHTMAPEXCLUDED\"] = lightmapMode;\r\n\r\n        if (needRebuild) {\r\n            defines.rebuild();\r\n        }\r\n\r\n        return needNormals;\r\n    }\r\n\r\n    /**\r\n     * Prepares the uniforms and samplers list to be used in the effect. This can automatically remove from the list uniforms\r\n     * that won t be acctive due to defines being turned off.\r\n     * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the liist and extra information\r\n     * @param samplersList The samplers list\r\n     * @param defines The defines helping in the list generation\r\n     * @param maxSimultaneousLights The maximum number of simultanous light allowed in the effect\r\n     */\r\n    public static PrepareUniformsAndSamplersList(uniformsListOrOptions: string[] | EffectCreationOptions, samplersList?: string[], defines?: any, maxSimultaneousLights = 4): void {\r\n        let uniformsList: string[];\r\n        let uniformBuffersList: Nullable<string[]> = null;\r\n\r\n        if ((<EffectCreationOptions>uniformsListOrOptions).uniformsNames) {\r\n            var options = <EffectCreationOptions>uniformsListOrOptions;\r\n            uniformsList = options.uniformsNames;\r\n            uniformBuffersList = options.uniformBuffersNames;\r\n            samplersList = options.samplers;\r\n            defines = options.defines;\r\n            maxSimultaneousLights = options.maxSimultaneousLights;\r\n        } else {\r\n            uniformsList = <string[]>uniformsListOrOptions;\r\n            if (!samplersList) {\r\n                samplersList = [];\r\n            }\r\n        }\r\n\r\n        for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n\r\n            uniformsList.push(\r\n                \"vLightData\" + lightIndex,\r\n                \"vLightDiffuse\" + lightIndex,\r\n                \"vLightSpecular\" + lightIndex,\r\n                \"vLightDirection\" + lightIndex,\r\n                \"vLightFalloff\" + lightIndex,\r\n                \"vLightGround\" + lightIndex,\r\n                \"lightMatrix\" + lightIndex,\r\n                \"shadowsInfo\" + lightIndex,\r\n                \"depthValues\" + lightIndex,\r\n            );\r\n\r\n            if (uniformBuffersList) {\r\n                uniformBuffersList.push(\"Light\" + lightIndex);\r\n            }\r\n\r\n            samplersList.push(\"shadowSampler\" + lightIndex);\r\n            samplersList.push(\"depthSampler\" + lightIndex);\r\n\r\n            if (defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex]) {\r\n                samplersList.push(\"projectionLightSampler\" + lightIndex);\r\n                uniformsList.push(\r\n                    \"textureProjectionMatrix\" + lightIndex,\r\n                );\r\n            }\r\n        }\r\n\r\n        if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n            uniformsList.push(\"morphTargetInfluences\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n     * @param defines The defines to update while falling back\r\n     * @param fallbacks The authorized effect fallbacks\r\n     * @param maxSimultaneousLights The maximum number of lights allowed\r\n     * @param rank the current rank of the Effect\r\n     * @returns The newly affected rank\r\n     */\r\n    public static HandleFallbacksForShadows(defines: any, fallbacks: EffectFallbacks, maxSimultaneousLights = 4, rank = 0): number {\r\n        let lightFallbackRank = 0;\r\n        for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n\r\n            if (lightIndex > 0) {\r\n                lightFallbackRank = rank + lightIndex;\r\n                fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\r\n            }\r\n\r\n            if (!defines[\"SHADOWS\"]) {\r\n                if (defines[\"SHADOW\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPCF\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPCSS\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWPOISSON\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\r\n                }\r\n\r\n                if (defines[\"SHADOWESM\" + lightIndex]) {\r\n                    fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\r\n                }\r\n            }\r\n        }\r\n        return lightFallbackRank++;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of attributes required for morph targets according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the morph targets attributes for\r\n     * @param defines The current Defines of the effect\r\n     */\r\n    public static PrepareAttributesForMorphTargets(attribs: string[], mesh: AbstractMesh, defines: any): void {\r\n        var influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\r\n\r\n        if (influencers > 0 && EngineStore.LastCreatedEngine) {\r\n            var maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\r\n            var manager = (<Mesh>mesh).morphTargetManager;\r\n            var normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n            var tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n            for (var index = 0; index < influencers; index++) {\r\n                attribs.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (normal) {\r\n                    attribs.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (tangent) {\r\n                    attribs.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (attribs.length > maxAttributesCount) {\r\n                    Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of attributes required for bones according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param mesh The mesh to prepare the bones attributes for\r\n     * @param defines The current Defines of the effect\r\n     * @param fallbacks The current efffect fallback strategy\r\n     */\r\n    public static PrepareAttributesForBones(attribs: string[], mesh: AbstractMesh, defines: any, fallbacks: EffectFallbacks): void {\r\n        if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of attributes required for instances according to the effect defines.\r\n     * @param attribs The current list of supported attribs\r\n     * @param defines The current Defines of the effect\r\n     */\r\n    public static PrepareAttributesForInstances(attribs: string[], defines: any): void {\r\n        if (defines[\"INSTANCES\"]) {\r\n            attribs.push(\"world0\");\r\n            attribs.push(\"world1\");\r\n            attribs.push(\"world2\");\r\n            attribs.push(\"world3\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the light shadow information to the effect for the given mesh.\r\n     * @param light The light containing the generator\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param lightIndex The light index in the effect used to render the mesh\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    public static BindLightShadow(light: Light, mesh: AbstractMesh, lightIndex: string, effect: Effect): void {\r\n        if (light.shadowEnabled && mesh.receiveShadows) {\r\n            var shadowGenerator = light.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                shadowGenerator.bindShadowLight(lightIndex, effect);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the light information to the effect.\r\n     * @param light The light containing the generator\r\n     * @param effect The effect we are binding the data to\r\n     * @param lightIndex The light index in the effect used to render\r\n     */\r\n    public static BindLightProperties(light: Light, effect: Effect, lightIndex: number): void {\r\n        light.transferToEffect(effect, lightIndex + \"\");\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param defines The generated defines for the effect\r\n     * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n     * @param usePhysicalLightFalloff Specifies whether the light falloff is defined physically or not\r\n     */\r\n    public static BindLights(scene: Scene, mesh: AbstractMesh, effect: Effect, defines: any, maxSimultaneousLights = 4, usePhysicalLightFalloff = false): void {\r\n        let len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\r\n\r\n        for (var i = 0; i < len; i++) {\r\n\r\n            let light = mesh.lightSources[i];\r\n            let iAsString = i.toString();\r\n\r\n            let scaledIntensity = light.getScaledIntensity();\r\n            light._uniformBuffer.bindToEffect(effect, \"Light\" + i);\r\n\r\n            MaterialHelper.BindLightProperties(light, effect, i);\r\n\r\n            light.diffuse.scaleToRef(scaledIntensity, Tmp.Color3[0]);\r\n            light._uniformBuffer.updateColor4(\"vLightDiffuse\", Tmp.Color3[0], usePhysicalLightFalloff ? light.radius : light.range, iAsString);\r\n            if (defines[\"SPECULARTERM\"]) {\r\n                light.specular.scaleToRef(scaledIntensity, Tmp.Color3[1]);\r\n                light._uniformBuffer.updateColor3(\"vLightSpecular\", Tmp.Color3[1], iAsString);\r\n            }\r\n\r\n            // Shadows\r\n            if (scene.shadowsEnabled) {\r\n                this.BindLightShadow(light, mesh, iAsString, effect);\r\n            }\r\n            light._uniformBuffer.update();\r\n        }\r\n    }\r\n\r\n    private static _tempFogColor = Color3.Black();\r\n    /**\r\n     * Binds the fog information from the scene to the effect for the given mesh.\r\n     * @param scene The scene the lights belongs to\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     * @param linearSpace Defines if the fog effect is applied in linear space\r\n     */\r\n    public static BindFogParameters(scene: Scene, mesh: AbstractMesh, effect: Effect, linearSpace = false): void {\r\n        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n            // Convert fog color to linear space if used in a linear space computed shader.\r\n            if (linearSpace) {\r\n                scene.fogColor.toLinearSpaceToRef(this._tempFogColor);\r\n                effect.setColor3(\"vFogColor\", this._tempFogColor);\r\n            }\r\n            else {\r\n                effect.setColor3(\"vFogColor\", scene.fogColor);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the bones information from the mesh to the effect.\r\n     * @param mesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    public static BindBonesParameters(mesh?: AbstractMesh, effect?: Effect): void {\r\n        if (!effect || !mesh) {\r\n            return;\r\n        }\r\n        if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\r\n            mesh.computeBonesUsingShaders = false;\r\n        }\r\n\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            const skeleton = mesh.skeleton;\r\n\r\n            if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\r\n                const boneTexture = skeleton.getTransformMatrixTexture();\r\n                effect.setTexture(\"boneSampler\", boneTexture);\r\n                effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n            } else {\r\n                const matrices = skeleton.getTransformMatrices(mesh);\r\n\r\n                if (matrices) {\r\n                    effect.setMatrices(\"mBones\", matrices);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the morph targets information from the mesh to the effect.\r\n     * @param abstractMesh The mesh we are binding the information to render\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    public static BindMorphTargetParameters(abstractMesh: AbstractMesh, effect: Effect): void {\r\n        let manager = (<Mesh>abstractMesh).morphTargetManager;\r\n        if (!abstractMesh || !manager) {\r\n            return;\r\n        }\r\n\r\n        effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\r\n    }\r\n\r\n    /**\r\n     * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n     * @param defines The generated defines used in the effect\r\n     * @param effect The effect we are binding the data to\r\n     * @param scene The scene we are willing to render with logarithmic scale for\r\n     */\r\n    public static BindLogDepth(defines: any, effect: Effect, scene: Scene): void {\r\n        if (defines[\"LOGARITHMICDEPTH\"]) {\r\n            effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log((<Camera>scene.activeCamera).maxZ + 1.0) / Math.LN2));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the clip plane information from the scene to the effect.\r\n     * @param scene The scene the clip plane information are extracted from\r\n     * @param effect The effect we are binding the data to\r\n     */\r\n    public static BindClipPlane(effect: Effect, scene: Scene): void {\r\n        if (scene.clipPlane) {\r\n            let clipPlane = scene.clipPlane;\r\n            effect.setFloat4(\"vClipPlane\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (scene.clipPlane2) {\r\n            let clipPlane = scene.clipPlane2;\r\n            effect.setFloat4(\"vClipPlane2\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (scene.clipPlane3) {\r\n            let clipPlane = scene.clipPlane3;\r\n            effect.setFloat4(\"vClipPlane3\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n        if (scene.clipPlane4) {\r\n            let clipPlane = scene.clipPlane4;\r\n            effect.setFloat4(\"vClipPlane4\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n        }\r\n    }\r\n}\r\n"]}