import { Engine } from "../Engines/engine";
import { Scene } from "../scene";
import { SceneLoaderProgressEvent } from "../Loading/sceneLoader";
/**
 * Class used to help managing file picking and drag'n'drop
 */
export declare class FilesInput {
    /**
     * List of files ready to be loaded
     */
    static readonly FilesToLoad: {
        [key: string]: File;
    };
    /**
     * Callback called when a file is processed
     */
    onProcessFileCallback: (file: File, name: string, extension: string) => true;
    private _engine;
    private _currentScene;
    private _sceneLoadedCallback;
    private _progressCallback;
    private _additionalRenderLoopLogicCallback;
    private _textureLoadingCallback;
    private _startingProcessingFilesCallback;
    private _onReloadCallback;
    private _errorCallback;
    private _elementToMonitor;
    private _sceneFileToLoad;
    private _filesToLoad;
    /**
     * Creates a new FilesInput
     * @param engine defines the rendering engine
     * @param scene defines the hosting scene
     * @param sceneLoadedCallback callback called when scene is loaded
     * @param progressCallback callback called to track progress
     * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop
     * @param textureLoadingCallback callback called when a texture is loading
     * @param startingProcessingFilesCallback callback called when the system is about to process all files
     * @param onReloadCallback callback called when a reload is requested
     * @param errorCallback callback call if an error occurs
     */
    constructor(engine: Engine, scene: Scene, sceneLoadedCallback: (sceneFile: File, scene: Scene) => void, progressCallback: (progress: SceneLoaderProgressEvent) => void, additionalRenderLoopLogicCallback: () => void, textureLoadingCallback: (remaining: number) => void, startingProcessingFilesCallback: (files?: File[]) => void, onReloadCallback: (sceneFile: File) => void, errorCallback: (sceneFile: File, scene: Scene, message: string) => void);
    private _dragEnterHandler;
    private _dragOverHandler;
    private _dropHandler;
    /**
     * Calls this function to listen to drag'n'drop events on a specific DOM element
     * @param elementToMonitor defines the DOM element to track
     */
    monitorElementForDragNDrop(elementToMonitor: HTMLElement): void;
    /**
     * Release all associated resources
     */
    dispose(): void;
    private renderFunction;
    private drag;
    private drop;
    private _traverseFolder;
    private _processFiles;
    /**
     * Load files from a drop event
     * @param event defines the drop event to use as source
     */
    loadFiles(event: any): void;
    private _processReload;
    /**
     * Reload the current scene from the loaded files
     */
    reload(): void;
}
