import { FloatArray, IndicesArray, Nullable } from "../types";
import { Color4, Color3, Vector2, Vector3 } from "../Maths/math";
import { IOfflineProvider } from "../Offline/IOfflineProvider";
import { Observable } from "./observable";
import { DomManagement } from "./domManagement";
import { WebRequest } from './webRequest';
declare type Camera = import("../Cameras/camera").Camera;
declare type Engine = import("../Engines/engine").Engine;
declare type Animation = import("../Animations/animation").Animation;
/**
 * Interface for any object that can request an animation frame
 */
export interface ICustomAnimationFrameRequester {
    /**
     * This function will be called when the render loop is ready. If this is not populated, the engine's renderloop function will be called
     */
    renderFunction?: Function;
    /**
     * Called to request the next frame to render to
     * @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
     */
    requestAnimationFrame: Function;
    /**
     * You can pass this value to cancelAnimationFrame() to cancel the refresh callback request
     * @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame#Return_value
     */
    requestID?: number;
}
/**
 * Interface containing an array of animations
 */
export interface IAnimatable {
    /**
     * Array of animations
     */
    animations: Nullable<Array<Animation>>;
}
/** Interface used by value gradients (color, factor, ...) */
export interface IValueGradient {
    /**
     * Gets or sets the gradient value (between 0 and 1)
     */
    gradient: number;
}
/** Class used to store color4 gradient */
export declare class ColorGradient implements IValueGradient {
    /**
     * Gets or sets the gradient value (between 0 and 1)
     */
    gradient: number;
    /**
     * Gets or sets first associated color
     */
    color1: Color4;
    /**
     * Gets or sets second associated color
     */
    color2?: Color4;
    /**
     * Will get a color picked randomly between color1 and color2.
     * If color2 is undefined then color1 will be used
     * @param result defines the target Color4 to store the result in
     */
    getColorToRef(result: Color4): void;
}
/** Class used to store color 3 gradient */
export declare class Color3Gradient implements IValueGradient {
    /**
     * Gets or sets the gradient value (between 0 and 1)
     */
    gradient: number;
    /**
     * Gets or sets the associated color
     */
    color: Color3;
}
/** Class used to store factor gradient */
export declare class FactorGradient implements IValueGradient {
    /**
     * Gets or sets the gradient value (between 0 and 1)
     */
    gradient: number;
    /**
     * Gets or sets first associated factor
     */
    factor1: number;
    /**
     * Gets or sets second associated factor
     */
    factor2?: number;
    /**
     * Will get a number picked randomly between factor1 and factor2.
     * If factor2 is undefined then factor1 will be used
     * @returns the picked number
     */
    getFactor(): number;
}
/**
 * @ignore
 * Application error to support additional information when loading a file
 */
export declare class LoadFileError extends Error {
    /** defines the optional web request */
    request?: WebRequest | undefined;
    private static _setPrototypeOf;
    /**
     * Creates a new LoadFileError
     * @param message defines the message of the error
     * @param request defines the optional web request
     */
    constructor(message: string, 
    /** defines the optional web request */
    request?: WebRequest | undefined);
}
/**
 * Class used to define a retry strategy when error happens while loading assets
 */
export declare class RetryStrategy {
    /**
     * Function used to defines an exponential back off strategy
     * @param maxRetries defines the maximum number of retries (3 by default)
     * @param baseInterval defines the interval between retries
     * @returns the strategy function to use
     */
    static ExponentialBackoff(maxRetries?: number, baseInterval?: number): (url: string, request: WebRequest, retryIndex: number) => number;
}
/**
 * File request interface
 */
export interface IFileRequest {
    /**
     * Raised when the request is complete (success or error).
     */
    onCompleteObservable: Observable<IFileRequest>;
    /**
     * Aborts the request for a file.
     */
    abort: () => void;
}
/**
 * Class containing a set of static utilities functions
 */
export declare class Tools {
    /**
     * Gets or sets the base URL to use to load assets
     */
    static BaseUrl: string;
    /**
     * Enable/Disable Custom HTTP Request Headers globally.
     * default = false
     * @see CustomRequestHeaders
     */
    static UseCustomRequestHeaders: boolean;
    /**
     * Custom HTTP Request Headers to be sent with XMLHttpRequests
     * i.e. when loading files, where the server/service expects an Authorization header
     */
    static CustomRequestHeaders: {
        [key: string]: string;
    };
    /**
     * Gets or sets the retry strategy to apply when an error happens while loading an asset
     */
    static DefaultRetryStrategy: (url: string, request: WebRequest, retryIndex: number) => number;
    /**
     * Default behaviour for cors in the application.
     * It can be a string if the expected behavior is identical in the entire app.
     * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)
     */
    static CorsBehavior: string | ((url: string | string[]) => string);
    /**
     * Gets or sets a global variable indicating if fallback texture must be used when a texture cannot be loaded
     * @ignorenaming
     */
    static UseFallbackTexture: boolean;
    /**
     * Use this object to register external classes like custom textures or material
     * to allow the laoders to instantiate them
     */
    static RegisteredExternalClasses: {
        [key: string]: Object;
    };
    /**
     * Texture content used if a texture cannot loaded
     * @ignorenaming
     */
    static fallbackTexture: string;
    /**
     * Read the content of a byte array at a specified coordinates (taking in account wrapping)
     * @param u defines the coordinate on X axis
     * @param v defines the coordinate on Y axis
     * @param width defines the width of the source data
     * @param height defines the height of the source data
     * @param pixels defines the source byte array
     * @param color defines the output color
     */
    static FetchToRef(u: number, v: number, width: number, height: number, pixels: Uint8Array, color: Color4): void;
    /**
     * Interpolates between a and b via alpha
     * @param a The lower value (returned when alpha = 0)
     * @param b The upper value (returned when alpha = 1)
     * @param alpha The interpolation-factor
     * @return The mixed value
     */
    static Mix(a: number, b: number, alpha: number): number;
    /**
     * Tries to instantiate a new object from a given class name
     * @param className defines the class name to instantiate
     * @returns the new object or null if the system was not able to do the instantiation
     */
    static Instantiate(className: string): any;
    /**
     * Provides a slice function that will work even on IE
     * @param data defines the array to slice
     * @param start defines the start of the data (optional)
     * @param end defines the end of the data (optional)
     * @returns the new sliced array
     */
    static Slice<T>(data: T, start?: number, end?: number): T;
    /**
     * Polyfill for setImmediate
     * @param action defines the action to execute after the current execution block
     */
    static SetImmediate(action: () => void): void;
    /**
     * Function indicating if a number is an exponent of 2
     * @param value defines the value to test
     * @returns true if the value is an exponent of 2
     */
    static IsExponentOfTwo(value: number): boolean;
    private static _tmpFloatArray;
    /**
     * Returns the nearest 32-bit single precision float representation of a Number
     * @param value A Number.  If the parameter is of a different type, it will get converted
     * to a number or to NaN if it cannot be converted
     * @returns number
     */
    static FloatRound(value: number): number;
    /**
     * Find the next highest power of two.
     * @param x Number to start search from.
     * @return Next highest power of two.
     */
    static CeilingPOT(x: number): number;
    /**
     * Find the next lowest power of two.
     * @param x Number to start search from.
     * @return Next lowest power of two.
     */
    static FloorPOT(x: number): number;
    /**
     * Find the nearest power of two.
     * @param x Number to start search from.
     * @return Next nearest power of two.
     */
    static NearestPOT(x: number): number;
    /**
     * Get the closest exponent of two
     * @param value defines the value to approximate
     * @param max defines the maximum value to return
     * @param mode defines how to define the closest value
     * @returns closest exponent of two of the given value
     */
    static GetExponentOfTwo(value: number, max: number, mode?: number): number;
    /**
     * Extracts the filename from a path
     * @param path defines the path to use
     * @returns the filename
     */
    static GetFilename(path: string): string;
    /**
     * Extracts the "folder" part of a path (everything before the filename).
     * @param uri The URI to extract the info from
     * @param returnUnchangedIfNoSlash Do not touch the URI if no slashes are present
     * @returns The "folder" part of the path
     */
    static GetFolderPath(uri: string, returnUnchangedIfNoSlash?: boolean): string;
    /**
     * Extracts text content from a DOM element hierarchy
     * Back Compat only, please use DomManagement.GetDOMTextContent instead.
     */
    static GetDOMTextContent: typeof DomManagement.GetDOMTextContent;
    /**
     * Convert an angle in radians to degrees
     * @param angle defines the angle to convert
     * @returns the angle in degrees
     */
    static ToDegrees(angle: number): number;
    /**
     * Convert an angle in degrees to radians
     * @param angle defines the angle to convert
     * @returns the angle in radians
     */
    static ToRadians(angle: number): number;
    /**
     * Encode a buffer to a base64 string
     * @param buffer defines the buffer to encode
     * @returns the encoded string
     */
    static EncodeArrayBufferTobase64(buffer: ArrayBuffer): string;
    /**
     * Extracts minimum and maximum values from a list of indexed positions
     * @param positions defines the positions to use
     * @param indices defines the indices to the positions
     * @param indexStart defines the start index
     * @param indexCount defines the end index
     * @param bias defines bias value to add to the result
     * @return minimum and maximum values
     */
    static ExtractMinAndMaxIndexed(positions: FloatArray, indices: IndicesArray, indexStart: number, indexCount: number, bias?: Nullable<Vector2>): {
        minimum: Vector3;
        maximum: Vector3;
    };
    /**
     * Extracts minimum and maximum values from a list of positions
     * @param positions defines the positions to use
     * @param start defines the start index in the positions array
     * @param count defines the number of positions to handle
     * @param bias defines bias value to add to the result
     * @param stride defines the stride size to use (distance between two positions in the positions array)
     * @return minimum and maximum values
     */
    static ExtractMinAndMax(positions: FloatArray, start: number, count: number, bias?: Nullable<Vector2>, stride?: number): {
        minimum: Vector3;
        maximum: Vector3;
    };
    /**
     * Returns an array if obj is not an array
     * @param obj defines the object to evaluate as an array
     * @param allowsNullUndefined defines a boolean indicating if obj is allowed to be null or undefined
     * @returns either obj directly if obj is an array or a new array containing obj
     */
    static MakeArray(obj: any, allowsNullUndefined?: boolean): Nullable<Array<any>>;
    /**
     * Gets the pointer prefix to use
     * @returns "pointer" if touch is enabled. Else returns "mouse"
     */
    static GetPointerPrefix(): string;
    /**
     * Queue a new function into the requested animation frame pool (ie. this function will be executed byt the browser for the next frame)
     * @param func - the function to be called
     * @param requester - the object that will request the next frame. Falls back to window.
     * @returns frame number
     */
    static QueueNewFrame(func: () => void, requester?: any): number;
    /**
     * Ask the browser to promote the current element to fullscreen rendering mode
     * @param element defines the DOM element to promote
     */
    static RequestFullscreen(element: HTMLElement): void;
    /**
     * Asks the browser to exit fullscreen mode
     */
    static ExitFullscreen(): void;
    /**
     * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.
     * @param url define the url we are trying
     * @param element define the dom element where to configure the cors policy
     */
    static SetCorsBehavior(url: string | string[], element: {
        crossOrigin: string | null;
    }): void;
    /**
     * Removes unwanted characters from an url
     * @param url defines the url to clean
     * @returns the cleaned url
     */
    static CleanUrl(url: string): string;
    /**
     * Gets or sets a function used to pre-process url before using them to load assets
     */
    static PreprocessUrl: (url: string) => string;
    /**
     * Loads an image as an HTMLImageElement.
     * @param input url string, ArrayBuffer, or Blob to load
     * @param onLoad callback called when the image successfully loads
     * @param onError callback called when the image fails to load
     * @param offlineProvider offline provider for caching
     * @returns the HTMLImageElement of the loaded image
     */
    static LoadImage(input: string | ArrayBuffer | Blob, onLoad: (img: HTMLImageElement) => void, onError: (message?: string, exception?: any) => void, offlineProvider: Nullable<IOfflineProvider>): HTMLImageElement;
    /**
     * Loads a file
     * @param url url string, ArrayBuffer, or Blob to load
     * @param onSuccess callback called when the file successfully loads
     * @param onProgress callback called while file is loading (if the server supports this mode)
     * @param offlineProvider defines the offline provider for caching
     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
     * @param onError callback called when the file fails to load
     * @returns a file request object
     */
    static LoadFile(url: string, onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void, onProgress?: (data: any) => void, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean, onError?: (request?: WebRequest, exception?: any) => void): IFileRequest;
    /**
     * Load a script (identified by an url). When the url returns, the
     * content of this file is added into a new script element, attached to the DOM (body element)
     * @param scriptUrl defines the url of the script to laod
     * @param onSuccess defines the callback called when the script is loaded
     * @param onError defines the callback to call if an error occurs
     * @param scriptId defines the id of the script element
     */
    static LoadScript(scriptUrl: string, onSuccess: () => void, onError?: (message?: string, exception?: any) => void, scriptId?: string): void;
    /**
     * Load an asynchronous script (identified by an url). When the url returns, the
     * content of this file is added into a new script element, attached to the DOM (body element)
     * @param scriptUrl defines the url of the script to laod
     * @param scriptId defines the id of the script element
     * @returns a promise request object
     */
    static LoadScriptAsync(scriptUrl: string, scriptId?: string): Nullable<Promise<boolean>>;
    /**
     * Loads a file from a blob
     * @param fileToLoad defines the blob to use
     * @param callback defines the callback to call when data is loaded
     * @param progressCallback defines the callback to call during loading process
     * @returns a file request object
     */
    static ReadFileAsDataURL(fileToLoad: Blob, callback: (data: any) => void, progressCallback: (ev: ProgressEvent) => any): IFileRequest;
    /**
     * Loads a file
     * @param fileToLoad defines the file to load
     * @param callback defines the callback to call when data is loaded
     * @param progressCallBack defines the callback to call during loading process
     * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer
     * @returns a file request object
     */
    static ReadFile(fileToLoad: File, callback: (data: any) => void, progressCallBack?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean): IFileRequest;
    /**
     * Creates a data url from a given string content
     * @param content defines the content to convert
     * @returns the new data url link
     */
    static FileAsURL(content: string): string;
    /**
     * Format the given number to a specific decimal format
     * @param value defines the number to format
     * @param decimals defines the number of decimals to use
     * @returns the formatted string
     */
    static Format(value: number, decimals?: number): string;
    /**
     * Checks if a given vector is inside a specific range
     * @param v defines the vector to test
     * @param min defines the minimum range
     * @param max defines the maximum range
     */
    static CheckExtends(v: Vector3, min: Vector3, max: Vector3): void;
    /**
     * Tries to copy an object by duplicating every property
     * @param source defines the source object
     * @param destination defines the target object
     * @param doNotCopyList defines a list of properties to avoid
     * @param mustCopyList defines a list of properties to copy (even if they start with _)
     */
    static DeepCopy(source: any, destination: any, doNotCopyList?: string[], mustCopyList?: string[]): void;
    /**
     * Gets a boolean indicating if the given object has no own property
     * @param obj defines the object to test
     * @returns true if object has no own property
     */
    static IsEmpty(obj: any): boolean;
    /**
     * Checks for a matching suffix at the end of a string (for ES5 and lower)
     * @param str Source string
     * @param suffix Suffix to search for in the source string
     * @returns Boolean indicating whether the suffix was found (true) or not (false)
     */
    static EndsWith(str: string, suffix: string): boolean;
    /**
     * Function used to register events at window level
     * @param events defines the events to register
     */
    static RegisterTopRootEvents(events: {
        name: string;
        handler: Nullable<(e: FocusEvent) => any>;
    }[]): void;
    /**
     * Function used to unregister events from window level
     * @param events defines the events to unregister
     */
    static UnregisterTopRootEvents(events: {
        name: string;
        handler: Nullable<(e: FocusEvent) => any>;
    }[]): void;
    /**
     * @ignore
     */
    static _ScreenshotCanvas: HTMLCanvasElement;
    /**
     * Dumps the current bound framebuffer
     * @param width defines the rendering width
     * @param height defines the rendering height
     * @param engine defines the hosting engine
     * @param successCallback defines the callback triggered once the data are available
     * @param mimeType defines the mime type of the result
     * @param fileName defines the filename to download. If present, the result will automatically be downloaded
     */
    static DumpFramebuffer(width: number, height: number, engine: Engine, successCallback?: (data: string) => void, mimeType?: string, fileName?: string): void;
    /**
     * Converts the canvas data to blob.
     * This acts as a polyfill for browsers not supporting the to blob function.
     * @param canvas Defines the canvas to extract the data from
     * @param successCallback Defines the callback triggered once the data are available
     * @param mimeType Defines the mime type of the result
     */
    static ToBlob(canvas: HTMLCanvasElement, successCallback: (blob: Nullable<Blob>) => void, mimeType?: string): void;
    /**
     * Encodes the canvas data to base 64 or automatically download the result if filename is defined
     * @param successCallback defines the callback triggered once the data are available
     * @param mimeType defines the mime type of the result
     * @param fileName defines he filename to download. If present, the result will automatically be downloaded
     */
    static EncodeScreenshotCanvasData(successCallback?: (data: string) => void, mimeType?: string, fileName?: string): void;
    /**
     * Downloads a blob in the browser
     * @param blob defines the blob to download
     * @param fileName defines the name of the downloaded file
     */
    static Download(blob: Blob, fileName: string): void;
    /**
     * Captures a screenshot of the current rendering
     * @see http://doc.babylonjs.com/how_to/render_scene_on_a_png
     * @param engine defines the rendering engine
     * @param camera defines the source camera
     * @param size This parameter can be set to a single number or to an object with the
     * following (optional) properties: precision, width, height. If a single number is passed,
     * it will be used for both width and height. If an object is passed, the screenshot size
     * will be derived from the parameters. The precision property is a multiplier allowing
     * rendering at a higher or lower resolution
     * @param successCallback defines the callback receives a single parameter which contains the
     * screenshot as a string of base64-encoded characters. This string can be assigned to the
     * src parameter of an <img> to display it
     * @param mimeType defines the MIME type of the screenshot image (default: image/png).
     * Check your browser for supported MIME types
     */
    static CreateScreenshot(engine: Engine, camera: Camera, size: any, successCallback?: (data: string) => void, mimeType?: string): void;
    /**
     * Generates an image screenshot from the specified camera.
     * @see http://doc.babylonjs.com/how_to/render_scene_on_a_png
     * @param engine The engine to use for rendering
     * @param camera The camera to use for rendering
     * @param size This parameter can be set to a single number or to an object with the
     * following (optional) properties: precision, width, height. If a single number is passed,
     * it will be used for both width and height. If an object is passed, the screenshot size
     * will be derived from the parameters. The precision property is a multiplier allowing
     * rendering at a higher or lower resolution
     * @param successCallback The callback receives a single parameter which contains the
     * screenshot as a string of base64-encoded characters. This string can be assigned to the
     * src parameter of an <img> to display it
     * @param mimeType The MIME type of the screenshot image (default: image/png).
     * Check your browser for supported MIME types
     * @param samples Texture samples (default: 1)
     * @param antialiasing Whether antialiasing should be turned on or not (default: false)
     * @param fileName A name for for the downloaded file.
     */
    static CreateScreenshotUsingRenderTarget(engine: Engine, camera: Camera, size: any, successCallback?: (data: string) => void, mimeType?: string, samples?: number, antialiasing?: boolean, fileName?: string): void;
    /**
     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
     * Be aware Math.random() could cause collisions, but:
     * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
     * @returns a pseudo random id
     */
    static RandomId(): string;
    /**
    * Test if the given uri is a base64 string
    * @param uri The uri to test
    * @return True if the uri is a base64 string or false otherwise
    */
    static IsBase64(uri: string): boolean;
    /**
    * Decode the given base64 uri.
    * @param uri The uri to decode
    * @return The decoded base64 data.
    */
    static DecodeBase64(uri: string): ArrayBuffer;
    /**
     * Gets the absolute url.
     * @param url the input url
     * @return the absolute url
     */
    static GetAbsoluteUrl(url: string): string;
    /**
     * No log
     */
    static readonly NoneLogLevel = 0;
    /**
     * Only message logs
     */
    static readonly MessageLogLevel = 1;
    /**
     * Only warning logs
     */
    static readonly WarningLogLevel = 2;
    /**
     * Only error logs
     */
    static readonly ErrorLogLevel = 4;
    /**
     * All logs
     */
    static readonly AllLogLevel = 7;
    /**
     * Gets a value indicating the number of loading errors
     * @ignorenaming
     */
    static readonly errorsCount: number;
    /**
     * Callback called when a new log is added
     */
    static OnNewCacheEntry: (entry: string) => void;
    /**
     * Log a message to the console
     * @param message defines the message to log
     */
    static Log(message: string): void;
    /**
     * Write a warning message to the console
     * @param message defines the message to log
     */
    static Warn(message: string): void;
    /**
     * Write an error message to the console
     * @param message defines the message to log
     */
    static Error(message: string): void;
    /**
     * Gets current log cache (list of logs)
     */
    static readonly LogCache: string;
    /**
     * Clears the log cache
     */
    static ClearLogCache(): void;
    /**
     * Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)
     */
    static LogLevels: number;
    /**
     * Checks if the loaded document was accessed via `file:`-Protocol.
     * @returns boolean
     */
    static IsFileURL(): boolean;
    /**
     * Checks if the window object exists
     * Back Compat only, please use DomManagement.IsWindowObjectExist instead.
     */
    static IsWindowObjectExist: typeof DomManagement.IsWindowObjectExist;
    /**
     * No performance log
     */
    static readonly PerformanceNoneLogLevel = 0;
    /**
     * Use user marks to log performance
     */
    static readonly PerformanceUserMarkLogLevel = 1;
    /**
     * Log performance to the console
     */
    static readonly PerformanceConsoleLogLevel = 2;
    private static _performance;
    /**
     * Sets the current performance log level
     */
    static PerformanceLogLevel: number;
    private static _StartPerformanceCounterDisabled;
    private static _EndPerformanceCounterDisabled;
    private static _StartUserMark;
    private static _EndUserMark;
    private static _StartPerformanceConsole;
    private static _EndPerformanceConsole;
    /**
     * Starts a performance counter
     */
    static StartPerformanceCounter: (counterName: string, condition?: boolean) => void;
    /**
     * Ends a specific performance coutner
     */
    static EndPerformanceCounter: (counterName: string, condition?: boolean) => void;
    /**
     * Gets either window.performance.now() if supported or Date.now() else
     */
    static readonly Now: number;
    /**
     * This method will return the name of the class used to create the instance of the given object.
     * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator.
     * @param object the object to get the class name from
     * @param isType defines if the object is actually a type
     * @returns the name of the class, will be "object" for a custom data type not using the @className decorator
     */
    static GetClassName(object: any, isType?: boolean): string;
    /**
     * Gets the first element of an array satisfying a given predicate
     * @param array defines the array to browse
     * @param predicate defines the predicate to use
     * @returns null if not found or the element
     */
    static First<T>(array: Array<T>, predicate: (item: T) => boolean): Nullable<T>;
    /**
     * This method will return the name of the full name of the class, including its owning module (if any).
     * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator or implementing a method getClassName():string (in which case the module won't be specified).
     * @param object the object to get the class name from
     * @param isType defines if the object is actually a type
     * @return a string that can have two forms: "moduleName.className" if module was specified when the class' Name was registered or "className" if there was not module specified.
     * @ignorenaming
     */
    static getFullClassName(object: any, isType?: boolean): Nullable<string>;
    /**
     * Returns a promise that resolves after the given amount of time.
     * @param delay Number of milliseconds to delay
     * @returns Promise that resolves after the given amount of time
     */
    static DelayAsync(delay: number): Promise<void>;
    /**
     * Gets the current gradient from an array of IValueGradient
     * @param ratio defines the current ratio to get
     * @param gradients defines the array of IValueGradient
     * @param updateFunc defines the callback function used to get the final value from the selected gradients
     */
    static GetCurrentGradient(ratio: number, gradients: IValueGradient[], updateFunc: (current: IValueGradient, next: IValueGradient, scale: number) => void): void;
}
/**
 * This class is used to track a performance counter which is number based.
 * The user has access to many properties which give statistics of different nature.
 *
 * The implementer can track two kinds of Performance Counter: time and count.
 * For time you can optionally call fetchNewFrame() to notify the start of a new frame to monitor, then call beginMonitoring() to start and endMonitoring() to record the lapsed time. endMonitoring takes a newFrame parameter for you to specify if the monitored time should be set for a new frame or accumulated to the current frame being monitored.
 * For count you first have to call fetchNewFrame() to notify the start of a new frame to monitor, then call addCount() how many time required to increment the count value you monitor.
 */
export declare class PerfCounter {
    /**
     * Gets or sets a global boolean to turn on and off all the counters
     */
    static Enabled: boolean;
    /**
     * Returns the smallest value ever
     */
    readonly min: number;
    /**
     * Returns the biggest value ever
     */
    readonly max: number;
    /**
     * Returns the average value since the performance counter is running
     */
    readonly average: number;
    /**
     * Returns the average value of the last second the counter was monitored
     */
    readonly lastSecAverage: number;
    /**
     * Returns the current value
     */
    readonly current: number;
    /**
     * Gets the accumulated total
     */
    readonly total: number;
    /**
     * Gets the total value count
     */
    readonly count: number;
    /**
     * Creates a new counter
     */
    constructor();
    /**
     * Call this method to start monitoring a new frame.
     * This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the start of the frame, then beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.
     */
    fetchNewFrame(): void;
    /**
     * Call this method to monitor a count of something (e.g. mesh drawn in viewport count)
     * @param newCount the count value to add to the monitored count
     * @param fetchResult true when it's the last time in the frame you add to the counter and you wish to update the statistics properties (min/max/average), false if you only want to update statistics.
     */
    addCount(newCount: number, fetchResult: boolean): void;
    /**
     * Start monitoring this performance counter
     */
    beginMonitoring(): void;
    /**
     * Compute the time lapsed since the previous beginMonitoring() call.
     * @param newFrame true by default to fetch the result and monitor a new frame, if false the time monitored will be added to the current frame counter
     */
    endMonitoring(newFrame?: boolean): void;
    private _fetchResult;
    private _startMonitoringTime;
    private _min;
    private _max;
    private _average;
    private _current;
    private _totalValueCount;
    private _totalAccumulated;
    private _lastSecAverage;
    private _lastSecAccumulated;
    private _lastSecTime;
    private _lastSecValueCount;
}
/**
 * Use this className as a decorator on a given class definition to add it a name and optionally its module.
 * You can then use the Tools.getClassName(obj) on an instance to retrieve its class name.
 * This method is the only way to get it done in all cases, even if the .js file declaring the class is minified
 * @param name The name of the class, case should be preserved
 * @param module The name of the Module hosting the class, optional, but strongly recommended to specify if possible. Case should be preserved.
 */
export declare function className(name: string, module?: string): (target: Object) => void;
/**
 * An implementation of a loop for asynchronous functions.
 */
export declare class AsyncLoop {
    /**
     * Defines the number of iterations for the loop
     */
    iterations: number;
    /**
     * Defines the current index of the loop.
     */
    index: number;
    private _done;
    private _fn;
    private _successCallback;
    /**
     * Constructor.
     * @param iterations the number of iterations.
     * @param func the function to run each iteration
     * @param successCallback the callback that will be called upon succesful execution
     * @param offset starting offset.
     */
    constructor(
    /**
     * Defines the number of iterations for the loop
     */
    iterations: number, func: (asyncLoop: AsyncLoop) => void, successCallback: () => void, offset?: number);
    /**
     * Execute the next iteration. Must be called after the last iteration was finished.
     */
    executeNext(): void;
    /**
     * Break the loop and run the success callback.
     */
    breakLoop(): void;
    /**
     * Create and run an async loop.
     * @param iterations the number of iterations.
     * @param fn the function to run each iteration
     * @param successCallback the callback that will be called upon succesful execution
     * @param offset starting offset.
     * @returns the created async loop object
     */
    static Run(iterations: number, fn: (asyncLoop: AsyncLoop) => void, successCallback: () => void, offset?: number): AsyncLoop;
    /**
     * A for-loop that will run a given number of iterations synchronous and the rest async.
     * @param iterations total number of iterations
     * @param syncedIterations number of synchronous iterations in each async iteration.
     * @param fn the function to call each iteration.
     * @param callback a success call back that will be called when iterating stops.
     * @param breakFunction a break condition (optional)
     * @param timeout timeout settings for the setTimeout function. default - 0.
     * @returns the created async loop object
     */
    static SyncAsyncForLoop(iterations: number, syncedIterations: number, fn: (iteration: number) => void, callback: () => void, breakFunction?: () => boolean, timeout?: number): AsyncLoop;
}
export {};
