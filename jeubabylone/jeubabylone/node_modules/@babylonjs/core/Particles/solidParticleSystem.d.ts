import { Vector3 } from "../Maths/math";
import { Mesh } from "../Meshes/mesh";
import { Scene, IDisposable } from "../scene";
import { DepthSortedParticle, SolidParticle } from "./solidParticle";
/**
 * The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.
 *As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.

 * The SPS is also a particle system. It provides some methods to manage the particles.
 * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.
 *
 * Full documentation here : http://doc.babylonjs.com/overviews/Solid_Particle_System
 */
export declare class SolidParticleSystem implements IDisposable {
    /**
     *  The SPS array of Solid Particle objects. Just access each particle as with any classic array.
     *  Example : var p = SPS.particles[i];
     */
    particles: SolidParticle[];
    /**
     * The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.
     */
    nbParticles: number;
    /**
     * If the particles must ever face the camera (default false). Useful for planar particles.
     */
    billboard: boolean;
    /**
     * Recompute normals when adding a shape
     */
    recomputeNormals: boolean;
    /**
     * This a counter ofr your own usage. It's not set by any SPS functions.
     */
    counter: number;
    /**
     * The SPS name. This name is also given to the underlying mesh.
     */
    name: string;
    /**
     * The SPS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are avalaible.
     */
    mesh: Mesh;
    /**
     * This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.
     * Please read : http://doc.babylonjs.com/overviews/Solid_Particle_System#garbage-collector-concerns
     */
    vars: any;
    /**
     * This array is populated when the SPS is set as 'pickable'.
     * Each key of this array is a `faceId` value that you can get from a pickResult object.
     * Each element of this array is an object `{idx: int, faceId: int}`.
     * `idx` is the picked particle index in the `SPS.particles` array
     * `faceId` is the picked face index counted within this particle.
     * Please read : http://doc.babylonjs.com/overviews/Solid_Particle_System#pickable-particles
     */
    pickedParticles: {
        idx: number;
        faceId: number;
    }[];
    /**
     * This array is populated when `enableDepthSort` is set to true.
     * Each element of this array is an instance of the class DepthSortedParticle.
     */
    depthSortedParticles: DepthSortedParticle[];
    /**
     * If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)
     * @hidden
     */
    _bSphereOnly: boolean;
    /**
     * A number to multiply the boundind sphere radius by in order to reduce it for instance. (Internal use only)
     * @hidden
     */
    _bSphereRadiusFactor: number;
    private _scene;
    private _positions;
    private _indices;
    private _normals;
    private _colors;
    private _uvs;
    private _indices32;
    private _positions32;
    private _normals32;
    private _fixedNormal32;
    private _colors32;
    private _uvs32;
    private _index;
    private _updatable;
    private _pickable;
    private _isVisibilityBoxLocked;
    private _alwaysVisible;
    private _depthSort;
    private _shapeCounter;
    private _copy;
    private _color;
    private _computeParticleColor;
    private _computeParticleTexture;
    private _computeParticleRotation;
    private _computeParticleVertex;
    private _computeBoundingBox;
    private _depthSortParticles;
    private _camera;
    private _mustUnrotateFixedNormals;
    private _particlesIntersect;
    private _needs32Bits;
    /**
     * Creates a SPS (Solid Particle System) object.
     * @param name (String) is the SPS name, this will be the underlying mesh name.
     * @param scene (Scene) is the scene in which the SPS is added.
     * @param options defines the options of the sps e.g.
     * * updatable (optional boolean, default true) : if the SPS must be updatable or immutable.
     * * isPickable (optional boolean, default false) : if the solid particles must be pickable.
     * * enableDepthSort (optional boolean, default false) : if the solid particles must be sorted in the geometry according to their distance to the camera.
     * * particleIntersection (optional boolean, default false) : if the solid particle intersections must be computed.
     * * boundingSphereOnly (optional boolean, default false) : if the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster).
     * * bSphereRadiusFactor (optional float, default 1.0) : a number to multiply the boundind sphere radius by in order to reduce it for instance.
     * @example bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.
     */
    constructor(name: string, scene: Scene, options?: {
        updatable?: boolean;
        isPickable?: boolean;
        enableDepthSort?: boolean;
        particleIntersection?: boolean;
        boundingSphereOnly?: boolean;
        bSphereRadiusFactor?: number;
    });
    /**
     * Builds the SPS underlying mesh. Returns a standard Mesh.
     * If no model shape was added to the SPS, the returned mesh is just a single triangular plane.
     * @returns the created mesh
     */
    buildMesh(): Mesh;
    /**
     * Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.
     * These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.
     * Thus the particles generated from `digest()` have their property `position` set yet.
     * @param mesh ( Mesh ) is the mesh to be digested
     * @param options {facetNb} (optional integer, default 1) is the number of mesh facets per particle, this parameter is overriden by the parameter `number` if any
     * {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets
     * {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets
     * @returns the current SPS
     */
    digest(mesh: Mesh, options?: {
        facetNb?: number;
        number?: number;
        delta?: number;
    }): SolidParticleSystem;
    private _unrotateFixedNormals;
    private _resetCopy;
    private _meshBuilder;
    private _posToShape;
    private _uvsToShapeUV;
    private _addParticle;
    /**
     * Adds some particles to the SPS from the model shape. Returns the shape id.
     * Please read the doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#create-an-immutable-sps
     * @param mesh is any Mesh object that will be used as a model for the solid particles.
     * @param nb (positive integer) the number of particles to be created from this model
     * @param options {positionFunction} is an optional javascript function to called for each particle on SPS creation.
     * {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation
     * @returns the number of shapes in the system
     */
    addShape(mesh: Mesh, nb: number, options?: {
        positionFunction?: any;
        vertexFunction?: any;
    }): number;
    private _rebuildParticle;
    /**
     * Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.
     * @returns the SPS.
     */
    rebuildMesh(): SolidParticleSystem;
    /**
     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.
     *  This method calls `updateParticle()` for each particle of the SPS.
     *  For an animated SPS, it is usually called within the render loop.
     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_
     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_
     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_
     * @returns the SPS.
     */
    setParticles(start?: number, end?: number, update?: boolean): SolidParticleSystem;
    /**
    * Disposes the SPS.
    */
    dispose(): void;
    /**
     * Visibilty helper : Recomputes the visible size according to the mesh bounding box
     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
     * @returns the SPS.
     */
    refreshVisibleSize(): SolidParticleSystem;
    /**
     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.
     * @param size the size (float) of the visibility box
     * note : this doesn't lock the SPS mesh bounding box.
     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
     */
    setVisibilityBox(size: number): void;
    /**
     * Gets whether the SPS as always visible or not
     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
     */
    /**
    * Sets the SPS as always visible or not
    * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
    */
    isAlwaysVisible: boolean;
    /**
     * Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
     */
    /**
    * Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
    * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
    */
    isVisibilityBoxLocked: boolean;
    /**
     * Tells to `setParticles()` to compute the particle rotations or not.
     * Default value : true. The SPS is faster when it's set to false.
     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
     */
    /**
    * Gets if `setParticles()` computes the particle rotations or not.
    * Default value : true. The SPS is faster when it's set to false.
    * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
    */
    computeParticleRotation: boolean;
    /**
     * Tells to `setParticles()` to compute the particle colors or not.
     * Default value : true. The SPS is faster when it's set to false.
     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
     */
    /**
    * Gets if `setParticles()` computes the particle colors or not.
    * Default value : true. The SPS is faster when it's set to false.
    * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
    */
    computeParticleColor: boolean;
    /**
    * Gets if `setParticles()` computes the particle textures or not.
    * Default value : true. The SPS is faster when it's set to false.
    * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.
    */
    computeParticleTexture: boolean;
    /**
     * Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.
     * Default value : false. The SPS is faster when it's set to false.
     * Note : the particle custom vertex positions aren't stored values.
     */
    /**
    * Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.
    * Default value : false. The SPS is faster when it's set to false.
    * Note : the particle custom vertex positions aren't stored values.
    */
    computeParticleVertex: boolean;
    /**
     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.
     */
    /**
    * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.
    */
    computeBoundingBox: boolean;
    /**
     * Tells to `setParticles()` to sort or not the distance between each particle and the camera.
     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.
     * Default : `true`
     */
    /**
    * Gets if `setParticles()` sorts or not the distance between each particle and the camera.
    * Skipped when `enableDepthSort` is set to `false` (default) at construction time.
    * Default : `true`
    */
    depthSortParticles: boolean;
    /**
     * This function does nothing. It may be overwritten to set all the particle first values.
     * The SPS doesn't call this function, you may have to call it by your own.
     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management
     */
    initParticles(): void;
    /**
     * This function does nothing. It may be overwritten to recycle a particle.
     * The SPS doesn't call this function, you may have to call it by your own.
     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management
     * @param particle The particle to recycle
     * @returns the recycled particle
     */
    recycleParticle(particle: SolidParticle): SolidParticle;
    /**
     * Updates a particle : this function should  be overwritten by the user.
     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.
     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management
     * @example : just set a particle position or velocity and recycle conditions
     * @param particle The particle to update
     * @returns the updated particle
     */
    updateParticle(particle: SolidParticle): SolidParticle;
    /**
     * Updates a vertex of a particle : it can be overwritten by the user.
     * This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.
     * @param particle the current particle
     * @param vertex the current index of the current particle
     * @param pt the index of the current vertex in the particle shape
     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#update-each-particle-shape
     * @example : just set a vertex particle position
     * @returns the updated vertex
     */
    updateParticleVertex(particle: SolidParticle, vertex: Vector3, pt: number): Vector3;
    /**
     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.
     * This does nothing and may be overwritten by the user.
     * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
     * @param update the boolean update value actually passed to setParticles()
     */
    beforeUpdateParticles(start?: number, stop?: number, update?: boolean): void;
    /**
     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.
     * This will be passed three parameters.
     * This does nothing and may be overwritten by the user.
     * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()
     * @param update the boolean update value actually passed to setParticles()
     */
    afterUpdateParticles(start?: number, stop?: number, update?: boolean): void;
}
