{"version":3,"file":"solidParticleSystem.js","sourceRoot":"","sources":["../../../sourceES6/core/Particles/solidParticleSystem.ts"],"names":[],"mappings":"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AS,CAAC,CAAC,CAAC;wBACpC,sBAAsB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;wBACvK,sBAAsB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;wBACvK,sBAAsB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;wBACvK,sBAAsB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;wBACvK,sBAAsB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;wBACvK,sBAAsB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,GAAG,eAAe,CAAC,CAAC,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC;wBACvK,sBAAsB,CAAC,CAAC,CAAC,GAAG,eAAe,CAA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","sourcesContent":["import { Nullable, IndicesArray, FloatArray } from \"../types\";\r\nimport { Color4, Vector3, Matrix, Tmp, Quaternion, Axis } from \"../Maths/math\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { DiscBuilder } from \"../Meshes/Builders/discBuilder\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Scene, IDisposable } from \"../scene\";\r\nimport { DepthSortedParticle, SolidParticle, ModelShape } from \"./solidParticle\";\r\nimport { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\n\r\nconst depthSortFunction = (p1: DepthSortedParticle, p2: DepthSortedParticle) => p2.sqDistance - p1.sqDistance;\r\n\r\n/**\r\n * The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.\r\n *As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\r\n\r\n * The SPS is also a particle system. It provides some methods to manage the particles.\r\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\r\n *\r\n * Full documentation here : http://doc.babylonjs.com/overviews/Solid_Particle_System\r\n */\r\nexport class SolidParticleSystem implements IDisposable {\r\n    /**\r\n     *  The SPS array of Solid Particle objects. Just access each particle as with any classic array.\r\n     *  Example : var p = SPS.particles[i];\r\n     */\r\n    public particles: SolidParticle[] = new Array<SolidParticle>();\r\n    /**\r\n     * The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.\r\n     */\r\n    public nbParticles: number = 0;\r\n    /**\r\n     * If the particles must ever face the camera (default false). Useful for planar particles.\r\n     */\r\n    public billboard: boolean = false;\r\n    /**\r\n     * Recompute normals when adding a shape\r\n     */\r\n    public recomputeNormals: boolean = true;\r\n    /**\r\n     * This a counter ofr your own usage. It's not set by any SPS functions.\r\n     */\r\n    public counter: number = 0;\r\n    /**\r\n     * The SPS name. This name is also given to the underlying mesh.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * The SPS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are avalaible.\r\n     */\r\n    public mesh: Mesh;\r\n    /**\r\n     * This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.\r\n     * Please read : http://doc.babylonjs.com/overviews/Solid_Particle_System#garbage-collector-concerns\r\n     */\r\n    public vars: any = {};\r\n    /**\r\n     * This array is populated when the SPS is set as 'pickable'.\r\n     * Each key of this array is a `faceId` value that you can get from a pickResult object.\r\n     * Each element of this array is an object `{idx: int, faceId: int}`.\r\n     * `idx` is the picked particle index in the `SPS.particles` array\r\n     * `faceId` is the picked face index counted within this particle.\r\n     * Please read : http://doc.babylonjs.com/overviews/Solid_Particle_System#pickable-particles\r\n     */\r\n    public pickedParticles: { idx: number; faceId: number }[];\r\n    /**\r\n     * This array is populated when `enableDepthSort` is set to true.\r\n     * Each element of this array is an instance of the class DepthSortedParticle.\r\n     */\r\n    public depthSortedParticles: DepthSortedParticle[];\r\n\r\n    /**\r\n     * If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)\r\n     * @hidden\r\n     */\r\n    public _bSphereOnly: boolean = false;\r\n    /**\r\n     * A number to multiply the boundind sphere radius by in order to reduce it for instance. (Internal use only)\r\n     * @hidden\r\n     */\r\n    public _bSphereRadiusFactor: number = 1.0;\r\n\r\n    private _scene: Scene;\r\n    private _positions: number[] = new Array<number>();\r\n    private _indices: number[] = new Array<number>();\r\n    private _normals: number[] = new Array<number>();\r\n    private _colors: number[] = new Array<number>();\r\n    private _uvs: number[] = new Array<number>();\r\n    private _indices32: IndicesArray;           // used as depth sorted array if depth sort enabled, else used as typed indices\r\n    private _positions32: Float32Array;         // updated positions for the VBO\r\n    private _normals32: Float32Array;           // updated normals for the VBO\r\n    private _fixedNormal32: Float32Array;       // initial normal references\r\n    private _colors32: Float32Array;\r\n    private _uvs32: Float32Array;\r\n    private _index: number = 0;  // indices index\r\n    private _updatable: boolean = true;\r\n    private _pickable: boolean = false;\r\n    private _isVisibilityBoxLocked = false;\r\n    private _alwaysVisible: boolean = false;\r\n    private _depthSort: boolean = false;\r\n    private _shapeCounter: number = 0;\r\n    private _copy: SolidParticle = new SolidParticle(0, 0, 0, null, 0, 0, this);\r\n    private _color: Color4 = new Color4(0, 0, 0, 0);\r\n    private _computeParticleColor: boolean = true;\r\n    private _computeParticleTexture: boolean = true;\r\n    private _computeParticleRotation: boolean = true;\r\n    private _computeParticleVertex: boolean = false;\r\n    private _computeBoundingBox: boolean = false;\r\n    private _depthSortParticles: boolean = true;\r\n    private _camera: TargetCamera;\r\n    private _mustUnrotateFixedNormals = false;\r\n    private _particlesIntersect: boolean = false;\r\n    private _needs32Bits: boolean = false;\r\n\r\n    /**\r\n     * Creates a SPS (Solid Particle System) object.\r\n     * @param name (String) is the SPS name, this will be the underlying mesh name.\r\n     * @param scene (Scene) is the scene in which the SPS is added.\r\n     * @param options defines the options of the sps e.g.\r\n     * * updatable (optional boolean, default true) : if the SPS must be updatable or immutable.\r\n     * * isPickable (optional boolean, default false) : if the solid particles must be pickable.\r\n     * * enableDepthSort (optional boolean, default false) : if the solid particles must be sorted in the geometry according to their distance to the camera.\r\n     * * particleIntersection (optional boolean, default false) : if the solid particle intersections must be computed.\r\n     * * boundingSphereOnly (optional boolean, default false) : if the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster).\r\n     * * bSphereRadiusFactor (optional float, default 1.0) : a number to multiply the boundind sphere radius by in order to reduce it for instance.\r\n     * @example bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.\r\n     */\r\n    constructor(name: string, scene: Scene, options?: { updatable?: boolean; isPickable?: boolean; enableDepthSort?: boolean; particleIntersection?: boolean; boundingSphereOnly?: boolean; bSphereRadiusFactor?: number }) {\r\n        this.name = name;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this._camera = <TargetCamera>scene.activeCamera;\r\n        this._pickable = options ? <boolean>options.isPickable : false;\r\n        this._depthSort = options ? <boolean>options.enableDepthSort : false;\r\n        this._particlesIntersect = options ? <boolean>options.particleIntersection : false;\r\n        this._bSphereOnly = options ? <boolean>options.boundingSphereOnly : false;\r\n        this._bSphereRadiusFactor = (options && options.bSphereRadiusFactor) ? options.bSphereRadiusFactor : 1.0;\r\n        if (options && options.updatable !== undefined) {\r\n            this._updatable = options.updatable;\r\n        } else {\r\n            this._updatable = true;\r\n        }\r\n        if (this._pickable) {\r\n            this.pickedParticles = [];\r\n        }\r\n        if (this._depthSort) {\r\n            this.depthSortedParticles = [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds the SPS underlying mesh. Returns a standard Mesh.\r\n     * If no model shape was added to the SPS, the returned mesh is just a single triangular plane.\r\n     * @returns the created mesh\r\n     */\r\n    public buildMesh(): Mesh {\r\n        if (this.nbParticles === 0) {\r\n            var triangle = DiscBuilder.CreateDisc(\"\", { radius: 1, tessellation: 3 }, this._scene);\r\n            this.addShape(triangle, 1);\r\n            triangle.dispose();\r\n        }\r\n        this._indices32 = (this._needs32Bits) ? new Uint32Array(this._indices) : new Uint16Array(this._indices);\r\n        this._positions32 = new Float32Array(this._positions);\r\n        this._uvs32 = new Float32Array(this._uvs);\r\n        this._colors32 = new Float32Array(this._colors);\r\n        if (this.recomputeNormals) {\r\n            VertexData.ComputeNormals(this._positions32, this._indices32, this._normals);\r\n        }\r\n        this._normals32 = new Float32Array(this._normals);\r\n        this._fixedNormal32 = new Float32Array(this._normals);\r\n        if (this._mustUnrotateFixedNormals) {  // the particles could be created already rotated in the mesh with a positionFunction\r\n            this._unrotateFixedNormals();\r\n        }\r\n\r\n        var vertexData = new VertexData();\r\n        vertexData.indices = (this._depthSort) ? this._indices : this._indices32;\r\n        vertexData.set(this._positions32, VertexBuffer.PositionKind);\r\n        vertexData.set(this._normals32, VertexBuffer.NormalKind);\r\n\r\n        if (this._uvs32.length > 0) {\r\n            vertexData.set(this._uvs32, VertexBuffer.UVKind);\r\n        }\r\n        if (this._colors32.length > 0) {\r\n            vertexData.set(this._colors32, VertexBuffer.ColorKind);\r\n        }\r\n        var mesh = new Mesh(this.name, this._scene);\r\n        vertexData.applyToMesh(mesh, this._updatable);\r\n        this.mesh = mesh;\r\n        this.mesh.isPickable = this._pickable;\r\n\r\n        // free memory\r\n        if (!this._depthSort) {\r\n            (<any>this._indices) = null;\r\n        }\r\n        (<any>this._positions) = null;\r\n        (<any>this._normals) = null;\r\n        (<any>this._uvs) = null;\r\n        (<any>this._colors) = null;\r\n\r\n        if (!this._updatable) {\r\n            this.particles.length = 0;\r\n        }\r\n\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.\r\n     * These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.\r\n     * Thus the particles generated from `digest()` have their property `position` set yet.\r\n     * @param mesh ( Mesh ) is the mesh to be digested\r\n     * @param options {facetNb} (optional integer, default 1) is the number of mesh facets per particle, this parameter is overriden by the parameter `number` if any\r\n     * {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets\r\n     * {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets\r\n     * @returns the current SPS\r\n     */\r\n    public digest(mesh: Mesh, options?: { facetNb?: number; number?: number; delta?: number }): SolidParticleSystem {\r\n        var size: number = (options && options.facetNb) || 1;\r\n        var number: number = (options && options.number) || 0;\r\n        var delta: number = (options && options.delta) || 0;\r\n        var meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        var meshInd = <IndicesArray>mesh.getIndices();\r\n        var meshUV = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind);\r\n        var meshCol = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n        var meshNor = <FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind);\r\n\r\n        var f: number = 0;                              // facet counter\r\n        var totalFacets: number = meshInd.length / 3;   // a facet is a triangle, so 3 indices\r\n        // compute size from number\r\n        if (number) {\r\n            number = (number > totalFacets) ? totalFacets : number;\r\n            size = Math.round(totalFacets / number);\r\n            delta = 0;\r\n        } else {\r\n            size = (size > totalFacets) ? totalFacets : size;\r\n        }\r\n\r\n        var facetPos: number[] = [];      // submesh positions\r\n        var facetInd: number[] = [];      // submesh indices\r\n        var facetUV: number[] = [];       // submesh UV\r\n        var facetCol: number[] = [];      // submesh colors\r\n        var barycenter: Vector3 = Vector3.Zero();\r\n        var sizeO: number = size;\r\n\r\n        while (f < totalFacets) {\r\n            size = sizeO + Math.floor((1 + delta) * Math.random());\r\n            if (f > totalFacets - size) {\r\n                size = totalFacets - f;\r\n            }\r\n            // reset temp arrays\r\n            facetPos.length = 0;\r\n            facetInd.length = 0;\r\n            facetUV.length = 0;\r\n            facetCol.length = 0;\r\n\r\n            // iterate over \"size\" facets\r\n            var fi: number = 0;\r\n            for (var j = f * 3; j < (f + size) * 3; j++) {\r\n                facetInd.push(fi);\r\n                var i: number = meshInd[j];\r\n                facetPos.push(meshPos[i * 3], meshPos[i * 3 + 1], meshPos[i * 3 + 2]);\r\n                if (meshUV) {\r\n                    facetUV.push(meshUV[i * 2], meshUV[i * 2 + 1]);\r\n                }\r\n                if (meshCol) {\r\n                    facetCol.push(meshCol[i * 4], meshCol[i * 4 + 1], meshCol[i * 4 + 2], meshCol[i * 4 + 3]);\r\n                }\r\n                fi++;\r\n            }\r\n\r\n            // create a model shape for each single particle\r\n            var idx: number = this.nbParticles;\r\n            var shape: Vector3[] = this._posToShape(facetPos);\r\n            var shapeUV: number[] = this._uvsToShapeUV(facetUV);\r\n\r\n            // compute the barycenter of the shape\r\n            var v: number;\r\n            for (v = 0; v < shape.length; v++) {\r\n                barycenter.addInPlace(shape[v]);\r\n            }\r\n            barycenter.scaleInPlace(1 / shape.length);\r\n\r\n            // shift the shape from its barycenter to the origin\r\n            for (v = 0; v < shape.length; v++) {\r\n                shape[v].subtractInPlace(barycenter);\r\n            }\r\n            var bInfo;\r\n            if (this._particlesIntersect) {\r\n                bInfo = new BoundingInfo(barycenter, barycenter);\r\n            }\r\n            var modelShape = new ModelShape(this._shapeCounter, shape, size * 3, shapeUV, null, null);\r\n\r\n            // add the particle in the SPS\r\n            var currentPos = this._positions.length;\r\n            var currentInd = this._indices.length;\r\n            this._meshBuilder(this._index, shape, this._positions, facetInd, this._indices, facetUV, this._uvs, facetCol, this._colors, meshNor, this._normals, idx, 0, null);\r\n            this._addParticle(idx, currentPos, currentInd, modelShape, this._shapeCounter, 0, bInfo);\r\n            // initialize the particle position\r\n            this.particles[this.nbParticles].position.addInPlace(barycenter);\r\n\r\n            this._index += shape.length;\r\n            idx++;\r\n            this.nbParticles++;\r\n            this._shapeCounter++;\r\n            f += size;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // unrotate the fixed normals in case the mesh was built with pre-rotated particles, ex : use of positionFunction in addShape()\r\n    private _unrotateFixedNormals() {\r\n        var index = 0;\r\n        var idx = 0;\r\n        const tmpNormal = Tmp.Vector3[0];\r\n        const quaternion = Tmp.Quaternion[0];\r\n        const invertedRotMatrix = Tmp.Matrix[0];\r\n        for (var p = 0; p < this.particles.length; p++) {\r\n            const particle = this.particles[p];\r\n            const shape = particle._model._shape;\r\n\r\n            // computing the inverse of the rotation matrix from the quaternion\r\n            // is equivalent to computing the matrix of the inverse quaternion, i.e of the conjugate quaternion\r\n            if (particle.rotationQuaternion) {\r\n                particle.rotationQuaternion.conjugateToRef(quaternion);\r\n            }\r\n            else {\r\n                const rotation = particle.rotation;\r\n                Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\r\n                quaternion.conjugateInPlace();\r\n            }\r\n            quaternion.toRotationMatrix(invertedRotMatrix);\r\n\r\n            for (var pt = 0; pt < shape.length; pt++) {\r\n                idx = index + pt * 3;\r\n                Vector3.TransformNormalFromFloatsToRef(this._normals32[idx], this._normals32[idx + 1], this._normals32[idx + 2], invertedRotMatrix, tmpNormal);\r\n                tmpNormal.toArray(this._fixedNormal32, idx);\r\n            }\r\n            index = idx + 3;\r\n        }\r\n    }\r\n\r\n    //reset copy\r\n    private _resetCopy() {\r\n        const copy = this._copy;\r\n        copy.position.setAll(0);\r\n        copy.rotation.setAll(0);\r\n        copy.rotationQuaternion = null;\r\n        copy.scaling.setAll(1);\r\n        copy.uvs.copyFromFloats(0.0, 0.0, 1.0, 1.0);\r\n        copy.color = null;\r\n        copy.translateFromPivot = false;\r\n    }\r\n\r\n    // _meshBuilder : inserts the shape model in the global SPS mesh\r\n    private _meshBuilder(p: number, shape: Vector3[], positions: number[], meshInd: IndicesArray, indices: number[], meshUV: number[] | Float32Array, uvs: number[], meshCol: number[] | Float32Array, colors: number[], meshNor: number[] | Float32Array, normals: number[], idx: number, idxInShape: number, options: any): SolidParticle {\r\n        var i;\r\n        var u = 0;\r\n        var c = 0;\r\n        var n = 0;\r\n\r\n        this._resetCopy();\r\n        const copy = this._copy;\r\n        if (options && options.positionFunction) {        // call to custom positionFunction\r\n            options.positionFunction(copy, idx, idxInShape);\r\n            this._mustUnrotateFixedNormals = true;\r\n        }\r\n\r\n        const rotMatrix = Tmp.Matrix[0];\r\n        const tmpVertex = Tmp.Vector3[0];\r\n        const tmpRotated = Tmp.Vector3[1];\r\n        const pivotBackTranslation = Tmp.Vector3[2];\r\n        const scaledPivot = Tmp.Vector3[3];\r\n        copy.getRotationMatrix(rotMatrix);\r\n\r\n        copy.pivot.multiplyToRef(copy.scaling, scaledPivot);\r\n\r\n        if (copy.translateFromPivot) {\r\n            pivotBackTranslation.setAll(0.0);\r\n        }\r\n        else {\r\n            pivotBackTranslation.copyFrom(scaledPivot);\r\n        }\r\n\r\n        for (i = 0; i < shape.length; i++) {\r\n            tmpVertex.copyFrom(shape[i]);\r\n            if (options && options.vertexFunction) {\r\n                options.vertexFunction(copy, tmpVertex, i);\r\n            }\r\n\r\n            tmpVertex.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\r\n            Vector3.TransformCoordinatesToRef(tmpVertex, rotMatrix, tmpRotated);\r\n            tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position);\r\n            positions.push(tmpRotated.x, tmpRotated.y, tmpRotated.z);\r\n            if (meshUV) {\r\n                const copyUvs = copy.uvs;\r\n                uvs.push((copyUvs.z - copyUvs.x) * meshUV[u] + copyUvs.x, (copyUvs.w - copyUvs.y) * meshUV[u + 1] + copyUvs.y);\r\n                u += 2;\r\n            }\r\n\r\n            if (copy.color) {\r\n                this._color = copy.color;\r\n            } else {\r\n                const color = this._color;\r\n                if (meshCol && meshCol[c] !== undefined) {\r\n                    color.r = meshCol[c];\r\n                    color.g = meshCol[c + 1];\r\n                    color.b = meshCol[c + 2];\r\n                    color.a = meshCol[c + 3];\r\n                } else {\r\n                    color.r = 1.0;\r\n                    color.g = 1.0;\r\n                    color.b = 1.0;\r\n                    color.a = 1.0;\r\n                }\r\n            }\r\n            colors.push(this._color.r, this._color.g, this._color.b, this._color.a);\r\n            c += 4;\r\n\r\n            if (!this.recomputeNormals && meshNor) {\r\n                tmpVertex.x = meshNor[n];\r\n                tmpVertex.y = meshNor[n + 1];\r\n                tmpVertex.z = meshNor[n + 2];\r\n                Vector3.TransformNormalToRef(tmpVertex, rotMatrix, tmpVertex);\r\n                normals.push(tmpVertex.x, tmpVertex.y, tmpVertex.z);\r\n                n += 3;\r\n            }\r\n\r\n        }\r\n\r\n        for (i = 0; i < meshInd.length; i++) {\r\n            var current_ind = p + meshInd[i];\r\n            indices.push(current_ind);\r\n            if (current_ind > 65535) {\r\n                this._needs32Bits = true;\r\n            }\r\n        }\r\n\r\n        if (this._pickable) {\r\n            var nbfaces = meshInd.length / 3;\r\n            for (i = 0; i < nbfaces; i++) {\r\n                this.pickedParticles.push({ idx: idx, faceId: i });\r\n            }\r\n        }\r\n\r\n        if (this._depthSort) {\r\n            this.depthSortedParticles.push(new DepthSortedParticle());\r\n        }\r\n\r\n        return copy;\r\n    }\r\n\r\n    // returns a shape array from positions array\r\n    private _posToShape(positions: number[] | Float32Array): Vector3[] {\r\n        var shape = [];\r\n        for (var i = 0; i < positions.length; i += 3) {\r\n            shape.push(Vector3.FromArray(positions, i));\r\n        }\r\n        return shape;\r\n    }\r\n\r\n    // returns a shapeUV array from a Vector4 uvs\r\n    private _uvsToShapeUV(uvs: number[] | Float32Array): number[] {\r\n        var shapeUV = [];\r\n        if (uvs) {\r\n            for (var i = 0; i < uvs.length; i++) {\r\n                shapeUV.push(uvs[i]);\r\n            }\r\n        }\r\n        return shapeUV;\r\n    }\r\n\r\n    // adds a new particle object in the particles array\r\n    private _addParticle(idx: number, idxpos: number, idxind: number, model: ModelShape, shapeId: number, idxInShape: number, bInfo: Nullable<BoundingInfo> = null): SolidParticle {\r\n        var sp = new SolidParticle(idx, idxpos, idxind, model, shapeId, idxInShape, this, bInfo);\r\n        this.particles.push(sp);\r\n        return sp;\r\n    }\r\n\r\n    /**\r\n     * Adds some particles to the SPS from the model shape. Returns the shape id.\r\n     * Please read the doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#create-an-immutable-sps\r\n     * @param mesh is any Mesh object that will be used as a model for the solid particles.\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param options {positionFunction} is an optional javascript function to called for each particle on SPS creation.\r\n     * {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation\r\n     * @returns the number of shapes in the system\r\n     */\r\n    public addShape(mesh: Mesh, nb: number, options?: { positionFunction?: any; vertexFunction?: any }): number {\r\n        var meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        var meshInd = <IndicesArray>mesh.getIndices();\r\n        var meshUV = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind);\r\n        var meshCol = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n        var meshNor = <FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind);\r\n        var bbInfo;\r\n        if (this._particlesIntersect) {\r\n            bbInfo = mesh.getBoundingInfo();\r\n        }\r\n\r\n        var shape = this._posToShape(meshPos);\r\n        var shapeUV = this._uvsToShapeUV(meshUV);\r\n\r\n        var posfunc = options ? options.positionFunction : null;\r\n        var vtxfunc = options ? options.vertexFunction : null;\r\n\r\n        var modelShape = new ModelShape(this._shapeCounter, shape, meshInd.length, shapeUV, posfunc, vtxfunc);\r\n\r\n        // particles\r\n        var sp;\r\n        var currentCopy;\r\n        var idx = this.nbParticles;\r\n        for (var i = 0; i < nb; i++) {\r\n            var currentPos = this._positions.length;\r\n            var currentInd = this._indices.length;\r\n            currentCopy = this._meshBuilder(this._index, shape, this._positions, meshInd, this._indices, meshUV, this._uvs, meshCol, this._colors, meshNor, this._normals, idx, i, options);\r\n            if (this._updatable) {\r\n                sp = this._addParticle(idx, currentPos, currentInd, modelShape, this._shapeCounter, i, bbInfo);\r\n                sp.position.copyFrom(currentCopy.position);\r\n                sp.rotation.copyFrom(currentCopy.rotation);\r\n                if (currentCopy.rotationQuaternion && sp.rotationQuaternion) {\r\n                    sp.rotationQuaternion.copyFrom(currentCopy.rotationQuaternion);\r\n                }\r\n                if (currentCopy.color && sp.color) {\r\n                    sp.color.copyFrom(currentCopy.color);\r\n                }\r\n                sp.scaling.copyFrom(currentCopy.scaling);\r\n                sp.uvs.copyFrom(currentCopy.uvs);\r\n            }\r\n            this._index += shape.length;\r\n            idx++;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._shapeCounter++;\r\n        return this._shapeCounter - 1;\r\n    }\r\n\r\n    // rebuilds a particle back to its just built status : if needed, recomputes the custom positions and vertices\r\n    private _rebuildParticle(particle: SolidParticle): void {\r\n        this._resetCopy();\r\n        const copy = this._copy;\r\n        if (particle._model._positionFunction) {        // recall to stored custom positionFunction\r\n            particle._model._positionFunction(copy, particle.idx, particle.idxInShape);\r\n        }\r\n\r\n        const rotMatrix = Tmp.Matrix[0];\r\n        const tmpVertex = Tmp.Vector3[0];\r\n        const tmpRotated = Tmp.Vector3[1];\r\n        const pivotBackTranslation = Tmp.Vector3[2];\r\n        const scaledPivot = Tmp.Vector3[3];\r\n\r\n        copy.getRotationMatrix(rotMatrix);\r\n\r\n        particle.pivot.multiplyToRef(particle.scaling, scaledPivot);\r\n\r\n        if (copy.translateFromPivot) {\r\n            pivotBackTranslation.copyFromFloats(0.0, 0.0, 0.0);\r\n        }\r\n        else {\r\n            pivotBackTranslation.copyFrom(scaledPivot);\r\n        }\r\n\r\n        const shape = particle._model._shape;\r\n\r\n        for (var pt = 0; pt < shape.length; pt++) {\r\n            tmpVertex.copyFrom(shape[pt]);\r\n            if (particle._model._vertexFunction) {\r\n                particle._model._vertexFunction(copy, tmpVertex, pt); // recall to stored vertexFunction\r\n            }\r\n\r\n            tmpVertex.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\r\n            Vector3.TransformCoordinatesToRef(tmpVertex, rotMatrix, tmpRotated);\r\n            tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position).toArray(this._positions32, particle._pos + pt * 3);\r\n        }\r\n        particle.position.setAll(0.0);\r\n        particle.rotation.setAll(0.0);\r\n        particle.rotationQuaternion = null;\r\n        particle.scaling.setAll(1.0);\r\n        particle.uvs.setAll(0.0);\r\n        particle.pivot.setAll(0.0);\r\n        particle.translateFromPivot = false;\r\n        particle.parentId = null;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.\r\n     * @returns the SPS.\r\n     */\r\n    public rebuildMesh(): SolidParticleSystem {\r\n        for (var p = 0; p < this.particles.length; p++) {\r\n            this._rebuildParticle(this.particles[p]);\r\n        }\r\n        this.mesh.updateVerticesData(VertexBuffer.PositionKind, this._positions32, false, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\r\n     *  This method calls `updateParticle()` for each particle of the SPS.\r\n     *  For an animated SPS, it is usually called within the render loop.\r\n     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\r\n     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\r\n     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\r\n     * @returns the SPS.\r\n     */\r\n    public setParticles(start: number = 0, end: number = this.nbParticles - 1, update: boolean = true): SolidParticleSystem {\r\n        if (!this._updatable) {\r\n            return this;\r\n        }\r\n\r\n        // custom beforeUpdate\r\n        this.beforeUpdateParticles(start, end, update);\r\n\r\n        const rotMatrix = Tmp.Matrix[0];\r\n        const invertedMatrix = Tmp.Matrix[1];\r\n        const mesh = this.mesh;\r\n        const colors32 = this._colors32;\r\n        const positions32 = this._positions32;\r\n        const normals32 = this._normals32;\r\n        const uvs32 = this._uvs32;\r\n        const indices32 = this._indices32;\r\n        const indices = this._indices;\r\n        const fixedNormal32 = this._fixedNormal32;\r\n\r\n        const tempVectors = Tmp.Vector3;\r\n        const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\r\n        const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\r\n        const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\r\n        const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\r\n        const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\r\n        const camInvertedPosition = tempVectors[10].setAll(0);\r\n\r\n        // cases when the World Matrix is to be computed first\r\n        if (this.billboard || this._depthSort) {\r\n            this.mesh.computeWorldMatrix(true);\r\n            this.mesh._worldMatrix.invertToRef(invertedMatrix);\r\n        }\r\n        // if the particles will always face the camera\r\n        if (this.billboard) {\r\n            // compute the camera position and un-rotate it by the current mesh rotation\r\n            const tmpVertex = tempVectors[0];\r\n            this._camera.getDirectionToRef(Axis.Z, tmpVertex);\r\n            Vector3.TransformNormalToRef(tmpVertex, invertedMatrix, camAxisZ);\r\n            camAxisZ.normalize();\r\n            // same for camera up vector extracted from the cam view matrix\r\n            var view = this._camera.getViewMatrix(true);\r\n            Vector3.TransformNormalFromFloatsToRef(view.m[1], view.m[5], view.m[9], invertedMatrix, camAxisY);\r\n            Vector3.CrossToRef(camAxisY, camAxisZ, camAxisX);\r\n            camAxisY.normalize();\r\n            camAxisX.normalize();\r\n        }\r\n\r\n        // if depthSort, compute the camera global position in the mesh local system\r\n        if (this._depthSort) {\r\n            Vector3.TransformCoordinatesToRef(this._camera.globalPosition, invertedMatrix, camInvertedPosition); // then un-rotate the camera\r\n        }\r\n\r\n        Matrix.IdentityToRef(rotMatrix);\r\n        var idx = 0;            // current position index in the global array positions32\r\n        var index = 0;          // position start index in the global array positions32 of the current particle\r\n        var colidx = 0;         // current color index in the global array colors32\r\n        var colorIndex = 0;     // color start index in the global array colors32 of the current particle\r\n        var uvidx = 0;          // current uv index in the global array uvs32\r\n        var uvIndex = 0;        // uv start index in the global array uvs32 of the current particle\r\n        var pt = 0;             // current index in the particle model shape\r\n\r\n        if (this.mesh.isFacetDataEnabled) {\r\n            this._computeBoundingBox = true;\r\n        }\r\n\r\n        end = (end >= this.nbParticles) ? this.nbParticles - 1 : end;\r\n        if (this._computeBoundingBox) {\r\n            if (start != 0 || end != this.nbParticles - 1) { // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\r\n                const boundingInfo = this.mesh._boundingInfo;\r\n                if (boundingInfo) {\r\n                    minimum.copyFrom(boundingInfo.minimum);\r\n                    maximum.copyFrom(boundingInfo.maximum);\r\n                }\r\n            }\r\n        }\r\n\r\n        // particle loop\r\n        index = this.particles[start]._pos;\r\n        const vpos = (index / 3) | 0;\r\n        colorIndex = vpos * 4;\r\n        uvIndex = vpos * 2;\r\n\r\n        for (var p = start; p <= end; p++) {\r\n            const particle = this.particles[p];\r\n\r\n            // call to custom user function to update the particle properties\r\n            this.updateParticle(particle);\r\n\r\n            const shape = particle._model._shape;\r\n            const shapeUV = particle._model._shapeUV;\r\n            const particleRotationMatrix = particle._rotationMatrix;\r\n            const particlePosition = particle.position;\r\n            const particleRotation = particle.rotation;\r\n            const particleScaling = particle.scaling;\r\n            const particleGlobalPosition = particle._globalPosition;\r\n\r\n            // camera-particle distance for depth sorting\r\n            if (this._depthSort && this._depthSortParticles) {\r\n                var dsp = this.depthSortedParticles[p];\r\n                dsp.ind = particle._ind;\r\n                dsp.indicesLength = particle._model._indicesLength;\r\n                dsp.sqDistance = Vector3.DistanceSquared(particle.position, camInvertedPosition);\r\n            }\r\n\r\n            // skip the computations for inactive or already invisible particles\r\n            if (!particle.alive || (particle._stillInvisible && !particle.isVisible)) {\r\n                // increment indexes for the next particle\r\n                pt = shape.length;\r\n                index += pt * 3;\r\n                colorIndex += pt * 4;\r\n                uvIndex += pt * 2;\r\n                continue;\r\n            }\r\n\r\n            if (particle.isVisible) {\r\n                particle._stillInvisible = false; // un-mark permanent invisibility\r\n\r\n                const scaledPivot = tempVectors[12];\r\n                particle.pivot.multiplyToRef(particleScaling, scaledPivot);\r\n\r\n                // particle rotation matrix\r\n                if (this.billboard) {\r\n                    particleRotation.x = 0.0;\r\n                    particleRotation.y = 0.0;\r\n                }\r\n                if (this._computeParticleRotation || this.billboard) {\r\n                    particle.getRotationMatrix(rotMatrix);\r\n                }\r\n\r\n                const particleHasParent = (particle.parentId !== null);\r\n                if (particleHasParent) {\r\n                    const parent = this.particles[particle.parentId!];\r\n                    const parentRotationMatrix = parent._rotationMatrix;\r\n                    const parentGlobalPosition = parent._globalPosition;\r\n\r\n                    const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\r\n                    const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\r\n                    const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\r\n\r\n                    particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\r\n                    particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\r\n                    particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\r\n\r\n                    if (this._computeParticleRotation || this.billboard) {\r\n                        const rotMatrixValues = rotMatrix.m;\r\n                        particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\r\n                        particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\r\n                        particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\r\n                        particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\r\n                        particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\r\n                        particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\r\n                        particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\r\n                        particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\r\n                        particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\r\n                    }\r\n                }\r\n                else {\r\n                    particleGlobalPosition.x = particlePosition.x;\r\n                    particleGlobalPosition.y = particlePosition.y;\r\n                    particleGlobalPosition.z = particlePosition.z;\r\n\r\n                    if (this._computeParticleRotation || this.billboard) {\r\n                        const rotMatrixValues = rotMatrix.m;\r\n                        particleRotationMatrix[0] = rotMatrixValues[0];\r\n                        particleRotationMatrix[1] = rotMatrixValues[1];\r\n                        particleRotationMatrix[2] = rotMatrixValues[2];\r\n                        particleRotationMatrix[3] = rotMatrixValues[4];\r\n                        particleRotationMatrix[4] = rotMatrixValues[5];\r\n                        particleRotationMatrix[5] = rotMatrixValues[6];\r\n                        particleRotationMatrix[6] = rotMatrixValues[8];\r\n                        particleRotationMatrix[7] = rotMatrixValues[9];\r\n                        particleRotationMatrix[8] = rotMatrixValues[10];\r\n                    }\r\n                }\r\n\r\n                const pivotBackTranslation = tempVectors[11];\r\n                if (particle.translateFromPivot) {\r\n                    pivotBackTranslation.setAll(0.0);\r\n                }\r\n                else {\r\n                    pivotBackTranslation.copyFrom(scaledPivot);\r\n                }\r\n\r\n                // particle vertex loop\r\n                for (pt = 0; pt < shape.length; pt++) {\r\n                    idx = index + pt * 3;\r\n                    colidx = colorIndex + pt * 4;\r\n                    uvidx = uvIndex + pt * 2;\r\n\r\n                    const tmpVertex = tempVectors[0];\r\n                    tmpVertex.copyFrom(shape[pt]);\r\n                    if (this._computeParticleVertex) {\r\n                        this.updateParticleVertex(particle, tmpVertex, pt);\r\n                    }\r\n\r\n                    // positions\r\n                    const vertexX = tmpVertex.x * particleScaling.x - scaledPivot.x;\r\n                    const vertexY = tmpVertex.y * particleScaling.y - scaledPivot.y;\r\n                    const vertexZ = tmpVertex.z * particleScaling.z - scaledPivot.z;\r\n\r\n                    let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\r\n                    let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\r\n                    let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\r\n\r\n                    rotatedX += pivotBackTranslation.x;\r\n                    rotatedY += pivotBackTranslation.y;\r\n                    rotatedZ += pivotBackTranslation.z;\r\n\r\n                    const px = positions32[idx] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\r\n                    const py = positions32[idx + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\r\n                    const pz = positions32[idx + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\r\n\r\n                    if (this._computeBoundingBox) {\r\n                        minimum.minimizeInPlaceFromFloats(px, py, pz);\r\n                        maximum.maximizeInPlaceFromFloats(px, py, pz);\r\n                    }\r\n\r\n                    // normals : if the particles can't be morphed then just rotate the normals, what is much more faster than ComputeNormals()\r\n                    if (!this._computeParticleVertex) {\r\n                        const normalx = fixedNormal32[idx];\r\n                        const normaly = fixedNormal32[idx + 1];\r\n                        const normalz = fixedNormal32[idx + 2];\r\n\r\n                        const rotatedx = normalx * particleRotationMatrix[0] + normaly * particleRotationMatrix[3] + normalz * particleRotationMatrix[6];\r\n                        const rotatedy = normalx * particleRotationMatrix[1] + normaly * particleRotationMatrix[4] + normalz * particleRotationMatrix[7];\r\n                        const rotatedz = normalx * particleRotationMatrix[2] + normaly * particleRotationMatrix[5] + normalz * particleRotationMatrix[8];\r\n\r\n                        normals32[idx] = camAxisX.x * rotatedx + camAxisY.x * rotatedy + camAxisZ.x * rotatedz;\r\n                        normals32[idx + 1] = camAxisX.y * rotatedx + camAxisY.y * rotatedy + camAxisZ.y * rotatedz;\r\n                        normals32[idx + 2] = camAxisX.z * rotatedx + camAxisY.z * rotatedy + camAxisZ.z * rotatedz;\r\n                    }\r\n\r\n                    if (this._computeParticleColor && particle.color) {\r\n                        const color = particle.color;\r\n                        const colors32 = this._colors32;\r\n                        colors32[colidx] = color.r;\r\n                        colors32[colidx + 1] = color.g;\r\n                        colors32[colidx + 2] = color.b;\r\n                        colors32[colidx + 3] = color.a;\r\n                    }\r\n\r\n                    if (this._computeParticleTexture) {\r\n                        const uvs = particle.uvs;\r\n                        uvs32[uvidx] = shapeUV[pt * 2] * (uvs.z - uvs.x) + uvs.x;\r\n                        uvs32[uvidx + 1] = shapeUV[pt * 2 + 1] * (uvs.w - uvs.y) + uvs.y;\r\n                    }\r\n                }\r\n            }\r\n            // particle just set invisible : scaled to zero and positioned at the origin\r\n            else {\r\n                particle._stillInvisible = true;      // mark the particle as invisible\r\n                for (pt = 0; pt < shape.length; pt++) {\r\n                    idx = index + pt * 3;\r\n                    colidx = colorIndex + pt * 4;\r\n                    uvidx = uvIndex + pt * 2;\r\n\r\n                    positions32[idx] = positions32[idx + 1] = positions32[idx + 2] = 0;\r\n                    normals32[idx] = normals32[idx + 1] = normals32[idx + 2] = 0;\r\n                    if (this._computeParticleColor && particle.color) {\r\n                        const color = particle.color;\r\n                        colors32[colidx] = color.r;\r\n                        colors32[colidx + 1] = color.g;\r\n                        colors32[colidx + 2] = color.b;\r\n                        colors32[colidx + 3] = color.a;\r\n                    }\r\n                    if (this._computeParticleTexture) {\r\n                        const uvs = particle.uvs;\r\n                        uvs32[uvidx] = shapeUV[pt * 2] * (uvs.z - uvs.x) + uvs.x;\r\n                        uvs32[uvidx + 1] = shapeUV[pt * 2 + 1] * (uvs.w - uvs.y) + uvs.y;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // if the particle intersections must be computed : update the bbInfo\r\n            if (this._particlesIntersect) {\r\n                const bInfo = particle._boundingInfo;\r\n                const bBox = bInfo.boundingBox;\r\n                const bSphere = bInfo.boundingSphere;\r\n                const modelBoundingInfo = particle._modelBoundingInfo;\r\n                if (!this._bSphereOnly) {\r\n                    // place, scale and rotate the particle bbox within the SPS local system, then update it\r\n                    const modelBoundingInfoVectors = modelBoundingInfo.boundingBox.vectors;\r\n\r\n                    const tempMin = tempVectors[1];\r\n                    const tempMax = tempVectors[2];\r\n                    tempMin.setAll(Number.MAX_VALUE);\r\n                    tempMax.setAll(-Number.MAX_VALUE);\r\n                    for (var b = 0; b < 8; b++) {\r\n                        const scaledX = modelBoundingInfoVectors[b].x * particleScaling.x;\r\n                        const scaledY = modelBoundingInfoVectors[b].y * particleScaling.y;\r\n                        const scaledZ = modelBoundingInfoVectors[b].z * particleScaling.z;\r\n                        const rotatedX = scaledX * particleRotationMatrix[0] + scaledY * particleRotationMatrix[3] + scaledZ * particleRotationMatrix[6];\r\n                        const rotatedY = scaledX * particleRotationMatrix[1] + scaledY * particleRotationMatrix[4] + scaledZ * particleRotationMatrix[7];\r\n                        const rotatedZ = scaledX * particleRotationMatrix[2] + scaledY * particleRotationMatrix[5] + scaledZ * particleRotationMatrix[8];\r\n                        const x = particlePosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\r\n                        const y = particlePosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\r\n                        const z = particlePosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\r\n                        tempMin.minimizeInPlaceFromFloats(x, y, z);\r\n                        tempMax.maximizeInPlaceFromFloats(x, y, z);\r\n                    }\r\n\r\n                    bBox.reConstruct(tempMin, tempMax, mesh._worldMatrix);\r\n                }\r\n\r\n                // place and scale the particle bouding sphere in the SPS local system, then update it\r\n                const minBbox = modelBoundingInfo.minimum.multiplyToRef(particleScaling, tempVectors[1]);\r\n                const maxBbox = modelBoundingInfo.maximum.multiplyToRef(particleScaling, tempVectors[2]);\r\n\r\n                const bSphereCenter = maxBbox.addToRef(minBbox, tempVectors[3]).scaleInPlace(0.5).addInPlace(particleGlobalPosition);\r\n                const halfDiag = maxBbox.subtractToRef(minBbox, tempVectors[4]).scaleInPlace(0.5 * this._bSphereRadiusFactor);\r\n                const bSphereMinBbox = bSphereCenter.subtractToRef(halfDiag, tempVectors[1]);\r\n                const bSphereMaxBbox = bSphereCenter.addToRef(halfDiag, tempVectors[2]);\r\n                bSphere.reConstruct(bSphereMinBbox, bSphereMaxBbox, mesh._worldMatrix);\r\n            }\r\n\r\n            // increment indexes for the next particle\r\n            index = idx + 3;\r\n            colorIndex = colidx + 4;\r\n            uvIndex = uvidx + 2;\r\n        }\r\n\r\n        // if the VBO must be updated\r\n        if (update) {\r\n            if (this._computeParticleColor) {\r\n                mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\r\n            }\r\n            if (this._computeParticleTexture) {\r\n                mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\r\n            }\r\n            mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\r\n            if (!mesh.areNormalsFrozen || mesh.isFacetDataEnabled) {\r\n                if (this._computeParticleVertex || mesh.isFacetDataEnabled) {\r\n                    // recompute the normals only if the particles can be morphed, update then also the normal reference array _fixedNormal32[]\r\n                    var params = mesh.isFacetDataEnabled ? mesh.getFacetDataParameters() : null;\r\n                    VertexData.ComputeNormals(positions32, indices32, normals32, params);\r\n                    for (var i = 0; i < normals32.length; i++) {\r\n                        fixedNormal32[i] = normals32[i];\r\n                    }\r\n                }\r\n                if (!mesh.areNormalsFrozen) {\r\n                    mesh.updateVerticesData(VertexBuffer.NormalKind, normals32, false, false);\r\n                }\r\n            }\r\n            if (this._depthSort && this._depthSortParticles) {\r\n                const depthSortedParticles = this.depthSortedParticles;\r\n                depthSortedParticles.sort(depthSortFunction);\r\n                const dspl = depthSortedParticles.length;\r\n                let sid = 0;\r\n                for (let sorted = 0; sorted < dspl; sorted++) {\r\n                    const lind = depthSortedParticles[sorted].indicesLength;\r\n                    const sind = depthSortedParticles[sorted].ind;\r\n                    for (var i = 0; i < lind; i++) {\r\n                        indices32[sid] = indices[sind + i];\r\n                        sid++;\r\n                    }\r\n                }\r\n                mesh.updateIndices(indices32);\r\n            }\r\n        }\r\n        if (this._computeBoundingBox) {\r\n            if (mesh._boundingInfo) {\r\n                mesh._boundingInfo.reConstruct(minimum, maximum, mesh._worldMatrix);\r\n            }\r\n            else {\r\n                mesh._boundingInfo = new BoundingInfo(minimum, maximum, mesh._worldMatrix);\r\n            }\r\n        }\r\n        this.afterUpdateParticles(start, end, update);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n    * Disposes the SPS.\r\n    */\r\n    public dispose(): void {\r\n        this.mesh.dispose();\r\n        this.vars = null;\r\n        // drop references to internal big arrays for the GC\r\n        (<any>this._positions) = null;\r\n        (<any>this._indices) = null;\r\n        (<any>this._normals) = null;\r\n        (<any>this._uvs) = null;\r\n        (<any>this._colors) = null;\r\n        (<any>this._indices32) = null;\r\n        (<any>this._positions32) = null;\r\n        (<any>this._normals32) = null;\r\n        (<any>this._fixedNormal32) = null;\r\n        (<any>this._uvs32) = null;\r\n        (<any>this._colors32) = null;\r\n        (<any>this.pickedParticles) = null;\r\n    }\r\n\r\n    /**\r\n     * Visibilty helper : Recomputes the visible size according to the mesh bounding box\r\n     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility\r\n     * @returns the SPS.\r\n     */\r\n    public refreshVisibleSize(): SolidParticleSystem {\r\n        if (!this._isVisibilityBoxLocked) {\r\n            this.mesh.refreshBoundingInfo();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\r\n     * @param size the size (float) of the visibility box\r\n     * note : this doesn't lock the SPS mesh bounding box.\r\n     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility\r\n     */\r\n    public setVisibilityBox(size: number): void {\r\n        var vis = size / 2;\r\n        this.mesh._boundingInfo = new BoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\r\n    }\r\n\r\n    /**\r\n     * Gets whether the SPS as always visible or not\r\n     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility\r\n     */\r\n    public get isAlwaysVisible(): boolean {\r\n        return this._alwaysVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the SPS as always visible or not\r\n     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility\r\n     */\r\n    public set isAlwaysVisible(val: boolean) {\r\n        this._alwaysVisible = val;\r\n        this.mesh.alwaysSelectAsActiveMesh = val;\r\n    }\r\n\r\n    /**\r\n     * Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\r\n     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility\r\n     */\r\n    public set isVisibilityBoxLocked(val: boolean) {\r\n        this._isVisibilityBoxLocked = val;\r\n\r\n        let boundingInfo = this.mesh.getBoundingInfo();\r\n\r\n        boundingInfo.isLocked = val;\r\n    }\r\n\r\n    /**\r\n     * Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\r\n     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility\r\n     */\r\n    public get isVisibilityBoxLocked(): boolean {\r\n        return this._isVisibilityBoxLocked;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle rotations or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\r\n     */\r\n    public set computeParticleRotation(val: boolean) {\r\n        this._computeParticleRotation = val;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle colors or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public set computeParticleColor(val: boolean) {\r\n        this._computeParticleColor = val;\r\n    }\r\n\r\n    public set computeParticleTexture(val: boolean) {\r\n        this._computeParticleTexture = val;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.\r\n     * Default value : false. The SPS is faster when it's set to false.\r\n     * Note : the particle custom vertex positions aren't stored values.\r\n     */\r\n    public set computeParticleVertex(val: boolean) {\r\n        this._computeParticleVertex = val;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public set computeBoundingBox(val: boolean) {\r\n        this._computeBoundingBox = val;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to sort or not the distance between each particle and the camera.\r\n     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\r\n     * Default : `true`\r\n     */\r\n    public set depthSortParticles(val: boolean) {\r\n        this._depthSortParticles = val;\r\n    }\r\n\r\n    /**\r\n     * Gets if `setParticles()` computes the particle rotations or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\r\n     */\r\n    public get computeParticleRotation(): boolean {\r\n        return this._computeParticleRotation;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes the particle colors or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleColor(): boolean {\r\n        return this._computeParticleColor;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes the particle textures or not.\r\n     * Default value : true. The SPS is faster when it's set to false.\r\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleTexture(): boolean {\r\n        return this._computeParticleTexture;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.\r\n     * Default value : false. The SPS is faster when it's set to false.\r\n     * Note : the particle custom vertex positions aren't stored values.\r\n     */\r\n    public get computeParticleVertex(): boolean {\r\n        return this._computeParticleVertex;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public get computeBoundingBox(): boolean {\r\n        return this._computeBoundingBox;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` sorts or not the distance between each particle and the camera.\r\n     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\r\n     * Default : `true`\r\n     */\r\n    public get depthSortParticles(): boolean {\r\n        return this._depthSortParticles;\r\n    }\r\n\r\n    // =======================================================================\r\n    // Particle behavior logic\r\n    // these following methods may be overwritten by the user to fit his needs\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to set all the particle first values.\r\n     * The SPS doesn't call this function, you may have to call it by your own.\r\n     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management\r\n     */\r\n    public initParticles(): void {\r\n    }\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to recycle a particle.\r\n     * The SPS doesn't call this function, you may have to call it by your own.\r\n     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management\r\n     * @param particle The particle to recycle\r\n     * @returns the recycled particle\r\n     */\r\n    public recycleParticle(particle: SolidParticle): SolidParticle {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * Updates a particle : this function should  be overwritten by the user.\r\n     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\r\n     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management\r\n     * @example : just set a particle position or velocity and recycle conditions\r\n     * @param particle The particle to update\r\n     * @returns the updated particle\r\n     */\r\n    public updateParticle(particle: SolidParticle): SolidParticle {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * Updates a vertex of a particle : it can be overwritten by the user.\r\n     * This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.\r\n     * @param particle the current particle\r\n     * @param vertex the current index of the current particle\r\n     * @param pt the index of the current vertex in the particle shape\r\n     * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#update-each-particle-shape\r\n     * @example : just set a vertex particle position\r\n     * @returns the updated vertex\r\n     */\r\n    public updateParticleVertex(particle: SolidParticle, vertex: Vector3, pt: number): Vector3 {\r\n        return vertex;\r\n    }\r\n\r\n    /**\r\n     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    public beforeUpdateParticles(start?: number, stop?: number, update?: boolean): void {\r\n    }\r\n    /**\r\n     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\r\n     * This will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    public afterUpdateParticles(start?: number, stop?: number, update?: boolean): void {\r\n    }\r\n}\r\n"]}