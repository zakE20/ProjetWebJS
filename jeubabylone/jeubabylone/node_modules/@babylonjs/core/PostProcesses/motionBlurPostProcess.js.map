{"version":3,"file":"motionBlurPostProcess.js","sourceRoot":"","sources":["../../../sourceES6/core/PostProcesses/motionBlurPostProcess.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Vector2 } from \"../Maths/math\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { PostProcess, PostProcessOptions } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\r\nimport { Scene } from \"../scene\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\nimport \"../Animations/animatable\";\r\nimport '../Rendering/geometryBufferRendererSceneComponent';\r\nimport \"../Shaders/motionBlur.fragment\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\n\r\n/**\r\n * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.\r\n * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.\r\n * As an example, all you have to do is to create the post-process:\r\n *  var mb = new BABYLON.MotionBlurPostProcess(\r\n *      'mb', // The name of the effect.\r\n *      scene, // The scene containing the objects to blur according to their velocity.\r\n *      1.0, // The required width/height ratio to downsize to before computing the render pass.\r\n *      camera // The camera to apply the render pass to.\r\n * );\r\n * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.\r\n */\r\nexport class MotionBlurPostProcess extends PostProcess {\r\n    /**\r\n     * Defines how much the image is blurred by the movement. Default value is equal to 1\r\n     */\r\n    public motionStrength: number = 1;\r\n\r\n    /**\r\n     * Gets the number of iterations are used for motion blur quality. Default value is equal to 32\r\n     */\r\n    public get motionBlurSamples(): number {\r\n        return this._motionBlurSamples;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of iterations to be used for motion blur quality\r\n     */\r\n    public set motionBlurSamples(samples: number) {\r\n        this._motionBlurSamples = samples;\r\n\r\n        if (this._geometryBufferRenderer) {\r\n            this.updateEffect(\"#define GEOMETRY_SUPPORTED\\n#define SAMPLES \" + samples.toFixed(1));\r\n        }\r\n    }\r\n\r\n    private _motionBlurSamples: number = 32;\r\n    private _geometryBufferRenderer: Nullable<GeometryBufferRenderer>;\r\n\r\n    /**\r\n     * Creates a new instance MotionBlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param scene The scene containing the objects to blur according to their velocity.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(name: string, scene: Scene, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode?: number, engine?: Engine, reusable?: boolean, textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT, blockCompilation = false) {\r\n        super(name, \"motionBlur\", [\"motionStrength\", \"motionScale\", \"screenSize\"], [\"velocitySampler\"], options, camera, samplingMode, engine, reusable, \"#define GEOMETRY_SUPPORTED\\n#define SAMPLES 64.0\", textureType, undefined, null, blockCompilation);\r\n\r\n        this._geometryBufferRenderer = scene.enableGeometryBufferRenderer();\r\n\r\n        if (!this._geometryBufferRenderer) {\r\n            // Geometry buffer renderer is not supported. So, work as a passthrough.\r\n            Logger.Warn(\"Multiple Render Target support needed to compute object based motion blur\");\r\n            this.updateEffect();\r\n        } else {\r\n            // Geometry buffer renderer is supported.\r\n            this._geometryBufferRenderer.enableVelocity = true;\r\n\r\n            this.onApply = (effect: Effect) => {\r\n                effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\r\n\r\n                effect.setFloat(\"motionScale\", scene.getAnimationRatio());\r\n                effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n                if (this._geometryBufferRenderer) {\r\n                    const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);\r\n                    effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Excludes the given skinned mesh from computing bones velocities.\r\n     * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.\r\n     * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.\r\n     */\r\n    public excludeSkinnedMesh(skinnedMesh: AbstractMesh): void {\r\n        if (this._geometryBufferRenderer && skinnedMesh.skeleton) {\r\n            this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity.push(skinnedMesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.\r\n     * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.\r\n     * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.\r\n     */\r\n    public removeExcludedSkinnedMesh(skinnedMesh: AbstractMesh): void {\r\n        if (this._geometryBufferRenderer && skinnedMesh.skeleton) {\r\n            const index = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity.indexOf(skinnedMesh);\r\n            if (index !== -1) {\r\n                this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the post process.\r\n     * @param camera The camera to dispose the post process on.\r\n     */\r\n    public dispose(camera?: Camera): void {\r\n        if (this._geometryBufferRenderer) {\r\n            // Clear previous transformation matrices dictionary used to compute objects velocities\r\n            this._geometryBufferRenderer._previousTransformationMatrices = {};\r\n            this._geometryBufferRenderer._previousBonesTransformationMatrices = {};\r\n            this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];\r\n        }\r\n\r\n        super.dispose(camera);\r\n    }\r\n}\r\n"]}