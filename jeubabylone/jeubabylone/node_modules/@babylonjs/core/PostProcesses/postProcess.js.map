{"version":3,"file":"postProcess.js","sourceRoot":"","sources":["../../../sourceES6/core/PostProcesses/postProcess.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Observable, Observer } from \"../Misc/observable\";\r\nimport { Color4, Vector2 } from \"../Maths/math\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport \"../Shaders/postprocess.vertex\";\r\nimport { IInspectable } from '../Misc/iInspectable';\r\n\r\ndeclare type Scene  = import(\"../scene\").Scene;\r\ndeclare type InternalTexture = import(\"../Materials/Textures/internalTexture\").InternalTexture;\r\ndeclare type WebVRFreeCamera = import(\"../Cameras/VR/webVRCamera\").WebVRFreeCamera;\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\n\r\n/**\r\n * Size options for a post process\r\n */\r\nexport type PostProcessOptions = { width: number, height: number };\r\n\r\n/**\r\n * PostProcess can be used to apply a shader to a texture after it has been rendered\r\n * See https://doc.babylonjs.com/how_to/how_to_use_postprocesses\r\n */\r\nexport class PostProcess {\r\n    /**\r\n     * Gets or sets the unique id of the post process\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n    * Width of the texture to apply the post process on\r\n    */\r\n    public width = -1;\r\n    /**\r\n    * Height of the texture to apply the post process on\r\n    */\r\n    public height = -1;\r\n\r\n    /**\r\n    * Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)\r\n    * @hidden\r\n    */\r\n    public _outputTexture: Nullable<InternalTexture> = null;\r\n    /**\r\n    * Sampling mode used by the shader\r\n    * See https://doc.babylonjs.com/classes/3.1/texture\r\n    */\r\n    public renderTargetSamplingMode: number;\r\n    /**\r\n    * Clear color to use when screen clearing\r\n    */\r\n    public clearColor: Color4;\r\n    /**\r\n    * If the buffer needs to be cleared before applying the post process. (default: true)\r\n    * Should be set to false if shader will overwrite all previous pixels.\r\n    */\r\n    public autoClear = true;\r\n    /**\r\n    * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)\r\n    */\r\n    public alphaMode = Constants.ALPHA_DISABLE;\r\n    /**\r\n    * Sets the setAlphaBlendConstants of the babylon engine\r\n    */\r\n    public alphaConstants: Color4;\r\n    /**\r\n    * Animations to be used for the post processing\r\n    */\r\n    public animations = new Array<Animation>();\r\n\r\n    /**\r\n     * Enable Pixel Perfect mode where texture is not scaled to be power of 2.\r\n     * Can only be used on a single postprocess or on the last one of a chain. (default: false)\r\n     */\r\n    public enablePixelPerfectMode = false;\r\n\r\n    /**\r\n     * Force the postprocess to be applied without taking in account viewport\r\n     */\r\n    public forceFullscreenViewport = true;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](http://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |\r\n     * | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](http://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |\r\n     * | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](http://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |\r\n     *\r\n     */\r\n    public scaleMode = Constants.SCALEMODE_FLOOR;\r\n    /**\r\n    * Force textures to be a power of two (default: false)\r\n    */\r\n    public alwaysForcePOT = false;\r\n\r\n    private _samples = 1;\r\n    /**\r\n    * Number of sample textures (default: 1)\r\n    */\r\n    public get samples() {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(n: number) {\r\n        this._samples = n;\r\n\r\n        this._textures.forEach((texture) => {\r\n            if (texture.samples !== this._samples) {\r\n                this._engine.updateRenderTargetTextureSampleCount(texture, this._samples);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n    * Modify the scale of the post process to be the same as the viewport (default: false)\r\n    */\r\n    public adaptScaleToCurrentViewport = false;\r\n\r\n    private _camera: Camera;\r\n    private _scene: Scene;\r\n    private _engine: Engine;\r\n\r\n    private _options: number | PostProcessOptions;\r\n    private _reusable = false;\r\n    private _textureType: number;\r\n    /**\r\n    * Smart array of input and output textures for the post process.\r\n    * @hidden\r\n    */\r\n    public _textures = new SmartArray<InternalTexture>(2);\r\n    /**\r\n    * The index in _textures that corresponds to the output texture.\r\n    * @hidden\r\n    */\r\n    public _currentRenderTextureInd = 0;\r\n    private _effect: Effect;\r\n    private _samplers: string[];\r\n    private _fragmentUrl: string;\r\n    private _vertexUrl: string;\r\n    private _parameters: string[];\r\n    private _scaleRatio = new Vector2(1, 1);\r\n    protected _indexParameters: any;\r\n    private _shareOutputWithPostProcess: Nullable<PostProcess>;\r\n    private _texelSize = Vector2.Zero();\r\n    private _forcedOutputTexture: InternalTexture;\r\n\r\n    /**\r\n     * Returns the fragment url or shader name used in the post process.\r\n     * @returns the fragment url or name in the shader store.\r\n     */\r\n    public getEffectName(): string {\r\n        return this._fragmentUrl;\r\n    }\r\n\r\n    // Events\r\n\r\n    /**\r\n    * An event triggered when the postprocess is activated.\r\n    */\r\n    public onActivateObservable = new Observable<Camera>();\r\n\r\n    private _onActivateObserver: Nullable<Observer<Camera>>;\r\n    /**\r\n    * A function that is added to the onActivateObservable\r\n    */\r\n    public set onActivate(callback: Nullable<(camera: Camera) => void>) {\r\n        if (this._onActivateObserver) {\r\n            this.onActivateObservable.remove(this._onActivateObserver);\r\n        }\r\n        if (callback) {\r\n            this._onActivateObserver = this.onActivateObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * An event triggered when the postprocess changes its size.\r\n    */\r\n    public onSizeChangedObservable = new Observable<PostProcess>();\r\n\r\n    private _onSizeChangedObserver: Nullable<Observer<PostProcess>>;\r\n    /**\r\n    * A function that is added to the onSizeChangedObservable\r\n    */\r\n    public set onSizeChanged(callback: (postProcess: PostProcess) => void) {\r\n        if (this._onSizeChangedObserver) {\r\n            this.onSizeChangedObservable.remove(this._onSizeChangedObserver);\r\n        }\r\n        this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered when the postprocess applies its effect.\r\n    */\r\n    public onApplyObservable = new Observable<Effect>();\r\n\r\n    private _onApplyObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n    * A function that is added to the onApplyObservable\r\n    */\r\n    public set onApply(callback: (effect: Effect) => void) {\r\n        if (this._onApplyObserver) {\r\n            this.onApplyObservable.remove(this._onApplyObserver);\r\n        }\r\n        this._onApplyObserver = this.onApplyObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered before rendering the postprocess\r\n    */\r\n    public onBeforeRenderObservable = new Observable<Effect>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n    * A function that is added to the onBeforeRenderObservable\r\n    */\r\n    public set onBeforeRender(callback: (effect: Effect) => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered after rendering the postprocess\r\n    */\r\n    public onAfterRenderObservable = new Observable<Effect>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n    * A function that is added to the onAfterRenderObservable\r\n    */\r\n    public set onAfterRender(callback: (efect: Effect) => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will\r\n    * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.\r\n    */\r\n    public get inputTexture(): InternalTexture {\r\n        return this._textures.data[this._currentRenderTextureInd];\r\n    }\r\n\r\n    public set inputTexture(value: InternalTexture) {\r\n        this._forcedOutputTexture = value;\r\n    }\r\n\r\n    /**\r\n    * Gets the camera which post process is applied to.\r\n    * @returns The camera the post process is applied to.\r\n    */\r\n    public getCamera(): Camera {\r\n        return this._camera;\r\n    }\r\n\r\n    /**\r\n    * Gets the texel size of the postprocess.\r\n    * See https://en.wikipedia.org/wiki/Texel_(graphics)\r\n    */\r\n    public get texelSize(): Vector2 {\r\n        if (this._shareOutputWithPostProcess) {\r\n            return this._shareOutputWithPostProcess.texelSize;\r\n        }\r\n\r\n        if (this._forcedOutputTexture) {\r\n            this._texelSize.copyFromFloats(1.0 / this._forcedOutputTexture.width, 1.0 / this._forcedOutputTexture.height);\r\n        }\r\n\r\n        return this._texelSize;\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance PostProcess\r\n     * @param name The name of the PostProcess.\r\n     * @param fragmentUrl The url of the fragment shader to be used.\r\n     * @param parameters Array of the names of uniform non-sampler2D variables that will be passed to the shader.\r\n     * @param samplers Array of the names of uniform sampler2D variables that will be passed to the shader.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param defines String of defines that will be set when running the fragment shader. (default: null)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param vertexUrl The url of the vertex shader to be used. (default: \"postprocess\")\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param blockCompilation If the shader should not be compiled imediatly. (default: false)\r\n     */\r\n    constructor(\r\n        /** Name of the PostProcess. */\r\n        public name: string,\r\n        fragmentUrl: string, parameters: Nullable<string[]>, samplers: Nullable<string[]>, options: number | PostProcessOptions, camera: Nullable<Camera>,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE, engine?: Engine, reusable?: boolean, defines: Nullable<string> = null, textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT, vertexUrl: string = \"postprocess\", indexParameters?: any, blockCompilation = false) {\r\n        if (camera != null) {\r\n            this._camera = camera;\r\n            this._scene = camera.getScene();\r\n            camera.attachPostProcess(this);\r\n            this._engine = this._scene.getEngine();\r\n\r\n            this._scene.postProcesses.push(this);\r\n            this.uniqueId = this._scene.getUniqueId();\r\n        }\r\n        else if (engine) {\r\n            this._engine = engine;\r\n            this._engine.postProcesses.push(this);\r\n        }\r\n        this._options = options;\r\n        this.renderTargetSamplingMode = samplingMode ? samplingMode : Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        this._reusable = reusable || false;\r\n        this._textureType = textureType;\r\n\r\n        this._samplers = samplers || [];\r\n        this._samplers.push(\"textureSampler\");\r\n\r\n        this._fragmentUrl = fragmentUrl;\r\n        this._vertexUrl = vertexUrl;\r\n        this._parameters = parameters || [];\r\n\r\n        this._parameters.push(\"scale\");\r\n\r\n        this._indexParameters = indexParameters;\r\n\r\n        if (!blockCompilation) {\r\n            this.updateEffect(defines);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a string idenfifying the name of the class\r\n     * @returns \"PostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"PostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Gets the engine which this post process belongs to.\r\n     * @returns The engine the post process was enabled with.\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corrisponding the the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._effect;\r\n    }\r\n\r\n    /**\r\n     * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.\r\n     * @param postProcess The post process to share the output with.\r\n     * @returns This post process.\r\n     */\r\n    public shareOutputWith(postProcess: PostProcess): PostProcess {\r\n        this._disposeTextures();\r\n\r\n        this._shareOutputWithPostProcess = postProcess;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.\r\n     * This should be called if the post process that shares output with this post process is disabled/disposed.\r\n     */\r\n    public useOwnOutput() {\r\n        if (this._textures.length == 0) {\r\n            this._textures = new SmartArray<InternalTexture>(2);\r\n        }\r\n\r\n        this._shareOutputWithPostProcess = null;\r\n    }\r\n\r\n    /**\r\n     * Updates the effect with the current post process compile time values and recompiles the shader.\r\n     * @param defines Define statements that should be added at the beginning of the shader. (default: null)\r\n     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\r\n     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param onCompiled Called when the shader has been compiled.\r\n     * @param onError Called if there is an error when compiling a shader.\r\n     */\r\n    public updateEffect(defines: Nullable<string> = null, uniforms: Nullable<string[]> = null, samplers: Nullable<string[]> = null, indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void) {\r\n        this._effect = this._engine.createEffect({ vertex: this._vertexUrl, fragment: this._fragmentUrl },\r\n            [\"position\"],\r\n            uniforms || this._parameters,\r\n            samplers || this._samplers,\r\n            defines !== null ? defines : \"\",\r\n            undefined,\r\n            onCompiled,\r\n            onError,\r\n            indexParameters || this._indexParameters\r\n        );\r\n    }\r\n\r\n    /**\r\n     * The post process is reusable if it can be used multiple times within one frame.\r\n     * @returns If the post process is reusable\r\n     */\r\n    public isReusable(): boolean {\r\n        return this._reusable;\r\n    }\r\n\r\n    /** invalidate frameBuffer to hint the postprocess to create a depth buffer */\r\n    public markTextureDirty(): void {\r\n        this.width = -1;\r\n    }\r\n\r\n    /**\r\n     * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.\r\n     * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.\r\n     * @param camera The camera that will be used in the post process. This camera will be used when calling onActivateObservable.\r\n     * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)\r\n     * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)\r\n     * @returns The target texture that was bound to be written to.\r\n     */\r\n    public activate(camera: Nullable<Camera>, sourceTexture: Nullable<InternalTexture> = null, forceDepthStencil?: boolean): InternalTexture {\r\n        camera = camera || this._camera;\r\n\r\n        var scene = camera.getScene();\r\n        var engine = scene.getEngine();\r\n        var maxSize = engine.getCaps().maxTextureSize;\r\n\r\n        var requiredWidth = ((sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * <number>this._options) | 0;\r\n        var requiredHeight = ((sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * <number>this._options) | 0;\r\n\r\n        // If rendering to a webvr camera's left or right eye only half the width should be used to avoid resize when rendered to screen\r\n        var webVRCamera = (<WebVRFreeCamera>camera.parent);\r\n        if (webVRCamera && (webVRCamera.leftCamera == camera || webVRCamera.rightCamera == camera)) {\r\n            requiredWidth /= 2;\r\n        }\r\n\r\n        var desiredWidth = ((<PostProcessOptions>this._options).width || requiredWidth);\r\n        var desiredHeight = (<PostProcessOptions>this._options).height || requiredHeight;\r\n\r\n        if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {\r\n\r\n            if (this.adaptScaleToCurrentViewport) {\r\n                let currentViewport = engine.currentViewport;\r\n\r\n                if (currentViewport) {\r\n                    desiredWidth *= currentViewport.width;\r\n                    desiredHeight *= currentViewport.height;\r\n                }\r\n            }\r\n\r\n            if (this.renderTargetSamplingMode === Constants.TEXTURE_TRILINEAR_SAMPLINGMODE || this.alwaysForcePOT) {\r\n                if (!(<PostProcessOptions>this._options).width) {\r\n                    desiredWidth = engine.needPOTTextures ? Tools.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;\r\n                }\r\n\r\n                if (!(<PostProcessOptions>this._options).height) {\r\n                    desiredHeight = engine.needPOTTextures ? Tools.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;\r\n                }\r\n            }\r\n\r\n            if (this.width !== desiredWidth || this.height !== desiredHeight) {\r\n                if (this._textures.length > 0) {\r\n                    for (var i = 0; i < this._textures.length; i++) {\r\n                        this._engine._releaseTexture(this._textures.data[i]);\r\n                    }\r\n                    this._textures.reset();\r\n                }\r\n                this.width = desiredWidth;\r\n                this.height = desiredHeight;\r\n\r\n                let textureSize = { width: this.width, height: this.height };\r\n                let textureOptions = {\r\n                    generateMipMaps: false,\r\n                    generateDepthBuffer: forceDepthStencil || camera._postProcesses.indexOf(this) === 0,\r\n                    generateStencilBuffer: (forceDepthStencil || camera._postProcesses.indexOf(this) === 0) && this._engine.isStencilEnable,\r\n                    samplingMode: this.renderTargetSamplingMode,\r\n                    type: this._textureType\r\n                };\r\n\r\n                this._textures.push(this._engine.createRenderTargetTexture(textureSize, textureOptions));\r\n\r\n                if (this._reusable) {\r\n                    this._textures.push(this._engine.createRenderTargetTexture(textureSize, textureOptions));\r\n                }\r\n\r\n                this._texelSize.copyFromFloats(1.0 / this.width, 1.0 / this.height);\r\n\r\n                this.onSizeChangedObservable.notifyObservers(this);\r\n            }\r\n\r\n            this._textures.forEach((texture) => {\r\n                if (texture.samples !== this.samples) {\r\n                    this._engine.updateRenderTargetTextureSampleCount(texture, this.samples);\r\n                }\r\n            });\r\n        }\r\n\r\n        var target: InternalTexture;\r\n\r\n        if (this._shareOutputWithPostProcess) {\r\n            target = this._shareOutputWithPostProcess.inputTexture;\r\n        } else if (this._forcedOutputTexture) {\r\n            target = this._forcedOutputTexture;\r\n\r\n            this.width = this._forcedOutputTexture.width;\r\n            this.height = this._forcedOutputTexture.height;\r\n        } else {\r\n            target = this.inputTexture;\r\n        }\r\n\r\n        // Bind the input of this post process to be used as the output of the previous post process.\r\n        if (this.enablePixelPerfectMode) {\r\n            this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);\r\n            this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);\r\n        }\r\n        else {\r\n            this._scaleRatio.copyFromFloats(1, 1);\r\n            this._engine.bindFramebuffer(target, 0, undefined, undefined, this.forceFullscreenViewport);\r\n        }\r\n\r\n        this.onActivateObservable.notifyObservers(camera);\r\n\r\n        // Clear\r\n        if (this.autoClear && this.alphaMode === Constants.ALPHA_DISABLE) {\r\n            this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);\r\n        }\r\n\r\n        if (this._reusable) {\r\n            this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;\r\n        }\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * If the post process is supported.\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._effect.isSupported;\r\n    }\r\n\r\n    /**\r\n     * The aspect ratio of the output texture.\r\n     */\r\n    public get aspectRatio(): number {\r\n        if (this._shareOutputWithPostProcess) {\r\n            return this._shareOutputWithPostProcess.aspectRatio;\r\n        }\r\n\r\n        if (this._forcedOutputTexture) {\r\n            return this._forcedOutputTexture.width / this._forcedOutputTexture.height;\r\n        }\r\n        return this.width / this.height;\r\n    }\r\n\r\n    /**\r\n     * Get a value indicating if the post-process is ready to be used\r\n     * @returns true if the post-process is ready (shader is compiled)\r\n     */\r\n    public isReady(): boolean {\r\n        return this._effect && this._effect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Binds all textures and uniforms to the shader, this will be run on every pass.\r\n     * @returns the effect corrisponding to this post process. Null if not compiled or not ready.\r\n     */\r\n    public apply(): Nullable<Effect> {\r\n        // Check\r\n        if (!this._effect || !this._effect.isReady()) {\r\n            return null;\r\n        }\r\n\r\n        // States\r\n        this._engine.enableEffect(this._effect);\r\n        this._engine.setState(false);\r\n        this._engine.setDepthBuffer(false);\r\n        this._engine.setDepthWrite(false);\r\n\r\n        // Alpha\r\n        this._engine.setAlphaMode(this.alphaMode);\r\n        if (this.alphaConstants) {\r\n            this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);\r\n        }\r\n\r\n        // Bind the output texture of the preivous post process as the input to this post process.\r\n        var source: InternalTexture;\r\n        if (this._shareOutputWithPostProcess) {\r\n            source = this._shareOutputWithPostProcess.inputTexture;\r\n        } else if (this._forcedOutputTexture) {\r\n            source = this._forcedOutputTexture;\r\n        } else {\r\n            source = this.inputTexture;\r\n        }\r\n        this._effect._bindTexture(\"textureSampler\", source);\r\n\r\n        // Parameters\r\n        this._effect.setVector2(\"scale\", this._scaleRatio);\r\n        this.onApplyObservable.notifyObservers(this._effect);\r\n\r\n        return this._effect;\r\n    }\r\n\r\n    private _disposeTextures() {\r\n        if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {\r\n            return;\r\n        }\r\n\r\n        if (this._textures.length > 0) {\r\n            for (var i = 0; i < this._textures.length; i++) {\r\n                this._engine._releaseTexture(this._textures.data[i]);\r\n            }\r\n        }\r\n        this._textures.dispose();\r\n    }\r\n\r\n    /**\r\n     * Disposes the post process.\r\n     * @param camera The camera to dispose the post process on.\r\n     */\r\n    public dispose(camera?: Camera): void {\r\n        camera = camera || this._camera;\r\n\r\n        this._disposeTextures();\r\n\r\n        if (this._scene) {\r\n            let index = this._scene.postProcesses.indexOf(this);\r\n            if (index !== -1) {\r\n                this._scene.postProcesses.splice(index, 1);\r\n            }\r\n        } else {\r\n            let index = this._engine.postProcesses.indexOf(this);\r\n            if (index !== -1) {\r\n                this._engine.postProcesses.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n        camera.detachPostProcess(this);\r\n\r\n        var index = camera._postProcesses.indexOf(this);\r\n        if (index === 0 && camera._postProcesses.length > 0) {\r\n            var firstPostProcess = this._camera._getFirstPostProcess();\r\n            if (firstPostProcess) {\r\n                firstPostProcess.markTextureDirty();\r\n            }\r\n        }\r\n\r\n        this.onActivateObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onApplyObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n    }\r\n}\r\n"]}