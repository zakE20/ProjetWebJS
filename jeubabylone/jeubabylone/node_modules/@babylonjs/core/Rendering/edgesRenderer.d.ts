import { Nullable } from "../types";
import { VertexBuffer } from "../Meshes/buffer";
import { AbstractMesh } from "../Meshes/abstractMesh";
import { Vector3 } from "../Maths/math";
import { IDisposable } from "../scene";
import { ShaderMaterial } from "../Materials/shaderMaterial";
import "../Shaders/line.fragment";
import "../Shaders/line.vertex";
import { DataBuffer } from '../Meshes/dataBuffer';
declare module "../Meshes/abstractMesh" {
    interface AbstractMesh {
        /**
         * Gets the edgesRenderer associated with the mesh
         */
        edgesRenderer: Nullable<EdgesRenderer>;
    }
}
declare module "../Meshes/linesMesh" {
    interface LinesMesh {
        /**
         * Enables the edge rendering mode on the mesh.
         * This mode makes the mesh edges visible
         * @param epsilon defines the maximal distance between two angles to detect a face
         * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces
         * @returns the currentAbstractMesh
         * @see https://www.babylonjs-playground.com/#19O9TU#0
         */
        enableEdgesRendering(epsilon?: number, checkVerticesInsteadOfIndices?: boolean): AbstractMesh;
    }
}
declare module "../Meshes/linesMesh" {
    interface InstancedLinesMesh {
        /**
         * Enables the edge rendering mode on the mesh.
         * This mode makes the mesh edges visible
         * @param epsilon defines the maximal distance between two angles to detect a face
         * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces
         * @returns the current InstancedLinesMesh
         * @see https://www.babylonjs-playground.com/#19O9TU#0
         */
        enableEdgesRendering(epsilon?: number, checkVerticesInsteadOfIndices?: boolean): InstancedLinesMesh;
    }
}
/**
 * Defines the minimum contract an Edges renderer should follow.
 */
export interface IEdgesRenderer extends IDisposable {
    /**
     * Gets or sets a boolean indicating if the edgesRenderer is active
     */
    isEnabled: boolean;
    /**
     * Renders the edges of the attached mesh,
     */
    render(): void;
    /**
     * Checks wether or not the edges renderer is ready to render.
     * @return true if ready, otherwise false.
     */
    isReady(): boolean;
}
/**
 * This class is used to generate edges of the mesh that could then easily be rendered in a scene.
 */
export declare class EdgesRenderer implements IEdgesRenderer {
    /**
     * Define the size of the edges with an orthographic camera
     */
    edgesWidthScalerForOrthographic: number;
    /**
     * Define the size of the edges with a perspective camera
     */
    edgesWidthScalerForPerspective: number;
    protected _source: AbstractMesh;
    protected _linesPositions: number[];
    protected _linesNormals: number[];
    protected _linesIndices: number[];
    protected _epsilon: number;
    protected _indicesCount: number;
    protected _lineShader: ShaderMaterial;
    protected _ib: DataBuffer;
    protected _buffers: {
        [key: string]: Nullable<VertexBuffer>;
    };
    protected _checkVerticesInsteadOfIndices: boolean;
    private _meshRebuildObserver;
    private _meshDisposeObserver;
    /** Gets or sets a boolean indicating if the edgesRenderer is active */
    isEnabled: boolean;
    /**
     * Creates an instance of the EdgesRenderer. It is primarily use to display edges of a mesh.
     * Beware when you use this class with complex objects as the adjacencies computation can be really long
     * @param  source Mesh used to create edges
     * @param  epsilon sum of angles in adjacency to check for edge
     * @param  checkVerticesInsteadOfIndices bases the edges detection on vertices vs indices
     * @param  generateEdgesLines - should generate Lines or only prepare resources.
     */
    constructor(source: AbstractMesh, epsilon?: number, checkVerticesInsteadOfIndices?: boolean, generateEdgesLines?: boolean);
    protected _prepareRessources(): void;
    /** @hidden */
    _rebuild(): void;
    /**
     * Releases the required resources for the edges renderer
     */
    dispose(): void;
    protected _processEdgeForAdjacencies(pa: number, pb: number, p0: number, p1: number, p2: number): number;
    protected _processEdgeForAdjacenciesWithVertices(pa: Vector3, pb: Vector3, p0: Vector3, p1: Vector3, p2: Vector3): number;
    /**
     * Checks if the pair of p0 and p1 is en edge
     * @param faceIndex
     * @param edge
     * @param faceNormals
     * @param  p0
     * @param  p1
     * @private
     */
    protected _checkEdge(faceIndex: number, edge: number, faceNormals: Array<Vector3>, p0: Vector3, p1: Vector3): void;
    /**
     * push line into the position, normal and index buffer
     * @protected
     */
    protected createLine(p0: Vector3, p1: Vector3, offset: number): void;
    /**
     * Generates lines edges from adjacencjes
     * @private
     */
    _generateEdgesLines(): void;
    /**
     * Checks wether or not the edges renderer is ready to render.
     * @return true if ready, otherwise false.
     */
    isReady(): boolean;
    /**
     * Renders the edges of the attached mesh,
     */
    render(): void;
}
/**
 * LineEdgesRenderer for LineMeshes to remove unnecessary triangulation
 */
export declare class LineEdgesRenderer extends EdgesRenderer {
    /**
     * This constructor turns off auto generating edges line in Edges Renderer to make it here.
     * @param  source LineMesh used to generate edges
     * @param  epsilon not important (specified angle for edge detection)
     * @param  checkVerticesInsteadOfIndices not important for LineMesh
     */
    constructor(source: AbstractMesh, epsilon?: number, checkVerticesInsteadOfIndices?: boolean);
    /**
     * Generate edges for each line in LinesMesh. Every Line should be rendered as edge.
     */
    _generateEdgesLines(): void;
}
