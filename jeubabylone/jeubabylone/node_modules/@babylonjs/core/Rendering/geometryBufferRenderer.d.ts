import { Matrix } from "../Maths/math";
import { SubMesh } from "../Meshes/subMesh";
import { Mesh } from "../Meshes/mesh";
import { MultiRenderTarget } from "../Materials/Textures/multiRenderTarget";
import { Effect } from "../Materials/effect";
import { Scene } from "../scene";
import { AbstractMesh } from "../Meshes/abstractMesh";
import "../Shaders/geometry.fragment";
import "../Shaders/geometry.vertex";
/** @hidden */
interface ISavedTransformationMatrix {
    world: Matrix;
    viewProjection: Matrix;
}
/**
 * This renderer is helpfull to fill one of the render target with a geometry buffer.
 */
export declare class GeometryBufferRenderer {
    /**
     * Constant used to retrieve the position texture index in the G-Buffer textures array
     * using getIndex(GeometryBufferRenderer.POSITION_TEXTURE_INDEX)
     */
    static readonly POSITION_TEXTURE_TYPE = 1;
    /**
     * Constant used to retrieve the velocity texture index in the G-Buffer textures array
     * using getIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_INDEX)
     */
    static readonly VELOCITY_TEXTURE_TYPE = 2;
    /**
     * Dictionary used to store the previous transformation matrices of each rendered mesh
     * in order to compute objects velocities when enableVelocity is set to "true"
     * @hidden
     */
    _previousTransformationMatrices: {
        [index: number]: ISavedTransformationMatrix;
    };
    /**
     * Dictionary used to store the previous bones transformation matrices of each rendered mesh
     * in order to compute objects velocities when enableVelocity is set to "true"
     * @hidden
     */
    _previousBonesTransformationMatrices: {
        [index: number]: Float32Array;
    };
    /**
     * Array used to store the ignored skinned meshes while computing velocity map (typically used by the motion blur post-process).
     * Avoids computing bones velocities and computes only mesh's velocity itself (position, rotation, scaling).
     */
    excludedSkinnedMeshesFromVelocity: AbstractMesh[];
    private _scene;
    private _multiRenderTarget;
    private _ratio;
    private _enablePosition;
    private _enableVelocity;
    private _positionIndex;
    private _velocityIndex;
    protected _effect: Effect;
    protected _cachedDefines: string;
    /**
     * Set the render list (meshes to be rendered) used in the G buffer.
     */
    renderList: Mesh[];
    /**
     * Gets wether or not G buffer are supported by the running hardware.
     * This requires draw buffer supports
     */
    readonly isSupported: boolean;
    /**
     * Returns the index of the given texture type in the G-Buffer textures array
     * @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX
     * @returns the index of the given texture type in the G-Buffer textures array
     */
    getTextureIndex(textureType: number): number;
    /**
     * Gets a boolean indicating if objects positions are enabled for the G buffer.
     */
    /**
    * Sets whether or not objects positions are enabled for the G buffer.
    */
    enablePosition: boolean;
    /**
     * Gets a boolean indicating if objects velocities are enabled for the G buffer.
     */
    /**
    * Sets wether or not objects velocities are enabled for the G buffer.
    */
    enableVelocity: boolean;
    /**
     * Gets the scene associated with the buffer.
     */
    readonly scene: Scene;
    /**
     * Gets the ratio used by the buffer during its creation.
     * How big is the buffer related to the main canvas.
     */
    readonly ratio: number;
    /** @hidden */
    static _SceneComponentInitialization: (scene: Scene) => void;
    /**
     * Creates a new G Buffer for the scene
     * @param scene The scene the buffer belongs to
     * @param ratio How big is the buffer related to the main canvas.
     */
    constructor(scene: Scene, ratio?: number);
    /**
     * Checks wether everything is ready to render a submesh to the G buffer.
     * @param subMesh the submesh to check readiness for
     * @param useInstances is the mesh drawn using instance or not
     * @returns true if ready otherwise false
     */
    isReady(subMesh: SubMesh, useInstances: boolean): boolean;
    /**
     * Gets the current underlying G Buffer.
     * @returns the buffer
     */
    getGBuffer(): MultiRenderTarget;
    /**
     * Gets the number of samples used to render the buffer (anti aliasing).
     */
    /**
    * Sets the number of samples used to render the buffer (anti aliasing).
    */
    samples: number;
    /**
     * Disposes the renderer and frees up associated resources.
     */
    dispose(): void;
    protected _createRenderTargets(): void;
    private _copyBonesTransformationMatrices;
}
export {};
