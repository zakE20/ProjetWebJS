{"version":3,"file":"outlineRenderer.js","sourceRoot":"","sources":["../../../sourceES6/core/Rendering/outlineRenderer.ts"],"names":[],"mappings":"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","sourcesContent":["import { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { _InstancesBatch } from \"../Meshes/mesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { ISceneComponent, SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\n\r\nimport \"../Shaders/outline.fragment\";\r\nimport \"../Shaders/outline.vertex\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden */\r\n        _outlineRenderer: OutlineRenderer;\r\n\r\n        /**\r\n         * Gets the outline renderer associated with the scene\r\n         * @returns a OutlineRenderer\r\n         */\r\n        getOutlineRenderer(): OutlineRenderer;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the outline renderer associated with the scene\r\n * @returns a OutlineRenderer\r\n */\r\nScene.prototype.getOutlineRenderer = function(): OutlineRenderer {\r\n    if (!this._outlineRenderer) {\r\n        this._outlineRenderer = new OutlineRenderer(this);\r\n    }\r\n    return this._outlineRenderer;\r\n};\r\n\r\ndeclare module \"../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /** @hidden (Backing field) */\r\n        _renderOutline: boolean;\r\n        /**\r\n         * Gets or sets a boolean indicating if the outline must be rendered as well\r\n         * @see https://www.babylonjs-playground.com/#10WJ5S#3\r\n         */\r\n        renderOutline: boolean;\r\n\r\n        /** @hidden (Backing field) */\r\n        _renderOverlay: boolean;\r\n        /**\r\n         * Gets or sets a boolean indicating if the overlay must be rendered as well\r\n         * @see https://www.babylonjs-playground.com/#10WJ5S#2\r\n         */\r\n        renderOverlay: boolean;\r\n    }\r\n}\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"renderOutline\", {\r\n    get: function(this: AbstractMesh) {\r\n        return this._renderOutline;\r\n    },\r\n    set: function(this: AbstractMesh, value: boolean) {\r\n        if (value) {\r\n            // Lazy Load the component.\r\n            this.getScene().getOutlineRenderer();\r\n        }\r\n        this._renderOutline = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n});\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"renderOverlay\", {\r\n    get: function(this: AbstractMesh) {\r\n        return this._renderOverlay;\r\n    },\r\n    set: function(this: AbstractMesh, value: boolean) {\r\n        if (value) {\r\n            // Lazy Load the component.\r\n            this.getScene().getOutlineRenderer();\r\n        }\r\n        this._renderOverlay = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n});\r\n\r\n/**\r\n * This class is responsible to draw bothe outline/overlay of meshes.\r\n * It should not be used directly but through the available method on mesh.\r\n */\r\nexport class OutlineRenderer implements ISceneComponent {\r\n    /**\r\n     * Stencil value used to avoid outline being seen within the mesh when the mesh is transparent\r\n     */\r\n    private static _StencilReference = 0x04;\r\n    /**\r\n     * The name of the component. Each component must have a unique name.\r\n     */\r\n    public name = SceneComponentConstants.NAME_OUTLINERENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Defines a zOffset to prevent zFighting between the overlay and the mesh.\r\n     */\r\n    public zOffset = 1;\r\n\r\n    private _engine: Engine;\r\n    private _effect: Effect;\r\n    private _cachedDefines: string;\r\n    private _savedDepthWrite: boolean;\r\n\r\n    /**\r\n     * Instantiates a new outline renderer. (There could be only one per scene).\r\n     * @param scene Defines the scene it belongs to\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this._engine = scene.getEngine();\r\n        this.scene._addComponent(this);\r\n    }\r\n\r\n    /**\r\n     * Register the component to one instance of a scene.\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);\r\n        this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated ressources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Renders the outline in the canvas.\r\n     * @param subMesh Defines the sumesh to render\r\n     * @param batch Defines the batch of meshes in case of instances\r\n     * @param useOverlay Defines if the rendering is for the overlay or the outline\r\n     */\r\n    public render(subMesh: SubMesh, batch: _InstancesBatch, useOverlay: boolean = false): void {\r\n        var scene = this.scene;\r\n        var engine = scene.getEngine();\r\n\r\n        var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null) && (batch.visibleInstances[subMesh._id] !== undefined);\r\n\r\n        if (!this.isReady(subMesh, hardwareInstancedRendering)) {\r\n            return;\r\n        }\r\n\r\n        var mesh = subMesh.getRenderingMesh();\r\n        var material = subMesh.getMaterial();\r\n\r\n        if (!material || !scene.activeCamera) {\r\n            return;\r\n        }\r\n\r\n        engine.enableEffect(this._effect);\r\n\r\n        // Logarithmic depth\r\n        if ((<any>material).useLogarithmicDepth) {\r\n            this._effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\r\n        }\r\n\r\n        this._effect.setFloat(\"offset\", useOverlay ? 0 : mesh.outlineWidth);\r\n        this._effect.setColor4(\"color\", useOverlay ? mesh.overlayColor : mesh.outlineColor, useOverlay ? mesh.overlayAlpha : material.alpha);\r\n        this._effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            this._effect.setMatrices(\"mBones\", mesh.skeleton.getTransformMatrices(mesh));\r\n        }\r\n\r\n        mesh._bind(subMesh, this._effect, Material.TriangleFillMode);\r\n\r\n        // Alpha test\r\n        if (material && material.needAlphaTesting()) {\r\n            var alphaTexture = material.getAlphaTestTexture();\r\n            if (alphaTexture) {\r\n                this._effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n                this._effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n            }\r\n        }\r\n\r\n        engine.setZOffset(-this.zOffset);\r\n\r\n        mesh._processRendering(subMesh, this._effect, Material.TriangleFillMode, batch, hardwareInstancedRendering,\r\n            (isInstance, world) => { this._effect.setMatrix(\"world\", world); });\r\n\r\n        engine.setZOffset(0);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the outline renderer is ready for a given submesh.\r\n     * All the dependencies e.g. submeshes, texture, effect... mus be ready\r\n     * @param subMesh Defines the submesh to check readyness for\r\n     * @param useInstances Defines wheter wee are trying to render instances or not\r\n     * @returns true if ready otherwise false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        var defines = [];\r\n        var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\r\n\r\n        var mesh = subMesh.getMesh();\r\n        var material = subMesh.getMaterial();\r\n\r\n        if (material) {\r\n            // Alpha test\r\n            if (material.needAlphaTesting()) {\r\n                defines.push(\"#define ALPHATEST\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    attribs.push(VertexBuffer.UVKind);\r\n                    defines.push(\"#define UV1\");\r\n                }\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                    attribs.push(VertexBuffer.UV2Kind);\r\n                    defines.push(\"#define UV2\");\r\n                }\r\n            }\r\n            //Logarithmic depth\r\n            if ((<any>material).useLogarithmicDepth) {\r\n                defines.push(\"#define LOGARITHMICDEPTH\");\r\n            }\r\n        }\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            attribs.push(\"world0\");\r\n            attribs.push(\"world1\");\r\n            attribs.push(\"world2\");\r\n            attribs.push(\"world3\");\r\n        }\r\n\r\n        // Get correct effect\r\n        var join = defines.join(\"\\n\");\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n            this._effect = this.scene.getEngine().createEffect(\"outline\",\r\n                attribs,\r\n                [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"offset\", \"color\", \"logarithmicDepthConstant\"],\r\n                [\"diffuseSampler\"], join);\r\n        }\r\n\r\n        return this._effect.isReady();\r\n    }\r\n\r\n    private _beforeRenderingMesh(mesh: AbstractMesh, subMesh: SubMesh, batch: _InstancesBatch): void {\r\n        // Outline - step 1\r\n        this._savedDepthWrite = this._engine.getDepthWrite();\r\n        if (mesh.renderOutline) {\r\n            var material = subMesh.getMaterial();\r\n            if (material && material.needAlphaBlending) {\r\n                this._engine.cacheStencilState();\r\n                // Draw only to stencil buffer for the original mesh\r\n                // The resulting stencil buffer will be used so the outline is not visible inside the mesh when the mesh is transparent\r\n                this._engine.setDepthWrite(false);\r\n                this._engine.setColorWrite(false);\r\n                this._engine.setStencilBuffer(true);\r\n                this._engine.setStencilOperationPass(Constants.REPLACE);\r\n                this._engine.setStencilFunction(Constants.ALWAYS);\r\n                this._engine.setStencilMask(OutlineRenderer._StencilReference);\r\n                this._engine.setStencilFunctionReference(OutlineRenderer._StencilReference);\r\n                this.render(subMesh, batch, /* This sets offset to 0 */ true);\r\n\r\n                this._engine.setColorWrite(true);\r\n                this._engine.setStencilFunction(Constants.NOTEQUAL);\r\n            }\r\n\r\n            // Draw the outline using the above stencil if needed to avoid drawing within the mesh\r\n            this._engine.setDepthWrite(false);\r\n            this.render(subMesh, batch);\r\n            this._engine.setDepthWrite(this._savedDepthWrite);\r\n\r\n            if (material && material.needAlphaBlending) {\r\n                this._engine.restoreStencilState();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _afterRenderingMesh(mesh: AbstractMesh, subMesh: SubMesh, batch: _InstancesBatch): void {\r\n        // Overlay\r\n        if (mesh.renderOverlay) {\r\n            var currentMode = this._engine.getAlphaMode();\r\n            this._engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n            this.render(subMesh, batch, true);\r\n            this._engine.setAlphaMode(currentMode);\r\n        }\r\n\r\n        // Outline - step 2\r\n        if (mesh.renderOutline && this._savedDepthWrite) {\r\n            this._engine.setDepthWrite(true);\r\n            this._engine.setColorWrite(false);\r\n            this.render(subMesh, batch);\r\n            this._engine.setColorWrite(true);\r\n        }\r\n    }\r\n}\r\n"]}