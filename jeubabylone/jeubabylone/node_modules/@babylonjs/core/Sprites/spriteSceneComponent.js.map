{"version":3,"file":"spriteSceneComponent.js","sourceRoot":"","sources":["../../../sourceES6/core/Sprites/spriteSceneComponent.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Scene } from \"../scene\";\r\nimport { Sprite } from \"./sprite\";\r\nimport { ISpriteManager } from \"./spriteManager\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { ISceneComponent, SceneComponentConstants } from \"../sceneComponent\";\r\nimport { ActionEvent } from \"../Actions/actionEvent\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @hidden */\r\n        _pointerOverSprite: Nullable<Sprite>;\r\n\r\n        /** @hidden */\r\n        _pickedDownSprite: Nullable<Sprite>;\r\n\r\n        /** @hidden */\r\n        _tempSpritePickingRay: Nullable<Ray>;\r\n\r\n        /**\r\n         * All of the sprite managers added to this scene\r\n         * @see http://doc.babylonjs.com/babylon101/sprites\r\n         */\r\n        spriteManagers: Array<ISpriteManager>;\r\n\r\n        /**\r\n         * An event triggered when sprites rendering is about to start\r\n         * Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)\r\n         */\r\n        onBeforeSpritesRenderingObservable: Observable<Scene>;\r\n\r\n        /**\r\n         * An event triggered when sprites rendering is done\r\n         * Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)\r\n         */\r\n        onAfterSpritesRenderingObservable: Observable<Scene>;\r\n\r\n        /** @hidden */\r\n        _internalPickSprites(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /** Launch a ray to try to pick a sprite in the scene\r\n         * @param x position on screen\r\n         * @param y position on screen\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param fastCheck Launch a fast check only using the bounding boxes. Can be set to null.\r\n         * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo\r\n         */\r\n        pickSprite(x: number, y: number, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /** Use the given ray to pick a sprite in the scene\r\n         * @param ray The ray (in world space) to use to pick meshes\r\n         * @param predicate Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true\r\n         * @param fastCheck Launch a fast check only using the bounding boxes. Can be set to null.\r\n         * @param camera camera to use. Can be set to null. In this case, the scene.activeCamera will be used\r\n         * @returns a PickingInfo\r\n         */\r\n        pickSpriteWithRay(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo>;\r\n\r\n        /**\r\n         * Force the sprite under the pointer\r\n         * @param sprite defines the sprite to use\r\n         */\r\n        setPointerOverSprite(sprite: Nullable<Sprite>): void;\r\n\r\n        /**\r\n         * Gets the sprite under the pointer\r\n         * @returns a Sprite or null if no sprite is under the pointer\r\n         */\r\n        getPointerOverSprite(): Nullable<Sprite>;\r\n    }\r\n}\r\n\r\nScene.prototype._internalPickSprites = function(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n\r\n    var pickingInfo = null;\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    if (this.spriteManagers.length > 0) {\r\n        for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\r\n            var spriteManager = this.spriteManagers[spriteIndex];\r\n\r\n            if (!spriteManager.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            var result = spriteManager.intersects(ray, camera, predicate, fastCheck);\r\n            if (!result || !result.hit) {\r\n                continue;\r\n            }\r\n\r\n            if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n                continue;\r\n            }\r\n\r\n            pickingInfo = result;\r\n\r\n            if (fastCheck) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n};\r\n\r\nScene.prototype.pickSprite = function(x: number, y: number, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    this.createPickingRayInCameraSpaceToRef(x, y, this._tempSpritePickingRay!, camera);\r\n\r\n    return this._internalPickSprites(this._tempSpritePickingRay!, predicate, fastCheck, camera);\r\n};\r\n\r\nScene.prototype.pickSpriteWithRay = function(ray: Ray, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n    if (!this._tempSpritePickingRay) {\r\n        return null;\r\n    }\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return null;\r\n        }\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    Ray.TransformToRef(ray, camera.getViewMatrix(), this._tempSpritePickingRay);\r\n\r\n    return this._internalPickSprites(this._tempSpritePickingRay, predicate, fastCheck, camera);\r\n};\r\n\r\nScene.prototype.setPointerOverSprite = function(sprite: Nullable<Sprite>): void {\r\n    if (this._pointerOverSprite === sprite) {\r\n        return;\r\n    }\r\n\r\n    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\r\n        this._pointerOverSprite.actionManager.processTrigger(Constants.ACTION_OnPointerOutTrigger, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\r\n    }\r\n\r\n    this._pointerOverSprite = sprite;\r\n    if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\r\n        this._pointerOverSprite.actionManager.processTrigger(Constants.ACTION_OnPointerOverTrigger, ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\r\n    }\r\n};\r\n\r\nScene.prototype.getPointerOverSprite = function(): Nullable<Sprite> {\r\n    return this._pointerOverSprite;\r\n};\r\n\r\n/**\r\n * Defines the sprite scene component responsible to manage sprites\r\n * in a given scene.\r\n */\r\nexport class SpriteSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_SPRITE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /** @hidden */\r\n    private _spritePredicate: (sprite: Sprite) => boolean;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.spriteManagers = new Array<ISpriteManager>();\r\n        this.scene._tempSpritePickingRay = Ray ? Ray.Zero() : null;\r\n        this.scene.onBeforeSpritesRenderingObservable = new Observable<Scene>();\r\n        this.scene.onAfterSpritesRenderingObservable = new Observable<Scene>();\r\n        this._spritePredicate = (sprite: Sprite): boolean => {\r\n            if (!sprite.actionManager) {\r\n                return false;\r\n            }\r\n            return sprite.isPickable && sprite.actionManager.hasPointerTriggers;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._pointerMoveStage.registerStep(SceneComponentConstants.STEP_POINTERMOVE_SPRITE, this, this._pointerMove);\r\n        this.scene._pointerDownStage.registerStep(SceneComponentConstants.STEP_POINTERDOWN_SPRITE, this, this._pointerDown);\r\n        this.scene._pointerUpStage.registerStep(SceneComponentConstants.STEP_POINTERUP_SPRITE, this, this._pointerUp);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        /** Nothing to do for sprites */\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated ressources.\r\n     */\r\n    public dispose(): void {\r\n        this.scene.onBeforeSpritesRenderingObservable.clear();\r\n        this.scene.onAfterSpritesRenderingObservable.clear();\r\n\r\n        let spriteManagers = this.scene.spriteManagers;\r\n        while (spriteManagers.length) {\r\n            spriteManagers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _pickSpriteButKeepRay(originalPointerInfo: Nullable<PickingInfo>, x: number, y: number, fastCheck?: boolean, camera?: Camera): Nullable<PickingInfo> {\r\n        var result = this.scene.pickSprite(x, y, this._spritePredicate, fastCheck, camera);\r\n        if (result) {\r\n            result.ray = originalPointerInfo ? originalPointerInfo.ray : null;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private _pointerMove(unTranslatedPointerX: number, unTranslatedPointerY: number, pickResult: Nullable<PickingInfo>, isMeshPicked: boolean, canvas: HTMLCanvasElement): Nullable<PickingInfo> {\r\n        var scene = this.scene;\r\n        if (isMeshPicked) {\r\n            scene.setPointerOverSprite(null);\r\n        } else {\r\n            pickResult = this._pickSpriteButKeepRay(pickResult, unTranslatedPointerX, unTranslatedPointerY, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (pickResult && pickResult.hit && pickResult.pickedSprite) {\r\n                scene.setPointerOverSprite(pickResult.pickedSprite);\r\n                if (scene._pointerOverSprite && scene._pointerOverSprite.actionManager && scene._pointerOverSprite.actionManager.hoverCursor) {\r\n                    canvas.style.cursor = scene._pointerOverSprite.actionManager.hoverCursor;\r\n                } else {\r\n                    canvas.style.cursor = scene.hoverCursor;\r\n                }\r\n            } else {\r\n                scene.setPointerOverSprite(null);\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n\r\n    private _pointerDown(unTranslatedPointerX: number, unTranslatedPointerY: number, pickResult: Nullable<PickingInfo>, evt: PointerEvent): Nullable<PickingInfo> {\r\n        var scene = this.scene;\r\n        scene._pickedDownSprite = null;\r\n        if (scene.spriteManagers.length > 0) {\r\n            pickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (pickResult && pickResult.hit && pickResult.pickedSprite) {\r\n                if (pickResult.pickedSprite.actionManager) {\r\n                    scene._pickedDownSprite = pickResult.pickedSprite;\r\n                    switch (evt.button) {\r\n                        case 0:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(Constants.ACTION_OnLeftPickTrigger, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\r\n                            break;\r\n                        case 1:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(Constants.ACTION_OnCenterPickTrigger, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\r\n                            break;\r\n                        case 2:\r\n                            pickResult.pickedSprite.actionManager.processTrigger(Constants.ACTION_OnRightPickTrigger, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\r\n                            break;\r\n                    }\r\n                    if (pickResult.pickedSprite.actionManager) {\r\n                        pickResult.pickedSprite.actionManager.processTrigger(Constants.ACTION_OnPickDownTrigger, ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, scene, evt));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n\r\n    private _pointerUp(unTranslatedPointerX: number, unTranslatedPointerY: number, pickResult: Nullable<PickingInfo>, evt: PointerEvent): Nullable<PickingInfo> {\r\n        var scene = this.scene;\r\n        if (scene.spriteManagers.length > 0) {\r\n            let spritePickResult = scene.pickSprite(unTranslatedPointerX, unTranslatedPointerY, this._spritePredicate, false, scene.cameraToUseForPointers || undefined);\r\n\r\n            if (spritePickResult) {\r\n                if (spritePickResult.hit && spritePickResult.pickedSprite) {\r\n                    if (spritePickResult.pickedSprite.actionManager) {\r\n                        spritePickResult.pickedSprite.actionManager.processTrigger(Constants.ACTION_OnPickUpTrigger, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\r\n                        if (spritePickResult.pickedSprite.actionManager) {\r\n                            if (!this.scene._inputManager._isPointerSwiping()) {\r\n                                spritePickResult.pickedSprite.actionManager.processTrigger(Constants.ACTION_OnPickTrigger, ActionEvent.CreateNewFromSprite(spritePickResult.pickedSprite, scene, evt));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (scene._pickedDownSprite && scene._pickedDownSprite.actionManager && scene._pickedDownSprite !== spritePickResult.pickedSprite) {\r\n                    scene._pickedDownSprite.actionManager.processTrigger(Constants.ACTION_OnPickOutTrigger, ActionEvent.CreateNewFromSprite(scene._pickedDownSprite, scene, evt));\r\n                }\r\n            }\r\n        }\r\n\r\n        return pickResult;\r\n    }\r\n}\r\n"]}