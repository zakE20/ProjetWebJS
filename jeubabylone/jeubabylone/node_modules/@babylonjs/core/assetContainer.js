import * as tslib_1 from "tslib";
import { AbstractScene } from "./abstractScene";
import { Mesh } from "./Meshes/mesh";
/**
 * Set of assets to keep when moving a scene into an asset container.
 */
var KeepAssets = /** @class */ (function (_super) {
    tslib_1.__extends(KeepAssets, _super);
    function KeepAssets() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return KeepAssets;
}(AbstractScene));
export { KeepAssets };
/**
 * Container with a set of assets that can be added or removed from a scene.
 */
var AssetContainer = /** @class */ (function (_super) {
    tslib_1.__extends(AssetContainer, _super);
    /**
     * Instantiates an AssetContainer.
     * @param scene The scene the AssetContainer belongs to.
     */
    function AssetContainer(scene) {
        var _this = _super.call(this) || this;
        _this.scene = scene;
        _this["sounds"] = [];
        _this["effectLayers"] = [];
        _this["layers"] = [];
        _this["lensFlareSystems"] = [];
        _this["proceduralTextures"] = [];
        _this["reflectionProbes"] = [];
        return _this;
    }
    /**
     * Adds all the assets from the container to the scene.
     */
    AssetContainer.prototype.addAllToScene = function () {
        var _this = this;
        this.cameras.forEach(function (o) {
            _this.scene.addCamera(o);
        });
        this.lights.forEach(function (o) {
            _this.scene.addLight(o);
        });
        this.meshes.forEach(function (o) {
            _this.scene.addMesh(o);
        });
        this.skeletons.forEach(function (o) {
            _this.scene.addSkeleton(o);
        });
        this.animations.forEach(function (o) {
            _this.scene.addAnimation(o);
        });
        this.animationGroups.forEach(function (o) {
            _this.scene.addAnimationGroup(o);
        });
        this.multiMaterials.forEach(function (o) {
            _this.scene.addMultiMaterial(o);
        });
        this.materials.forEach(function (o) {
            _this.scene.addMaterial(o);
        });
        this.morphTargetManagers.forEach(function (o) {
            _this.scene.addMorphTargetManager(o);
        });
        this.geometries.forEach(function (o) {
            _this.scene.addGeometry(o);
        });
        this.transformNodes.forEach(function (o) {
            _this.scene.addTransformNode(o);
        });
        this.actionManagers.forEach(function (o) {
            _this.scene.addActionManager(o);
        });
        this.textures.forEach(function (o) {
            _this.scene.addTexture(o);
        });
        this.reflectionProbes.forEach(function (o) {
            _this.scene.addReflectionProbe(o);
        });
        if (this.environmentTexture) {
            this.scene.environmentTexture = this.environmentTexture;
        }
        for (var _i = 0, _a = this.scene._serializableComponents; _i < _a.length; _i++) {
            var component = _a[_i];
            component.addFromContainer(this);
        }
    };
    /**
     * Removes all the assets in the container from the scene
     */
    AssetContainer.prototype.removeAllFromScene = function () {
        var _this = this;
        this.cameras.forEach(function (o) {
            _this.scene.removeCamera(o);
        });
        this.lights.forEach(function (o) {
            _this.scene.removeLight(o);
        });
        this.meshes.forEach(function (o) {
            _this.scene.removeMesh(o);
        });
        this.skeletons.forEach(function (o) {
            _this.scene.removeSkeleton(o);
        });
        this.animations.forEach(function (o) {
            _this.scene.removeAnimation(o);
        });
        this.animationGroups.forEach(function (o) {
            _this.scene.removeAnimationGroup(o);
        });
        this.multiMaterials.forEach(function (o) {
            _this.scene.removeMultiMaterial(o);
        });
        this.materials.forEach(function (o) {
            _this.scene.removeMaterial(o);
        });
        this.morphTargetManagers.forEach(function (o) {
            _this.scene.removeMorphTargetManager(o);
        });
        this.geometries.forEach(function (o) {
            _this.scene.removeGeometry(o);
        });
        this.transformNodes.forEach(function (o) {
            _this.scene.removeTransformNode(o);
        });
        this.actionManagers.forEach(function (o) {
            _this.scene.removeActionManager(o);
        });
        this.textures.forEach(function (o) {
            _this.scene.removeTexture(o);
        });
        this.reflectionProbes.forEach(function (o) {
            _this.scene.removeReflectionProbe(o);
        });
        if (this.environmentTexture === this.scene.environmentTexture) {
            this.scene.environmentTexture = null;
        }
        for (var _i = 0, _a = this.scene._serializableComponents; _i < _a.length; _i++) {
            var component = _a[_i];
            component.removeFromContainer(this);
        }
    };
    /**
     * Disposes all the assets in the container
     */
    AssetContainer.prototype.dispose = function () {
        this.cameras.forEach(function (o) {
            o.dispose();
        });
        this.cameras = [];
        this.lights.forEach(function (o) {
            o.dispose();
        });
        this.lights = [];
        this.meshes.forEach(function (o) {
            o.dispose();
        });
        this.meshes = [];
        this.skeletons.forEach(function (o) {
            o.dispose();
        });
        this.skeletons = [];
        this.animationGroups.forEach(function (o) {
            o.dispose();
        });
        this.animationGroups = [];
        this.multiMaterials.forEach(function (o) {
            o.dispose();
        });
        this.multiMaterials = [];
        this.materials.forEach(function (o) {
            o.dispose();
        });
        this.materials = [];
        this.geometries.forEach(function (o) {
            o.dispose();
        });
        this.geometries = [];
        this.transformNodes.forEach(function (o) {
            o.dispose();
        });
        this.transformNodes = [];
        this.actionManagers.forEach(function (o) {
            o.dispose();
        });
        this.actionManagers = [];
        this.textures.forEach(function (o) {
            o.dispose();
        });
        this.textures = [];
        this.reflectionProbes.forEach(function (o) {
            o.dispose();
        });
        this.reflectionProbes = [];
        if (this.environmentTexture) {
            this.environmentTexture.dispose();
            this.environmentTexture = null;
        }
        for (var _i = 0, _a = this.scene._serializableComponents; _i < _a.length; _i++) {
            var component = _a[_i];
            component.removeFromContainer(this, true);
        }
    };
    AssetContainer.prototype._moveAssets = function (sourceAssets, targetAssets, keepAssets) {
        if (!sourceAssets) {
            return;
        }
        for (var _i = 0, sourceAssets_1 = sourceAssets; _i < sourceAssets_1.length; _i++) {
            var asset = sourceAssets_1[_i];
            var move = true;
            if (keepAssets) {
                for (var _a = 0, keepAssets_1 = keepAssets; _a < keepAssets_1.length; _a++) {
                    var keepAsset = keepAssets_1[_a];
                    if (asset === keepAsset) {
                        move = false;
                        break;
                    }
                }
            }
            if (move) {
                targetAssets.push(asset);
            }
        }
    };
    /**
     * Removes all the assets contained in the scene and adds them to the container.
     * @param keepAssets Set of assets to keep in the scene. (default: empty)
     */
    AssetContainer.prototype.moveAllFromScene = function (keepAssets) {
        if (keepAssets === undefined) {
            keepAssets = new KeepAssets();
        }
        for (var key in this) {
            if (this.hasOwnProperty(key)) {
                this[key] = this[key] || [];
                this._moveAssets(this.scene[key], this[key], keepAssets[key]);
            }
        }
        this.removeAllFromScene();
    };
    /**
     * Adds all meshes in the asset container to a root mesh that can be used to position all the contained meshes. The root mesh is then added to the front of the meshes in the assetContainer.
     * @returns the root mesh
     */
    AssetContainer.prototype.createRootMesh = function () {
        var rootMesh = new Mesh("assetContainerRootMesh", this.scene);
        this.meshes.forEach(function (m) {
            if (!m.parent) {
                rootMesh.addChild(m);
            }
        });
        this.meshes.unshift(rootMesh);
        return rootMesh;
    };
    return AssetContainer;
}(AbstractScene));
export { AssetContainer };
//# sourceMappingURL=assetContainer.js.map